## 1、Redis 是什么？

Redis（**Remote Dictonary Server**），即远程字典服务，是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 非关系型数据库，并提供多种语言的 API。
Redis 支持多种类型的数据结构，如字符串（strings）、列表（lists）、集合（sets）、有序集合（sotred sets）、哈希表（hashes）、位图（bitmaps）、超日志（hyperlogs）以及地理空间（geospatial）索引等，使得它不仅可以用作简单的键值存储，还能支持复杂的数据结构操作，满足多种不同的应用场景。
Redis 的出现，很大程度补偿了 Memcached 这类 Key-Value 存储的不足，在部分场合可以对关系数据库起到很好的补充作用，它提供了 Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Erlang 等客户端，使用很方便。

## 2、Redis 有哪些应用场景？

##### 1、缓存

缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能打打降低数据库的压力。Redis 提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在 Redis 用在缓存的场合非常多。

##### 2、排行榜

很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis 提供的有序集合数据类构能实现各种复杂的排行榜应用。

##### 3、计数器

什么是计数器，如电商网站商品的浏览量、视频网站视频的播放量等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis 提供的 incr 命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。

##### 4、分布式会话

集群模式下，在应用不多的情况下一般使用容器自带的 session 复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理。

##### 5、分布式锁

在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局 ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的长河中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用 Redis 的 setnx 功能来编写分布式的锁，如果设置返回 1 说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。

##### 6、社交网络

点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis 提供的哈希、集合等数据结构能很方便的实现这些功能。

##### 7、最新列表

Redis 列表结构，LPUSH 可以在列表头部插入一个内容 ID 作为关键字，LTRIM 可用来限制列表的数量，这样列表永远为 N 个 ID，无需查询最新的列表，直接根据 ID 去到对应的内容页即可。

##### 8、消息系统

消息队列是大型网站必用中间件，如 ActiveMQ、RabbitMQ、Kafka 等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis 提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

## 3、Redis 有什么优势？

##### 1、性能高，速度快

Redis 命令执行速度非常快，官方给出的读写性能可以达到 10W/秒。

为什么会如此之快呢？由以下几个因素：

- 数据存储在内存中，直接与内存连接。
- 由相对底层的 C 语言实现，离操作系统更近。
- 实现源码很精湛，仅仅几万行代码，简单稳定。
- 使用了单线程模型，无多线程竞争、锁等问题。

##### 2、丰富的数据结构

Redis 与其他的内存数据库不同的是，Redis 拥有丰富的数据类型，如字符串、哈希、列表、集合、有序集合等。正是因为 Redis 丰富的数据类型，所有它能应用的场景非常多。

##### 3、丰富的特性

除了支持丰富的数据结果外，还支持以下高级功能：

- 支持建过期功能，可以用来实现定时缓存。
- 支持发布/订阅功能，可以用来实现消息队列。
- 支持事务功能，可以保证多条命令的事务型。
- 支持管道功能，能够批量处理命令。
- 支持 Luau 脚本功能。
- 支持集群分片和数据复制功能。
- 支持内存数据持久化硬盘功能。

##### 4、丰富的客户端

> 官方索引：http://www.redis.cn/clients.html

从官网给出的客户端列表可以看出，各种各样的语言都能接入到 Redis，接入包括了所有的主流开发语言。

目前使用 Redis 的公司非常多，国内外都有很多重量级的公司在用。所以，现在学习 Redis 是大势所趋，学好 Redis 能为自己在日后的工作谋生中增加一个强有利的竞争手段。

## 4、Redis 为什么这么快？

##### 1、基于内存的存储

Redis 将所有数据存储在内存中，内存的访问速度远远超过任何类型的磁盘存储。这种设计使得数据的读写非常快，几乎可以达到微秒级别的延迟。

##### 2、高效的数据结构

Redis 使用高效的数据结构来存储和访问数据，如字符串、列表、集合、哈希表等，这些数据结构经过优化，以支持快速的数据操作和访问。

##### 3、单线程模型

Redis 的操作大多数是单线程的，单线程也使得 Redis 的设计更简单，减少了锁的开销，避免了多线程环境中的上下文切换和竞争条件。

##### 4、非阻塞 I/O

Redis 使用非阻塞 I/O 和多路复用技术，者允许 Redis 在单线程中高效地处理多个客户端的连接和请求，而不会因为 IO 操作而阻塞。

## 5、Redis 主要消耗什么物理资源？

Redis 是内存数据库，所以主要消耗的肯定是内存，当然还包括 CPU、网络、磁盘等资源。

##### 1、内存

Redis 是一种基于内存的数据结构的服务器，它将所有数据存储在内存中以实现高速访问，所以，内存是 Redis 最主要的资源消耗。

##### 2、CPU

Redis 是单线程模型，它使用单个 CPU 核心来处理命令。虽然 Redis 的 CPU 使用率通常不会很高，但在处理大量命令或执行复杂操作时，CPU 可能会成为性能瓶颈。

##### 3、网络

Redis 通过网络与客户端进行通信，处理大量的并发连接和数据传输，因此，网络带宽和延迟也会影响 Redis 的性能。

##### 4、磁盘

虽然 Redis 主要在内存中操作数据，但它也提供了持久化功能，将数据保存到磁盘上。这样做的目的是为了在服务器重启后能够恢复数据。

## 6、Redis 为什么把所有数据放到内存中？

因为 Redis 的定位就是一个内存数据库。

**内存的读取速度是最快的**，如果放到硬盘，磁盘 IO 的速度势必会严重影响 Redis 的性能，那就和一般的关系数据库相比没什么优势可言，而且随着现在内存硬件成本的降低，内存已经不是问题，性能才是关键，现在硬盘只是成为了一种持久化方案而已。

## 7、Redis 命令是原子性的吗？

Redis 中的大多数命令**是原子性的**，因为 Redis 是单线程的，一个操作要么执行，要么不执行，不会被其他线程打断，可以保证在多线程或多进程环境下的并发访问安全性。

但是，也有一些命令不是原子性的，比如，**WATCH**命令和事务相关的命令（如**MULIT**、**EXEC**、**DISCARD**等）都不是原子性的，因为它们需要与其他命令配合使用，以提供事务功能和乐观锁功能。

## 8、Redis 磁盘快照操作是原子的吗？

是的，Redis 任何命令在内存中是原子操作的，在磁盘快照里同样也是原子的，在快照过程中，Redis 能够保证生成的 RDB 文件在任何时刻都是数据一致性的快照，即使在快照进行时还有新的写入操作发生。

> 需要注意的是：
>
> 虽然快照操作本身是原子的，但是如果在快照生成过程中 Redis 服务器发生崩溃，那么正在生成的快照文件可能会不完整，因此在使用 RDB 持久化时，还需要考虑适当的备份和故障恢复策略。

## 9、Redis 怎么测试连通性？

先连接上 Redis，再使用 ping 指令。

示例如下：

> $ redis-cli -h 127.0.0.1 -p 679 -a 123456
>
> 127.0.0.1:6379 > ping
>
> PONG
>
> 127.0.0.1:6379 >

## 10、Redis 到底是单线程还是多线程？

Redis 是单线程模型，指的是执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。

##### Redis 不仅仅只是单线程。

其实，Redis 4.0 开始就有多线程的概念了，比如 Redis 通过多线程方式在后台删除对象、以及通过 Redis 模块实现的阻塞命令等：

![](/images/Redis/10_1.jpg)

Redis 6 中也有一个被说了很久的多线程 IO：

![](/images/Redis/10_2.jpg)

这个 Theaded IO 指的是**在网络 IO 处理方面上了多线程，如网络数据的读写和协议解析等**，需要注意的是，执行命令的核心模块还是单线程的。

##### 为什么网络处理要引入多线程？

一般来说，Redis 的瓶颈并不在 CPU，而在内存和网络。

内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分作成多线程处理方式，那对整个 Redis 的性能会有很大的提升。

## 11、Redis 和 Memcache 有什么区别？

最主要的几个区别：

##### 1、存储方式

Redis 支持数据持久性， 可以持久化数据到硬盘上。

Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。

##### 2、数据类型

Redis 有丰富的数据结构，Memecache 只支持简单的字符串类型。

##### 3、数据大小

Redis 单个 value 的最大限制是 512MB，

Memecache 最大限制是 1MB。

但是 Memecache 在存储 100K 以上的数据，性能稍微好一点。

## 12、分布式缓存为什么要用 Redis，而不是用 Map 或 Guava 本地缓存？

#### 1、分布式环境

##### Redis：

Redis 是一个基于内存的键值存储系统，非常适合于分布式系统，它可以被多个应用实例共享，支持跨多个服务器的数据分片、共享和同步。

##### Map 或 Guava：

Java 的 Map 或 Guava 本地缓存通常只限于单个 JVM 实例，在分布式应用中，每个实例的缓存是独立的，不能在多个服务器之间共享状态。

#### 2、持久化能力

##### Redis：

Redis 支持数据持久化，可以将内存中的数据保存到硬盘中，即使系统重启数据也不会丢失。

##### Map 或 Guava：

标准的 Map 或 Guava 缓存不提供持久化功能，如果应用程序停止或服务器重启，所有存储在本地缓存中的数据都会丢失。

#### 3、内存管理

##### Redis：

Redis 作为一个独立的服务运行，具有高效的内存管理机制。它允许配置最大内存使用量，并可以通过 LRU 等算法自动淘汰老旧数据，能够有效防止内存泄露和内存满载问题。

##### Map 或 Guava：

Map 或 Guava 缓存使用的是 JVM 的内存，需要开发者自行管理内存使用和数据的有效期，容易出现内存溢出的风险，并且缓存大小不易控制，过多使用本地缓存可能会影响应用程序的其他部分。

#### 4、高级数据结构和功能

##### Redis：

Redis 提供了丰富的数据结构，如字符串、哈希、列表、集合、有序集合等，以及这些数据结构上的各种原子操作，非常适合解决复杂的缓存和消息传递问题。

##### Map 或 Guava：

Java 的 Map 接口较为简单，主要支持基本的键值存储。Guava 提供了一些扩展的集合功能，如多值映射、双向映射等，但与 Redis 相比仍较为有限。

##### 5、其他能力

Redis 是专业的缓存系统，相比 Map 或 Guava 更加强大和专业，此处，还提供了丰富的 API 和高级功能，比如：过期时间设置，事务等等，并且性能也非常强悍，可以满足高并发场景下各种复杂业务问题的处理。

## 13、Redis 支持哪些数据类型？

Redis 支持多种数据类型，使得它能够用于各种不同的应用场景。

以下是 Redis 支持的主要数据类型：

##### 1、字符串（String）

字符串是 Redis 最基本的数据类型，可以存储任何形式的字符串，包括文本数据或二进制数据，如 JPEG 图像的内容。

##### 2、列表（List）

列表是简单的字符串链表，适用于存储一系列的元素，可用于实现队列（）或栈（）等数据结构。列表中的元素可以在列表的头部或尾部添加，并且可以从列表中检索元素。

##### 3、集合（Set）

集合是字符串的无序收集，并且保证集合中没有重复的元素。它支持添加、删除和测试元素是否存在等操作，集合之间进行并集、交集和差集等集合运算。

##### 4、有序集合（Sotred Set）

有序集合也叫 ZSet，它与集合类似，但是每个元素都会关联一个浮点数的分数（），Redis 根据分数来为集合中的成员进行从小到大的排序。

有序集合适用于需要按照范围和排序检索元素的场景，比如排行榜。

##### 5、哈希（Hash）

哈希是键值对的集合，适合存储对象，每个哈希可以存储多个键值对，这些键值对都是字符串类型。

##### 6、位图（Bitmap）

位图适合进行大规模、底层级的布尔值存储，位图本质上是字符串，但是可以对字符串的位进行操作，比如计算位值为 1 的数量、设置位值等。

##### 7、HyperLogLog

HyperLogLog 是一种概率性数据结构，可以用很小的内存空间估计非常大的数据集的基数（不同元素的数量），比如统计网站访问中的独立 IP 数。

##### 8、地理空间（Geospatial）

Redis 的地理空间数据类型允许将地理位置信息（经度和纬度）存储在集合中，并对这些信息进行查询，如计算两个地点之间的距离、查找给定区域内的地点等。

##### 9、Streams

Redis 5.0 版本引入了 Streams 数据类型，这是一个由多个条目组成的日志数据结构，条目是包含一组键值对的数据。Streams 主要用于消息队列和日志应用，支持消费者组和消息持久化等功能。

---

从 Redis 4.0 版本开始，通过模块系统，开发者可以扩展 Redis 的功能，如可以自定义数据类型，比如 RedisJSON 模块可以用来存储和操作 JSON 对象，而 RedisGraph 模块提供了图数据库的特性。

## 14、Redis 支持 JSON 数据类型吗？为什么？

在 Redis 的原生数据类型中，没有专门用于存储 JSON 的数据类型。

你可以将 JSON 字符串作为普通的字符串存储在 Redis 中，**但 Redis 不会理解这个字符串的 JSON 结构，也无法对 JSON 数据进行结构化的查询和操作。**

然而，从 Redis 4.0 版本开始，Redis 引入了模块系统，它允许开发者使用 C 语言编写扩展模块，增强 Redis 的功能。借助这个特性，Redis 社区开发了一些模块来支持 JSON 数据类型，如 RedisJSON。

模块名：**RedisJSON**

模块地址：https://oss.redis.com/redisjson/

![](/images/Redis/14.jpg)

RedisJSON 是一个 Redis 模块，它为 Redis 提供了完整的 JSON 支持。通过 RedisJSON，你可以将 JSON 文档存储在 Redis 中，并且可以对 JSON 文档进行结构化的查询和操作，比如获取或修改 JSON 文档的某个字段，或者对 JSON 数组进行添加、删除等操作。

为什么 Redis 原生不支持 JSON 数据类型，这当然是为了 Redis 的简洁性、性能考虑。

## 15、Redis 模块系统有什么用？

Redis 中的模块系统：**Redis Modules System**，是 Redis 4.0 中的重大改进，它允许开发者使用 C 语言编写扩展模块，增强 Redis 的功能。

通过模块系统，我们可以对 Redis 的功能进行动态扩展，如果官方不支持的功能，我们可以开发一个模块进行支持，还可以自定义数据类型、命令，甚至改变 Redis 的行为。

## 16、Redis 支持对象映射模型吗？

Redis 重磅官宣：RedisOM 发布，即：**Object Mapping**，支持对象映射，像操作对象一样操作 Redis! !

当然，Redis OM 的横空出世不仅仅是对象映射它更多的是提供一个高级的抽象类库，目标就是让开发人员更简单、方便的使用 Redis 数据。

Redis OM 支持的第一个抽象就是：**对象映射**，支持基于对象的 Redis 数据持久化、流式查询操作。

目前只支持 4 种开发语言：

- Redis OM for Spring （Java）
- Redis OM for Node.js
- Redis OM for Python

相信后续会支持更多语言。

## 17、Redis 默认支持多少个数据库？怎么修改？

Redis 默认支持 16 个数据库，可以通过修改 Redis 配置文件 redis.conf 中的 databases 一值进行变更。

如修改为 20 个：

```
databases 20
```

Redis 不会限制最大的数据库数量，但是会限制最小数据库数量为 1 个。

默认的数据库是 0，可以通过 SELECT 命令来切换，如：

> SELECT 12

## 18、Redis SET 命令可以代替 SETNX 吗？

##### 答案：看版本，目前的版本肯定可以了。

从 2.6.12 版本开始，Redis 为 SET 命令增加了一系列选项：

- `EX`seconds - 设置键 key 的过期时间，单位：秒；
- `PX` milliseconds - 设置键 key 的过期时间，单位：毫秒；
- `NX` - 只有键 key 不存在的时候才会设置 key 的值；
- `XX` - 只有键 key 存在的时候才会设置 key 的值；

SET 命令加上这些选项，已经可以完全取代**SETNX，SETEX，PSETEX**的功能。

这样做的好处是`SET`命令提供了更多的灵活性，你可以在同一个命令种设置过期时间和其他选项，而`SETNX`命令则只提供了基本的设置功能。

所以在将来的版本中，Redis 可能不推荐使用这些命令了，并且最终抛弃这几个命令。

## 19、Redis 单个实例最多能存放多少个键？

Redis 最大可以存放**2^32**个键值，即如果没有设置最大内存，Redis 存储极限是服务器最大可用内存值。

## 20、Redis 单个 Set，List 最多能存放多少个元素？

单个 List、Set、Sotred Set 都可以放 2^32 个元素。

## 21、Redis 最大 key 大小？

据官方文档介绍：

> The maximum allowed key size is 512MB.

Redis 的 key 最大可以是**512MB**。

虽然我们可以使用非常长的字符串作为 key，但在实际应用中，**建议使用更短的 key，因为过长的 key 会消耗更多的内存，也可能影响 Redis 的性能**。

此外，虽然 Redis 支持很长的 key，但在设计 key 的时候应该考虑到可读性和管理的便捷性。

## 22、Redis String 值最大存储多少？

A value can't be bigger than **512MB**.

根据 Redis 的官方文档，每个 String 值最大可以存储 512MB 的数据，这个限制是为了确保性能和内存管理的可行性，因为 Redis 是一个内存存储系统，设计之初也就是为了能快速读写。

## 23、Redis String 底层是怎么设计的？

Redis 的 String 类型最基本的数据类型，它能够存储任何二进制数据。

Redis 的 String 类型底层实现是基于一个名为**SDS（Simple Dynamic String，简单动态字符串）**的数据结构。SDS 提供了对动态字符串的操作，他的设计目标是能够高效地处理字符串，同时尽可能地降低内存重新分配地次数。

下面是 SDS 地头部结构代码：

```java
typedef char *sds;

struct sdshdr {

    // 已用长度
    int len;

    // 可用长度
    int free;

    // 保存字符串地字节数组
    char buf[];
};
```

SDS 地数据结构如下：

![](/images/Redis/23.jpg)

包含以下几个部分：

- free：表示字符串地可用长度，也就是字符串中可以增加地字符数量，而不需要进行内存重新分配。
- len：表示字符串地占用长度，也就是字符串中实际字符地数量。
- buf：是一个字节数组，用于存储实际地字符串。这个数组的长度 len + free + 1，多出来的 1 是为了存储字符串的结束符'\0'，用于兼容部分 C 语言标准库的函数。

## 24、Redis 为什么要把字符串设计成 SDS？

Redis 是使用 C 语言编写的，但是 Redis 中的字符串并没有使用 C 语言中的 char\*字符数组来实现，反而使用自己重新设计的 SDS 来实现，主要是为了解决 C 语言原生字符串在某些场景下的局限性。

##### 1、二进制安全

C 语言的字符串是以'\0'作为结束标志的，中间不能包含'\0'字符，所以它只能保存文本数据，不能保存二进制数据。

SDS 记录了字符串的实际长度，可以包含任何二级制数据，包括'\0'。

##### 2、避免缓冲区溢出

C 语言的字符串不记录自身长度，如果执行拼接字符串时，长度又不够，就会导致缓冲区溢出等安全性问题。

SDS 通过维护长度信息，可以在执行操作时进行安全检查，避免溢出。

##### 3、减少修改字符串时的内存重新分配次数

在 C 语言中，每当需要增加或减少字符串的长度时，都必须手动对字符串所占用的内存进行重新分配，不然就可能导致内存泄漏问题。

SDS 使用预分配和惰性释放的策略来优化内存的使用：

- 当 SDS 增长时，他会分配额外的未使用空间，这样在未来的增长中就可以不用重新分配内存；
- 当 SDS 缩短时，它不会立即释放内存，而是保留这部分内存以便将来使用。

##### 4、快速获取字符串长度

C 语言的字符串需要遍历整个字符串来确定长度，时间复杂度为 O(n)。

SDS 由于存储了长度信息，获取长度的操作时间复杂度为 O(1)，性能更好。

## 25、Redis 中 List 的底层实现是？

Redis 再不同版本的迭代中，对 List 的底层实现做了一些调整，以提高性能和内存利用效率。

以下是 Redis 中 List 的底层实现在不同版本的演变：

##### Redis 早期版本：双向链表（Linked List）

在 Redis 早期版本中，List 类型纯粹是由[**双向链表（Linked List）**]实现的。

每个 List 元素都是链表中的一个节点，这种实现方式使得在列表两端进行 push 和 pop 操作非常高效。但这种实现在内存使用上不够高效，特别是当存储许多小的 List 时，指针的开销会变得很大。

##### Redis 2.2 版本：压缩列表（ziplist）

为了减少内存使用，在 Redis 2.2 版本引入了[**压缩列表（ziplist）**]作为 List 的底层数据结构。

ziplist 是一种紧凑的顺序数据结构，这种结构适用于存储较小的元素和较短的列表，它将多个元素压缩存储在连续的内存区域。

##### Redis 3.2 版本：快速列表（quicklist）

考虑到 ziplist 在列表较大或元素较大时的性能问题，Redis 3.2 版本引入了[**快速列表（quicklist）**]作为 List 的底层实现。

quicklist 是**双向链表和压缩列表**的结合体，它维护多个 ziplist，每个 ziplist 作为链表的一个节点。这样，quicklist 结合了 ziplist 的内存高效性和双向链表在元素访问上的灵活性。

##### Redis 7.0 版本：快速列表（quicklist）

由于 quicklist 在不同场景下都能提供良好的性能和内存效率，它一直被保留作为 List 的底层实现，所以，**在 Redis 的最新版本中，List 类型的实现仍然是 quicklist。**

只不过在 Redis 7.0 版本之后，**List 的底层实现 quicklist 发生了变化，主要的改进是将之前的 ziplist 替换为了 listpack。**

listpack 是 ziplist 的一个改进版本，用于解决 ziplist 的连锁更新问题，还有在某些场景下的性能问题。

## 26、Redis 中的 quicklist 是什么？

> 在 Redis 中，quicklist 是 List 数据类型的底层实现。
>
> quicklist 专门为提高 Redis 列表操作的性能和内存使用效率而设计的，也可以最大程度上避免[连锁更新]的问题。

quicklist 在不同的版本也有不同的实现，Quicklist 通过优化存储方式，使得列表操作既快速又节省内存，特别适用于执行大量列表操作的场景。

## 27、Redis 中的 quicklist 的底层实现是？

这要分不同版本：

- 在 Redis 3.2+版本中，quicklist 是 ziplist 和 Linked List 的结合。
- 在 Redis 7.0+版本中，quicklist 的内部 ziplist 被替换为了 listpack。

所以，quicklist 其实就是一个链表，链表中的每个元素就是一个 ziplist，或者是一个 listpack。以 Redis 7.0 版本为示例，quicklist 底层数据结构图如下：

![](/images/Redis/27.jpg)

quicklist 的结构部分源码：

```
typedef struct quicklist {

  // 链表头
  quicklistNode *head;

  // 链表尾
  quicklistNode *tail;

  // 总元素数量
  unsigned long count;

  // quicklistNode节点数量
  unsigned long len;

  ...
}quicklist;
typedef struct quicklistNode {

  // 前一个quicklistNode节点
  struct quicklistNode *prev;

  // 后一个quicklistNode节点
  struct quicklistNode *next;

  // listpack
  unsigned char *entry;

  // listpack的总字节长度
  size_sz;

  // listpack包含的元素个数
  unsigned int count : 16;

  ...
} quicklistNode;
```

源码说明：

- **QuickList**：主要是一个双向链表。
- **quickListNode**：这是链表中的每个节点，每个节点内都包含一个 listpack，这些节点通过指针相互连接，构成了一个双向链表，每个节点可以快速访问前一个节点和后一个节点。
- **listpack**：存储在每个 quickListNode 中，用于存储实际的 List 元素。

quicklist 通过将数据分散在多个 listpack 中，每个 listpack 可以独立地内存管理，这样就可以在保持高性能地同时，减少了内存地占用。

对于 List 的头部或尾部操作，quicklist 由于其链表的特性，可以快速地进行插入和删除操作，即使是对于较大的 List，quicklist 也能保持相对较好的性能。

## 28、Redis 中的 ziplist 是什么？

Redis 中的压缩列表，即 ziplist，它是 Redis 为节约内存而开发的一个新的数据结构，它可以以更加紧凑的方式来存储 Hash、ZSet 元素。

所以，ziplist 是[]和[]底层实现之一：

- 当一个列表键只包含少量[列表项]时，并且每个列表都是小整数值，或者是长度比较短的字符串，那么 Redis 就会使用[ziplist]作为[**列表键**]的底层实现。
- 当一个哈希键只包含少量[键值对]时，并且每个键值对的键和值都是小整数值，或者是长度较短的字符串，那么 Redis 就会使用[ziplist]作为[**哈希键**]的底层实现。

因为 ziplist 的查找的时间复杂度是**O(N)**，并且插入新数据需要重新分配内存，且它还存在[**锁更新**]的问题，所以它只适用于[**小数据量**]的存储。

> ziplist 在 Redis 7 中已经被淘汰。

## 29、Redis 中的 ziplist 的底层实现是？

ziplist 的底层数据结构如图所示：

![](/images/Redis/29.jpg)

ziplist 是由一系列特殊编码的连续内存块组成的顺序数据结构，一个压缩列表可以包含多个 entry 节点，每个节点可以存储一个整数值或者一个字节数组。

## 30、Redis 中的 listpack 是什么？

在 Redis 中，listpack 是一种用于内部存储的紧凑序列数据结构，它是为了替代 ziplist 而设计的，listpack 的设计目标是在保持 ziplist 的内存效率的同时，提供更好的性能和更高的灵活性。

> 由于 ziplist 在每个元素中包含了指向前一个元素长度的信息，当一个元素被修改导致长度发生变化时，就需要更新后续元素中存储的前置元素长度信息。
>
> 这种设计容易导致连锁更新问题，特别是当发生在 ziplist 中间位置的修改操作时，它可能会触发多个元素的更新，影响性能。
>
> 相比之下，listpack 摒弃了这种前后元素之间的长度依赖关系。

listpack 主要用于 Redis 的内部实现， 在 Redis7.0 版本更新中，**listpack 替换了 ziplist 成为了 QuickList（用于实现 List 数据类型）中的存储结构**，这是它最主要的应用场景。

## 31、Redis 中 listpack 的底层实现是？

listpack 是用来代替 ziplist 的，索引它们的数据结构很相似：

![](/images/Redis/31.jpg)

结构说明：

- listpack 移除了 ziplist 到尾部节点 entryN 的偏移量，并移除了每个元素中前一个元素的长度，同时保留了其他属性。
- encoding 表示 content 的编码，encoding 表示元素存储的内容，length 表示每个 entry 的长度。

在 listpack 中，每个元素独立存储，不包含指向前一个元素长度的属性。这种设计减少了元素间的耦合，从而当一个元素发生变化时，不会影响到其他元素的存储结构，避免了连锁更新的问题，提高了操作效率。

在 listpack 中，尽管没有直接指向尾部节点的偏移，但仍能快速定位到尾部节点。这是通过使用 listpack 的总字节长度属性来快速找到尾部，再依据尾部 entry 的长度属性反向定位到其起始地址实现的。

## 32、Redis 中的连锁更新问题是什么？怎么产生的？

Redis 中的[连续更新]问题，一般是指 ziplist 压缩列表在特殊情况下，产生的连续多次扩展内存空间的操作。

##### 这个问题具体是怎么产生的？

不得不说到 ziplist 中的 entry 节点的`previous_entry_length`属性，这个属性记录了前一个节点的长度：

- 如果前一节点的长度 < 254 字节，那么`previous_entry_length`属性需要用 1 个字节的空间来保存这个长度值。
- 如果前一节点的长度 >= 254 字节，那么`previous_entry_length`属性需要用 5 个字节的空间来保存这个长度值。

而这个[连锁更新]问题正是由`previous_entry_length`属性造成的，

![](/images/Redis/32.jpg)

##### 举个例子：

比如有一个压缩列表，它有多个连续的，长度介于 250~253 字节之间的节点，所以它们的`previous_entry_length`属性均为 1 个字节。

如果现在将一个长度 > 254 字节的节点 entry10 插入到第一个节点 entry1 前面，所以会导致后面的 entry1 的`previous_entry_length`值就变为 5 字节，这样扩展后，enrty1 的长度就必须会超过 254 字节，从而导致后面所有节点都要扩展，这便是[**连锁更新**]问题。

从上面例子可以看到，在最坏的情况下，连锁更新问题会对 ziplist 执行 N 次空间重分配，而每次空间重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)。

## 33、Redis 是怎么解决连锁更新问题的？

为了解决 Redis 中的 ziplist 压缩列表[Redis 7.0+是 listpack]问题，Redis 开始引入了 quicklist，当 quicklist 进行数据更新时，通过控制 QuickListNode 结构里的 ziplist（Redis 7.0+是 listpack）的大小或者元素个数，避免了所有元素的连锁更新，连锁更新只会发生在单个节点上了。

所以，即使这样，quicklist 并没有完全解决[连锁更新]问题，所以，Redis 7 有引入了 listpack，代替 ziplist 彻底解决了[连锁更新]的问题。

## 34、Redis 中的 ZSet 是什么数据类型？

Redis 中的**ZSet**，即**Sorted set**，即有序不重复集合，它是一种可以存储有序的、不重复字符串集合的数据结构，类似于 Java 中的 TreeSet 集合。

ZSet 和 Set 不同的是，ZSet 中的每个元素有一个**排序权重值（score）**,然后通过权重值来为集合中的元素进行从小到大的排序。

ZSet 中的元素是唯一、不重复的，但权重值可以重复。

## 35、Redis 中 ZSet 的底层实现是？

Redis ZSet 的底层实现还是比较复杂的，Redis 为了达追求内存和性能的平衡，不同的 Redis 版本其 ZSet 的数据结构也有所不同：

- Redis 7.0 之前使用的 ziplist 和 skiplist、dict；
- Redis7.0+ 使用的 listpack 和 skiplist、dict；

数据结构解释：

- ziplist：压缩列表
- skiplist：跳跃表
- dict：字典

ziplist 会出现[**连锁更新**]现象，所以，Redis 7 引入了**listpack**，取代**ziplist**来解决这个问题。

以 Redis 7 为例，当 ZSet 同时满足以下两个条件时，会使用**listpack**作为底层数据结构：

- 元素个数小于`zset_max_listpack_entries`的值，默认值为 128
- 元素值小于`zset_max_listpack_value`的值，默认值为 64

否则使用**skiplist**作为底层数据结构，以提升效率。

## 36、Redis 哪里使用到了跳表？

Redis 中使用跳表的地方：

##### 1、有序集合（ZSet）

跳表是有序集合（ZSet）的底层实现之一，用来存储有序的元素列表。

##### 2、集群节点

在集群节点中，Redis 使用了[跳表]作为其内部数据结构。

## 37、Redis 为什么用跳表而不用平衡树？

Redis 使用跳表（skiplist）而不用平衡树（B 树）的原因：

##### 1、跳表的实现比较简单

跳表相比平衡树而言， 代码实现难度要小很多，也不需要考虑平衡问题。

##### 2、跳表有更好的写入性能

跳表的插入和删除操作比平衡树快，只需要修改相邻节点的指针。而平衡树则需要从根节点开始遍历到叶子节点，才能找到正确的位置进行插入或删除操作。

所以，在进行频繁插入和删除操作时，跳跃表的性能要比平衡树要更好。

##### 3、跳表占用的内存空间比较小

因为跳表的节点数目和层数都是随机生成的，而不像平衡树那样记录所有子节点的指针，所以，在存储相同数量的元素时，跳表所占用的内存比平衡树要更少。

## 38、Redis 中的 BitMap 是怎么实现的？

**Redis 中的 BitMap 通过字符串类型来实现**，每个字节可以表示 8 个二进制位，因此一个字符串最多可以表示 8 倍字符串的位数，比如，长度为 10 的字符串需要 80 位表示。

以下是 Redis 中 BitMap 的实现细节：

##### BitMap 的存储：

Redis 使用字符串类型来存储 BitMap，每个二进制位可以通过字符串中的一个字节来表示。

> 例如，字符串“abc”的 BitMap 表示为“011000010110001001100011”。

##### BitMap 的设置：

可以使用 SETBIT 命令将某一位设置为 0 或 1。

> 例如，SETBIT mybitmap 0 1 表示将 mybitmap 中的第 0 位设置为 1。

##### BitMap 的查询：

可以使用 GETBIT 命令查询某一位的值。

> 例如，GETBIT mybitmap 0 表示查询 mybitmap 中第 0 位的值。

BitMap 的计数：

可以使用 BITCOUNT 命令计算 BitMap 中值为 1 的位的数量。

> 例如，BITCOUNT mybatimap 表示计算 mybitmap 中值为 1 的位的数量。

##### BitMap 的操作：

可以使用 BITOP 命令对多个 BitMap 进行位运算。

> 例如，BITOP AND myresult mybitmap1 mybitmap2 表示将 mybitmap1 和 mybitmap2 进行按位与操作，并将结果存储到 myresult 中。

需要注意的是，BitMap 在 Redis 中的存储空间占用较小、计算速度较快，但是其最大的缺点是支持删除操作，如果需要删除 BitMap 中的某一位，只能将其设置为 0。

**因此，在使用 BitMap 时需要仔细考虑是否需要支持删除操作。**

## 39、Redis 中的 BitMap 的应用场景？

Redis 中 BitMap 的应用场景：

##### 1、统计网站访问量

可以使用一个 BitMap 来表示一段时间内网站的访问情况，其中每一位表示每一秒钟的访问情况。

当用户访问网站时，可以通过 SETBIT 命令将对应的位设置为 1，然后通过 BITCOUNT 命令计算访问量。

##### 2、存储用户在线状态

可以使用一个 BitMap 来表示每个用户的在线状态，其中每一位表示一个用户是否在线。当用户登录或退出时，可以通过 SETBIT 命令将对应的位设置为 1 或 0，然后通过 BITCOUNT 命令计算在线用户数。

## 40、Redis 使用 BitMap 会有哪些问题？如何解决？

在使用 Redis BitMap 时需要注意以下几个问题：

##### 1、存储空间

BitMap 需要存储大量的二进制位，因此需要考虑存储空间的问题。

> 可以通过使用 Redis 的压缩存储方式来减少存储空间的占用， 例如使用 HyperLogLog 算法对 BitMap 进行近似统计。

##### 2、不支持删除操作

BitMap 不支持删除操作，在使用 BitMap 时需要仔细考虑是否需要支持删除操作。

> 如果需要删除操作，可以使用其他数据结构来代替 BitMap。

##### 3、并发安全问题

由于 BitMap 中的每个二进制位都需要进行单独的读写操作，因此在多线程或者多进程并发操作时，需要注意线程安全的问题。

> 可以使用 Redis 的事务，或者乐观锁来解决并发操作问题。

## 41、Redis 中的 Hash 表的扩容机制？

在 Redis 中，Hash 数据类型采用了**链表和散列表**的结合方式，也就是**哈希表**，当一个 Hash 中的键值对数量过多时，Redis 会自动对其进行扩容，以提高数据的存储效率和查询性能。

Redis 中 Hash 表的扩容机制采用的是：**渐进式 rehash 算法**。

## 42、Redis 渐进式 rehash 是指什么？

哈希表一般是在元素个数达到一定阈值时才扩容的，如果扩容是 rehash 的操作一次性移动太多数据，可能导致服务器停顿的问题，所以，Redis 引入了渐进式 rehash 策略，它是一种哈希表渐进式扩容方式。

渐进式 rehash 可以有以下好处：

- 渐进式 rehash 不会一次性移动太多数据，**可以避免扩容导致服务器停顿的问题，还可以降低 CPU 负载，减少数据迁移时间；**
- 渐进式 rehash 不会一次性分配过多的内存，**可以减少内存碎片的产生，提高内存利用率。**

## 43、Redis 渐进式 rehash 过程是怎样的？

渐进式 rehash 过程分为两个阶段：

##### 1、迁移数据：

在这个阶段，Redis 会新建一个更大的哈希表，然后将原哈希表中的数据迁移到新哈希表中。

在迁移数据的过程中，Redis 会每次将原哈希表中的一小部分数据迁移到新哈希表中，每次迁移的数据量不会过大，可以控制在一定范围内，从而避免服务器停顿的问题。

##### 2、释放空间

在所有数据迁移完成后，Redis 会释放原哈希表所占用的空间，并将新哈希表设置为当前哈希表，此时扩容操作完成。

> 需要注意的是：
>
> （1）渐进式 rehash 可能会导致新旧哈希表同时存在一段时间，因此在查询时需要同时查询新旧哈希表。
>
> （2）渐进式 rehash 在扩容时可能会消耗一定的 CPU 资源，因此需要根据实际情况综合考虑哈希表大小、CPU 资源等因素来进行设置。

## 44、Redis 中的 HyperLogLog 是什么？

Redis 中的 HyperLogLog 是一种基数统计算法，以非常小的内存空间内存储海量数据，并且空间占用量是固定的，也用于快速、高效地估算一个集合的基数（即不重复元素的数量），适用于大数据量的基数统计问题。

HyperLogLog 算法的实现原理是利用哈希函数将输入的数据转换为一个数字，然后利用位运算和取最大值等方法对这些数字进行处理，从而得到一个估计值，该估计值与输入数据的基数呈正相关关系。

HyperLogLog 算法的优点在于，在处理大数据量的基数统计问题时，空间占用量很小，性能非常高，误差范围可以接受。

> ##### 需要注意的是：
>
> （1）HyperLogLog 只能处理不重复元素的基数问题。
>
> （2）HyperLogLog 可能会存在一定的误差（可以满足大多数实际场景中的需求），可以通过增加位数组的长度来降低误差率，但这也会增加空间占用量。

## 45、Redis 中的 HyperLogLog 应用场景？

HyperLogLog 主要应用于以下场景：

##### 1、统计独立用户访问量

可以使用 HyperLogLog 统计网站或应用程序的独立用户访问量，即统计不重复的用户数量。每当有一个用户访问时，将其唯一标识加入到 HyperLogLog 中，然后通过计算 HyperLogLog 的基数来估算独立用户访问量。

##### 2、统计在线用户数量

可以使用 HyperLogLog 统计在线用户数量，每当一个用户上线时，将其唯一标识加入到 HyperLogLog 中，然后通过计算 HyperLogLog 的基数来估算在线用户数量。

等等。。。

## 46、Redis 如何实现计数器功能？

Redis 可以通过使用 INCRBY、DECRBY 命令实现计数器的功能，具体实现方式如下。

##### 1、初始化计数器

首先需要创建一个 Redis 字符串类型的 key，并将其对应的值初始化为 0，表示计数器的初始值位 0。

示例代码：

> SET counter 0

##### 2、对计数器进行自增

可以使用 INCRBY 命令对计数器进行自增操作，从而实现计数器的递增。

该命令可以将指定 Key 对应的值加上指定的增量，如果 key 不存在，则会先将其初始化为 0，然后再进行自增操作。

示例代码：

> INCRBY counter 1

##### 3、对计数器进行自减

可以使用 DECRBY 命令对计数器进行自减操作，从而实现计数器的递减。

该命令可以将指定 key 对应的值减去指定的减量，如果 key 不存在，则会先将其初始化为 0，然后再进行自减操作。

示例代码：

> DECRBY counter 1

##### 4、获取计数器的值

可以使用 GET 命令获取指定 key 对应的值，从而获取计数器的值。

示例代码：

> GET counter

除了使用字符串类型来实现计数器之外，还可以使用 HyperLogLog、Lua 脚本等方式来实现分布式计数器的功能。

## 47、Redis 如何统计独立用户访问量？

在 Redis 中统计独立用户访问量可以采用 HyperLogLog 算法来实现，这是一种基数统计算法，可以在较小的内存空间内快速地计算一个集合地基数，适合处理海量数据地基数统计问题。

具体实现步骤如下：

##### 1、创建一个 HyperLogLog

> PFADD key user_id

其中，Key 表示 HyperLogLog 地键名，user_id 表示用户唯一标识。

##### 2、统计 HyperLogLog 中元素的个数

> PFCOUNT key

PFCOUNT 命令会返回 HyperLogLog 中元素的基数（cardimality），也就是独立用户访问量的近似值。

## 48、Redis 中 INCR 和 INCRBY 命令的区别？

INCR 和 INCRBY 命令都是 Redis 中用于对指定键的整数值进行递增操作的命令，它们都是原子性操作命令，区别在于递增的步长不同。

INCR 命令用于将指定键的整数值 + 1，语法如下：

> INCR key

如果指定的键不存在，将创建一个新的键，并将其值初始化为 0。

INCRBY 命令用于将指定键的整数值增加指定的步长，语法如下：

> INCRBY key increment

其中，increment 是递增的步长，可以是负数。

> ##### 总结一下：
>
> 如果步长是固定的 1，则使用 INCR 更为简便；
>
> 如果步长是可变的，则使用 INCRBY 更加灵活。

## 49、Redis 事务有什么用？

Redis 中的事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来地命令请求所打断。

和关系数据库中地事务不同，Redis 中地事务只是一组命令集合，不能保证关系数据库 ACID 所有特性，Redis 事务中的命令**要么全部执行或者部分执行，不保证命令全不能执行成功。**

## 50、Redis 事务相关的命令有哪几个？

Redis 的事务功能主要由几个命令提供：

##### 1、MULTI

MULTI 命令用于开启一个事务，它标记一个事务块的开始，之后的所有命令都会被顺序地加入到队列中。

> MULTI

##### 2、EXEC

EXEC 命令用于执行所有在 MULTI 之后加入到队列的命令，如果事务块内的所有命令都被成功执行，那么 EXEC 返回事务块内所有命令的返回值。

> EXEC

##### 3、DISCARD

DISCARD 命令用于取消事务，放弃执行事务块内的所有命令。

> DISCARD

##### 4、WATCH

WATCH 命令用于监视一个或多个键，如果在事务执行之前这个键被其他命令改动了，那么事务将被打断。WATCH 命令可以被用于实现乐观锁。

> WATCH key1 [key2 ...]

##### 5、UNWATCH

UNWATCH 命令用于取消 WATCH 对所有键的监视。如果在执行 WATCH 命令之后，执行了 MULTI 命令之前，执行了 UNWATCH 命令，那么之前的 WATCH 命令就会被取消。

## 51、Redis 事务是原子性的吗？

**Redis 事务不是原子性的，且事务不支持回滚。**

1、EXEC 命令执行之前的错误，如：各种语法错误，Redis 会自动放弃事务，所有命令都不会执行。

2、调用 EXEC 命令执行失败后的错误，如：事务中的命令和处理了不支持的键，此时，除了出错的命令之外，事务中的其他命令仍会执行。

## 52、Redis 持久化有什么用？

因为 Redis 是内存数据库，持久化的主要作用就是将内存中的数据保存到磁盘上，以防止因为系统故障、重启或其他原因导致的数据丢失，保证数据安全性。

## 53、Redis 有哪几种持久化方式？

Redis 支持两种不同的持久化方式：

##### 1、RDB 持久化（默认）

RDB 即 Redis DataBase File，它是 Redis 的默认持久化方式，它可以定期或手动生成 Redis 数据库的快照，快照是一个二进制文件，包含了 Redis 数据库在某个时间点的所有数据，默认产生的数据文件为 dump.rdb。

RDB 持久化机制的实现原理是将 Redis 内存中的数据按照一定的格式写入到磁盘文件中，因此可以快速恢复数据，但可能会有一定的数据丢失。

##### 优点：

- RDB 文件是一个非常紧凑的单个文件，非常适合于备份、灾难恢复以及提高大数据集的冷启动速度。
- RDB 可以创建非常快速的数据快照，尤其是在数据集很大时，相比 AOF 的持续写操作，对性能的影响较小。

##### 缺点：

- 在发生故障时，可能会丢失最后一次快照之后的所有数据。
- RDB 在报仇呢快照时可能需要较高的内存，因为在快照过程中要维持现有连接和操作，同时还要复制整个数据集。

##### 2、AOF 持久化

AOF，即：Append Only File，它是 Redis 的另一种持久化方式，它将所有对 Redis 数据库进行的写操作记录下来，然后将这些操作以追加的方式写入到一个磁盘文件中，默认产生的数据文件为 appendonly.aof。

AOF 持久化机制的实现原理是在每次写操作完成后，将相应的写命令以追加的方式写入到 AOF 文件中，将相应的写命令以追加的方式写入到 AOF 文件中，因此可以保证数据的完整性和持久性，但可能会导致 AOF 文件多大。

##### 优点：

AOF 持久化记录了所有写操作的命令，确保即使在发生故障时，也不会丢失数据；

##### 缺点：

AOF 文件保存了每个写操作的命令，因此相比于 RDB 文件，AOF 文件通常会更大。在长时间运行的 Redis 实例上，AOF 文件可能会变得非常庞大，增加了备份和恢复的成本。

## 54、Redis 持久化方式如何选择？

下面是一些常见的选择标准：

##### 数据重要性：

如果数据重要性较高，需要保证数据的完整性和可靠性，可以选择 AOF 持久化方式。

AOF 方式可以在每次写操作完成后将相应的写命令以追加的方式写入到 AOF 文件中，以保证数据的完整性和持久性。

##### 空间占用：

如果空间占用是一个关键因素，可以选择 RDB 持久化方式。

RDB 方式可以定期会根据条件生成 Redis 数据库的快照，快照是一个二进制文件，可以快速恢复数据，而且占用的空间相对较小。

##### 数据恢复速度：

如果需要快速恢复数据，可以选择 RDB 持久化方式。

RDB 文件可以快速地恢复数据，因为它是一个二进制文件，恢复速度相对较快。而 AOF 文件由于是文本文件，恢复速度相对较慢。

##### 写入频率：

如果写入频率较高，可以选择 AOF 持久化方式。

AOF 方式可以在每次写操作完成后将相应地写命令以追加的方式写入到 AOF 文件中，因此可以保证数据的完整性和持久性。

##### 性能要求：

如果对性能要求较高，可以选择关闭持久化功能，只使用 Redis 的内存数据库。当然，这种方式可能会导致数据丢失，因此需要根据实际需求来综合考虑。

> 需要注意的是：
>
> Redis 支持 RDB 和 AOF 持久化方式的混合使用，可以在需要时同时使用两种持久化方式，以充分发挥它们各自的优势。
>
> 选择 Redis 持久化方式需要根据**应用场景、数据量、性能要求**等实际需求和场景综合因素来考虑，不能一概而论。

## 55、Redis RDB 持久化的原理？

RDB 自动持久化使用的是**bgsave**方式，它不会阻塞 Redis 主进程，而是会 fork 出一个子进程来进行快照操作，Redis 主进程可以继续处理客户端的请求。

##### Redis 创建快照文件的原理：

- Redis 会 fork 出一个子进程来进行快照操作，子进程和主进程共享内存空间；
- 子进程将整个数据集写入新的 RDB 文件；
- 子进程写入完成后，使用新的 RDB 文件替换旧的 RDB 文件。

主进程在写入过程中使用了写时复制技术（Copy-On-Write），所以主进程对数据库的修改不会影响子进程的操作。

## 56、Redis AOF 持久化的原理？

AOF 持久化的工作原理：

##### 1、命令追回

每次执行写命令（如 SET，DEL，HSET 等）时，Redis 将命令追加到 AOF 缓冲区（buffer）中。

##### 2、数据同步

按照一定的策略（根据 appendfsyne 配置），再从缓冲区同步到硬盘上的 AOF 文件中。

##### 3、AOF 重写

当 AOF 的文件达到指定策略配置的阈值时，Redis 会对 AOF 日志文件进行重写。

## 57、Redis 中的 AOF 重写机制是什么？

随着时间的推移，AOF 文件可能会变得非常大，因为每个被修改过的命令都被记录下来了，为了**优化 AOF 文件大小，Redis 提供了 AOF 重写的机制。**

##### 重写原理：

AOF 重写不是通过简单地复制原始 AOF 文件来实现的，而是在后台创建一个新的、更紧凑的 AOF 文件，该文件只包含达到当前数据库状态所需的最少命令集，重写操作不会影响现有的 AOF 日志记录。

##### 重写流程：

- Redis 主进程会 fork 出一个子进程来进行 AOF 文件的重写；
- 子进程将当前数据库状态所需的最少命令集写入新的 AOF 文件；
- 子进程重写完毕后，主进程会把子进程重写期间产生的写请求追加到新的 AOF 文件中；
- 主进程最终替换旧的 AOF 文件。

在 AOF 重写过程中，主进程可以继续处理客户端请求，它使用了写时复制技术（Copy-On-Write），确保不会影响子进程的重写过程数据不变。

##### 重写是如何缩减文件大小的？

- 只保留最终状态对应的命令，去除过期和无效的命令；
- 重新构造命令，优化存储结构，使用更高效的命令来减小文件大小；

## 58、Redis 中的混合持久化是什么？如何实现的？

Redis 中现有持久化的缺陷：

- RDB 持久化虽然快，但是会丢失快照之后的数据，不能保证数据完整性；
- AOF 持久化虽然能保证数据完整性，但是性能不佳，日志文件也过大。

所以，Redis 4.0 开始，引入了混合持久化模式。

**混合持久化结合了 RDB 和 AOF 两种持久化方案**，旨在利用两者的优点，达到**既能快速启动并恢复数据、又能保证数据完整性**的效果，以实现更优化的持久化解决方案。

##### 混合持久化实现原理：

在进行 AOF 重写的时候，Redis 不仅仅重写 AOF 文件，而是先写入一个当前内存状态的 RDB 快照，之后的写操作则在 RDB 快照之后写入，所以新的 AOF 文件在前部都会包含一个完整的数据快照（RDB 格式），在后部包含了增量更新的命令（AOF 格式）。

开启混合持久化：

```
# 开启AOF（必须项）
appendonly  yes

# 开启混合持久化
aof-use-rdb-preamble  yes
```

注意，Redis 5.0 以后默认会开启混合持久化功能。

## 59、Redis 持久化触发的时机有哪些？

Redis 的持久化触发时机取决于所使用的持久化方法，主要包括 RDB 和 AOF 两种机制，每种方法的触发时机有所不同，下面会分别说明。

##### RDB 持久化触发时机

---

RDB 持久化会创建数据集的快照，这种快照可以在以下几种情况下自动或手动触发：

##### 1、定时触发

可以在 Redis 配置文件中设置具体的间隔规则，如每隔多少分钟和发生多少次写操作后触发，如以下配置：

```
# 如果至少有1000个键被修改，则每900秒自动保存一次
save  900 1000
```

##### 2、手动触发

参考面试题：Redis 命令 save 和 bigsave 的区别？

##### 3、自动触发

当执行如`SHUTDOWN`关闭 Redis 正常关闭命令时，如果没有开启 AOF 持久化，或者 AOF 重写不在进行中，Redis 会自动进行一次 RDB 持久化。

> 客户端可以通过命令判断 RDB 持久化是否执行成功，他返回最后一次成功执行 RDB 快照的 UNIX 时间戳，这个命令在管理和监控 Redis 实例时非常有用，特别是当你需要确认数据的最后保存时间或者验证持久化操作是否按预期执行了。

##### AOF 持久化触发时机

AOF 持久化通过记录每一个写操作命令来工作，AOF 的触发主要是基于以下配置：

##### 1、实时更新

每个写命令都会被追加到 AOF 文件的末尾。

为了保证数据安全性，可以通过配置文件设置 AOF 的刷新频率：

| appendfsync 参数值 |     |
| ------------------ | --- |
| always             |     |
| everysec           |     |
| no                 |     |

##### 2、手动触发

使用`BGREWRITEAOF`命令可以触发 AOF 文件的重写操作。

##### 3、自动触发

AOF 文件大小超过一定阈值时，Redis 会自动触发 AOF 重写操作，这个阈值可以通过配置文件的以下参数配置进行设置。

| 参数                        | 默认值 | 说明 |
| --------------------------- | ------ | ---- |
| auto-aof-rewrite-percentage | 100    |      |
| auto-aof-rewrite-min-size   | 64MB   |      |

## 60、Redis 重启是如何恢复持久化数据的？

Redis 重启时恢复持久化数据的过程依赖于它使用的持久化机制，包括 RDB 和 AOF，以及是否开启了混合持久化模式，以下是主要恢复数据流程。

![](/images/Redis/60.jpg)

具体恢复流程如下：

##### 1、判断 AOF 持久化设置

在启动时，Redis 首先检查是否启用了 AOF 持久化，如果没有启用，系统将自动转到使用 RDB 文件的数据恢复流程。

##### 2、定位并读取 AOF 文件

若发现 AOF 持久化已开启，Redis 会寻找并读取对应的 AOF 文件。

##### 3、分析 AOF 文件头部

在读取 AOF 文件时，系统会分析文件的头部，如果头部以 RDB 格式的数据开始，Redis 首先加载这部分 RDB 数据，然后继续加载 AOF 文件中的剩余 AOF 命令日志。

##### 4、纯 AOF 数据恢复

如果 AOF 文件的头部并不包含 RDB 数据，Redis 将整个文件按照 AOF 日志的格式直接加载，逐条执行命令以恢复数据。

##### 5、完成数据恢复一旦所有日志文件完全加载并执行，数据恢复过程即完成。

## 61、Redis 命令 save 和 bigsave 的区别？

因为 Redis 中的 RDB 持久化是某个时间点的数据快照，而不是实时的数据持久化，如果想要手动进行一次持久化，可以使用`save`或者`bgsave`命令。

##### save

---

基本命令：

> redis 127.0.0.1:6379 > save

save 命令会阻塞 Redis 主进程，直到快照生成为止，在 Redis 主进程阻塞期间，Redis 主进程不能处理客户端的任何请求。

##### bgsave

---

基本命令：

> 127.0.0.1:637 > bgsave

bgsave 命令执行后会立即返回 OK，并不会阻塞 Redis 主进程，然后再 fork 出一个子进程来进行快照操作，Redis 主进程可以继续处理客户端的请求。

> Redis RDB 自动持久化方式使用的是 bgsave。

## 62、如何保证 Redis 中的数据都是热点数据？

比如，现在 MySQL 数据库里有 2000 万数据，Redis 中只能存 20 万数据，如何保证 Redis 中的数据都是热点数据呢？

---

其实考察的是 Redis 的淘汰策略，参见面试题：`Redis有哪些淘汰策略？`

所以，首先计算以下 20 万数据大概占用的内存大小，然后设置一下 Redis 的最大内存容量大小，并将淘汰策略为**LRU**（根据访问时间淘汰）或者**LFU**（根据访问频率淘汰）中的一种，Redis 会根据自身数据执行淘汰策略，最后留下来的都是热数据。

## 63、Redisn 欸村碎片是什么？怎么产生的？

Redis 内存碎片是指内存空间被频繁地分配和释放，导致内存空间出现不连续的情况。

##### Redis 内存碎片可能产生的原因：

- 频繁地进行内存分配和释放操作，如果内存分配和释放不当，就会产生大量地内存碎片；
- 存储数据时，向操作系统申请地内存空间，大于数据实际需要的存储空间；

内存碎片会影响 Redis 的性能和稳定性，例如增加内存的占用率、降低内存利用率、导致内存溢出等问题。

## 64、Redis 内存碎片如何查看？

可以通过执行 info memory 命令查看 Redis 内存信息，其中包括内存使用情况和碎片情况；

| 指标 | 描述 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

主要关注这两个参数：

- allocator_frag_ratio
- allocator_frag_bytes

如果 allocator_frag_ratio 参数的值越大，代表内存碎片率越严重。

## 65、Redis 内存碎片率过高有什么影响？

当 Redis 实例的内存碎片率过高时，可能会出现以下影响：

##### 1、内存使用率上升

由于内存碎片会浪费一定的内存空间，因此当 Redis 实例的内存碎片率过高时，实例占用的内存空间也会相应地增加，从而可能导致 Redis 实例占用的内存空间超过物理内存大小，引发内存溢出问题。

##### 2、Redis 性能下降

内存碎片会导致 Redis 实例的内存分配和回收变得不规律，从而影响 Redis 的读写效率和响应速度。

此外，当 Redis 实例的内存碎片率过高时，可能会导致 Redis 实例出现频繁的内存分配和回收，从而引发 CPU 使用率上升、响应时间延长等问题，影响 Redis 的性能表现。

## 66、Redis 内存碎片率超过 50%会怎样？

当 Redis 实例的内存碎片率超过 50%时，Redis 会根据配置文件中的**maxmemory-fragmentation-ratio**参数进行处理：

- 如果该参数的值 < 1.0：即内存碎片率有限制，超过该值后，Redis 会拒绝进行新的写入操作，直到内存碎片率下降到设定的阈值以下。
- 如果该参数的值 = 默认值 1.0：即内存碎片率无限制，超过该值后，Redis 会继续运行，但可能会因为内存碎片过多而导致性能下降。

## 67、Redis 内存碎片如果清理？

Redis 的内存碎片清理方法：

##### 1、定期重启 Redis

通过定期重启 Redis，可以释放内存碎片，从而减小内存碎片的影响。这种方式会中断 Redis 的服务，可能会影响业务运行，需要根据具体情况来选择重启时间。

##### 2、内存压缩机制

Redis 提供了内存压缩机制来减小内存碎片的影响，该机制可以对 Redis 中的内存空间进行整理和压缩，从而消除内存碎片，提高内存利用率。

##### 3、内存分配器

Redis 使用 jemalloc 作为默认的内存分配器，jemalloc 采用了一些优化策略，如内存分配池、预分配内存、计算分配空间的大小等方式，它在很大程度上避免了内存碎片问题。

可以通过一些配置参数来调整内存分配器的行为，以减小内存碎片的影响，比如可以通过**maxmemory-fragmentation-ratio**参数来控制内存分配和释放的比率。

##### 4、活跃内存碎片整理（Active-Defragmentation）

这是一种在线清理内存碎片的方式，不需要停止 Redis 服务，可以在 Redis 运行期间进行。该方法通过周期性地对 Redis 中的活跃内存碎片进行整列和压缩，从而减小内存碎片的影响。

要启用 Redis 的活跃内存碎片的整理功能，需要在 Redis 配置文件中设置以下参数：

![](/images/Redis/67.jpg)

> **需要注意的是：**
>
> 启用活跃内存碎片整理功能会消耗一定的 CPU 资源，可能会影响 Redis 的性能。

## 68、Redis 内存满了怎么办？

如果达到设置的上限，默认淘汰策略下，Redis 的写命令会返回错误信息，但是读命令还可以正常返回。

一般要配置合适的淘汰机制，当 Redis 内存满了时，即达到了配置的`maxmemory`限制，Redis 会根据预设的内存淘汰策略来处理新的写入操作。

## 69、Redis 怎么配置最大内存容量？

打开 Redis 的配置文件：

![](/images/Redis/69.jpg)

找到并放开`maxmemory`配置项注释，单位为：字节。

比如，如果你希望设置最大内存容量为 100MB，你可以这样设置：`maxmemory 104857600`，然后保存并重启 Redis 服务器。

如果你不希望重启 Redis 服务器，你也可以在运行时使用``命令来修改最大内存容量：

> CONFIG SET maxmemory 104857600

## 70、Redis 有哪些淘汰策略？

Redis 目前有 8 种淘汰策略：

| 淘汰策略        | 描述                                           |
| --------------- | ---------------------------------------------- |
| moevivtion      | 默认淘汰策略，无法进行写入                     |
| alleys-lru      | 从所有键中淘汰最久未被访问的键                 |
| volatile-lru    | 从设置了过期时间的键中淘汰最久未被访问的键     |
| allkeys-lfu     | 从所有键中淘汰最近访问频率最低的键             |
| volatile-lfu    | 从设置了过期时间的键种淘汰最近访问频率最低的键 |
| allkeys-random  | 从所有键中随机淘汰键                           |
| volatile-random | 从设置了过期时间的键种随机淘汰键               |
| volatile-ttl    | 从设置了过期时间的键种淘汰最早过期的键         |

Redis 4.0 开始支持基于 LFU 算法的淘汰策略。

## 71、Redis 为什么新增了 LFU 淘汰策略？

##### 为什么 Redis 4.0 有了 LFU？

因为 Redis 中的 LRU 时抽样式 LRU 算法，**仅关注数据的访问时间，而忽略了访问次数的重要性**，可能淘汰热点键，所以，LFU 比 LRU 淘汰更精确，有助于提升 Redis 的缓存命中率。

比如 Redis 中的一个键，之前一直都没有被访问过，最近突然被访问了一次。

使用 LRU 淘汰策略就很难被淘汰，因为 LRU 会把它定义为热键，会很晚淘汰。而使用 LFU 淘汰策略就可能很快被淘汰，因为 LRU 优先淘汰最近未被使用的，而 LFU 优先淘汰最近访问频率最低的。

## 72、Redis 淘汰策略 LRU 和 LFU 的区别？

##### 1、实现复杂度

LRU 实现更简单，仅采用哈希表实现，而 LFU 可以采用哈希表 + 最小堆相结合的方式实现。

LFU 更加复杂，需要维护每个数据的访问频率，因此相对于 LRU 来说，实现起来更加困难。

##### 2、淘汰策略

LRU 根据数据最近被访问的时间进行淘汰，即淘汰最久未被访问的数据，因此它可以更好地适应访问时间比较稳定的场景。

LFU 淘汰策略是 Redis 4.0 开始支持的，这种策略是基于键的访问频率进行淘汰，访问频率更低的键将更容易被淘汰，因此它可以更好地适应访问频率变化的场景。

##### 3、时间敏感性

LRU 对事件敏感，最近访问的数据被认为是热点数据，而 LFU 对时间不敏感，它关注的是访问次数。

## 73、Redis LRU 算法怎么实现的？有什么优缺点？

Redis 为了在高性能和资源利用之间取得平衡，Redis 实现 LRU（Least Recently Used）缓存淘汰算法的机制，但它并不是传统意义上的精确 LRU 算法，而是一种**近似的、抽样式的 LRU 算法**。

因为不需要对所有键进行筛选淘汰，所以，Redis 并没有没有像标准的 LRU 算法一样使用 Hash 表 + 双向链表来维护所有键的访问记录，所以其内部**只使用了 Hash 表，并没有创建双向链表**。

每个键都有一个[**LRU 时间戳**]字段，记录了最后一次访问时间。当内存达到限制并需要淘汰一些键时，Redis 会随机采样一定数量的键，并检查它们的**LRU 时间戳**，淘汰其中[**LRU 时间戳**]最小的键。

##### 这样实现方式的好处：

##### 1、实现简单

相比于精确的 LRU 实现，Redis 中的 LRU 算法实现更简单。

##### 2、性能更好

因为 Redis 中的 LRU 算法每次只对一小部分键进行抽样，从而它能快速做出淘汰决策，避免了为每次键访问更新状态的高昂成本。

这样的实现，使得 Redis 能够在保持高性能的同时实现近似的 LRU 功能，让整个淘汰过程非常高效。

##### 3、内存占用小

由于不需要存储所有键的访问记录，所以内存空间占用较小，使得 Redis 可以更有效地利用可用内存存储更多的数据。

##### 这种实现方式的缺点：

Redis 中的 LRU 算法，每次会随机选取一批数据进行淘汰，而不是所有的数据，所以，会牺牲部分准确率（可能会淘汰热点数据），但提升了 LRU 算法的性能。

## 74、Redis LFU 算法怎么实现的？有什么优缺点？

因为 Redis LRU 算法的弊端，所以 Redis 4.0 中新增了 LFU 算法的缓存淘汰策略，它也是采用了数据抽样机制，然后依据数据的频率值排序，淘汰掉频率值较小的数据。

Redis 的 LFU 实现不是维护一个全局的频率列表，而是为每个键维护一个计数器，这个计数器表示该键被访问的频率，**每个键都有一个 8 位（bit）的计数器，最多可以表示 255 的访问次数**，所以只是记录相对频率，而不是记录总访问次数。

这里的关键在于如何在有限的空间内有效地跟踪频率，以及如何处理计数器的增长和衰减。

##### 计数器增加逻辑：

为了避免频繁访问导致计数器快速溢出，Redis 使用了一个概率算法来决定是否增加计数器的值，它有一个递增衰减因子参数：

**Ifu_log_factor**，默认为 10，值越大，计数器递增的概率越低。

简单来说就是，当一个键访问时，其计数器不是每次都增加，而是会参考递增衰减因子的值，随着计数器的值增大，增加计数器的概率就会逐渐减小，当数值达到 255 时，就不再计算递增逻辑了。

##### 计数器衰减逻辑：

为了处理长时间运行的系统中计数器的自然增长，Redis 引入了衰减逻辑，它有一个时间衰减因子参数：**Ifu_delay_time**，默认为 1 分钟，值越小，计数器衰减的概率会更快。

通过定期运行一个衰减过程，逐渐减少所有键的计数器值，这样可以确保及时某些键在开始时被频繁访问，如果随后很少被访问，它们的计数器值也会逐渐降低，反映出它们的真实使用频率。

---

##### 优点：

1、虽然比 LRU 实现更复杂一点，但和 LRU 一样，在性能和内存占用方面也有不错的表现。

2、可以根据间的使用热度进行淘汰，不会像 LRU 一样可能会淘汰热点数据。

##### 缺点：

1、由于采用概率算法和有限的计数器大小，Redis 的 LFU 实现也不能精确反映每个键的实际访问频率。

2、新加入的键会有一个低的频率基数，这可能导致它们在一开始就被淘汰，尤其是在缓存空间紧张时。

## 75、Redis 怎么配置淘汰策略？

修改 Redis 配置文件：

![](/images/Redis/75.jpg)

默认为**noeviction**，对于写请求不再提供服务，直接返回错误。

配置淘汰策略为”**allkeys-lru**“

```
maxmemory-policy allkeys-lru
```

另外，还可以通过以下命令配置：

> config set maxmemory-police allkeys-lru

## 76、Redis 过期键的删除策略有哪些？

Redis 过期键的删除策略有 3 种：

##### 1、定时删除

设置键的过期时间时，同时创建一个定时器，当键达到过期时间时，让定时器执行键的删除操作。

##### 2、惰性删除

这种策略不会定时、主动去删除过期的键，每次从键空间获取键时，首先检查该键是否过期，如果过期则主动删除该键，否则直接返回。

##### 3、定期删除

程序每隔一段时间会取出一定数量的随机键进行检查，然后删除所有过期的键。

## 77、Redis 如何提高多核 CPU 利用率？

Redis 是一个单线程模型的内存数据库，其网络请求和键值对读写操作默认都是在一个线程中处理的，它无法直接利用多核 CPU 的优势来提高并发处理能力。

不过，有几种方法可以间接提高 Redis 在多核 CPU 上的利用率：

##### 1、使用 Redis 集群

通过搭建 Redis 集群，可以在多个核心上运行多个 Redis 实例，每个实例处理不同的数据分片。这样，客户端请求可以分布到多个实例上并行处理，从而提高了多核 CPU 的利用率。

##### 2、使用多个 Redis 进程

在同一台机器上启动多个 Redis 服务进程，每个进程监听不同的端口，这样，每个 Redis 进程可以绑定到不同的 CPU 核心上，实现并行处理。

##### 3、使用多线程 I/O

从 Redis 6 开始，Redis 引入了多线程 I/O 处理，允许 Redis 在处理网络请求的读写操作时使用多个线程，这样可以在一定程度上提高多核 CPU 的利用率。

## 78、Redis 如何实现大量数据插入？

##### 1、批量插入命令

Redis 提供了一些批量插入命令：

- `MSET`：一次设置多个键值对
- `LPUSH`：一次向列表插入多个值
- `SADD`：一次向集合添加多个成员

等等，这些命令可以一次性执行多个操作，减少网络开销和命令解析的开销。

例如，使用`MSET`命令插入 1000 个键值对：

> MSET key1 value1 key2 value2 ... key1000 value1000

##### 2、管道（Pipelining）

Redis 支持管道技术，可以一次发送多个命令，然后再一次接收所有命令的返回结果。这样可以减少网络延迟的影响，提高数据插入的速度。

##### 3、使用 Lua 脚本

Redis 支持使用 Lua 脚本来执行一系列命令，这样可以将多个命令打包成一个脚本在服务器端一次性执行，避免了多次的网络往返开销。

## 79、Redis 的回收进程如何工作的？

Redis 的回收过程：

- 客户端发送命令给 Redis 服务器，请求写入新的数据。
- Redis 在执行命令前会检查当前内存使用量，如果内存使用量已经达到或者超过了`maxmemory`设置的上限，Redis 将触发内存淘汰机制。
- 根据配置的套题策略，Redis 会决定哪些数据项被移除以释放内存。比如，如果配置的是`allkeys-lru`策略，Redis 会移除最近最少使用的键。
- 一旦内存被回收到`maxmemory`限制以下，Redis 就可以继续执行新的命令。

这样，Redis 通过不断监控内存使用情况，并在达到内存限制时进行数据淘汰，来维持内存使用在一个可控的范围内。

这个过程是动态的，随着新命令的执行和旧数据的淘汰，Redis 的内存使用会在`maxmemory`的阈值附近波动。

## 80、Redis 怎么尽量降低内存使用？

为了尽量降低 Redis 的内存使用，可以采取以下一些策略和优化措施：

1、使用合适的数据结构。

2、优化键和值。

3、使用合适的内存淘汰策略。

4、定期删除不需要的键。

## 81、Redis 为什么要避免使用合并操作？

Redis 避免使用合并操作，如多个命令的自动合并或批处理执行，主要原因是为了保持其高性能和间接性。

##### 1、单线程模型

Redis 使用单线程模型来处理命令，使得 Redis 能够避免多线程编程中的锁、竟态条件等复杂问题，从而保持高性能。如果 Redis 自动合并多个命令为一个更复杂的操作，可能会增加单个命令的执行时间，从而影响到其他命令的响应时间。

##### 2、简洁性

Redis 的设计哲学倾向于保持操作的简洁性，每个 Redis 命令都被设计为执行一个明确的操作，自动合并操作可能会引入额外的复杂性，使得性能优化和故障排查变得更加困难。

##### 3、网络延迟优化

Redis 提供了管道（pipelining）功能，允许客户端一次性发送多个命令到服务器，然后批量读取这些命令的响应。这种方式可以显著减少网络延迟的影响，而不需要在服务器端合并操作，客户端可以根据自己的需求决定是否使用管道，以及如何组织这些命令。

## 82、Redis 中的管道有什么用？

Redis 中的管道技术是指：**Redis Pipelining**，用于提高 Redis 服务的功能。

管道技术可以在服务端还未响应时，客户端仍然可以继续向服务端发送请求，即客户端可以发送多个命令到服务端，而不用等待服务器的响应，客户端会在最后一次性读取所有服务端的响应。

## 83、Redis 有哪些高可用方案？

Redis 提供了多种用于构建高可用性和可扩展性的分布式架构的解决方案，同时也有一些第三方案可以帮助更好地部署 Redis。

#### Redis 官方方案

##### 1、Redis 主从复制

Redis 主从复制是一种简单的复制方案，通过将一个 Redis 实例配置为主服务器（master）和多个实例配置为从服务器（slave），从服务器可以实时同步主服务器的数据，以保持数据一致性。

##### 适用场景：

- **简单高可用性**：适用于需要简单复制以实现高可用性，但不需要自动故障转移的场景。
- **读写分离**：可以配置从服务器来处理只读操作，以减轻主服务器的负担，适合需要将读写分开处理的应用。
- **小规模部署**：适合小规模部署，设置简单，操作直接，但需要手动管理故障转移。

##### 2、Redis Sentinel（哨兵）

Redis Sentinel 是 Redis 官方提供的高可用性解决方案，用于监控 Redis 服务器的状态、自动故障转移、报警以及配置管理。

##### 适用场景：

- **自动故障转移**：适用于需要自动故障转移以确保系统高可用性的场景。
- **实时监控**：适合需要持续监控 Redis 实例状态，并在故障时提供报警或修复方案的场景。
- **中小规模部署**：适用于中小规模 Redis 集群，提供有效的监控和自动化管理。

##### 3、Redis Cluster（集群）

Redis Cluster 提供了内置的数据分片和高可用性功能，数据通过哈希槽（）分配到不同的节点上，每个槽的主节点都有一个或多个从节点备份。

##### 使用场景：

- **高扩展性**：适用于需要扩展以处理大量数据存储和请求的场景。
- **数据分片**：适合需要自动数据分片，将数据分散到不同节点，以减少单一节点负担的场景。
- **高可用性**：适合需要多层级高可用性，包括主从架构、自动故障转移和节点监控的场景。
- **大规模部署**：适合大规模 Redis 部署，可以在多节点置键进行负载分配。

##### 第三方解决方案

##### 1、Codis

Codis 是一个开源的 Redis 分布式代理系统，用于分片 Redis 数据，使多个 Redis 实例组成一个大的逻辑 Redis。

Codis 提供了透明代理层，可以自动分配请求到不同的 Redis 实例，并支持在线数据迁移。

##### 2、Twemproxy

Twemproxy 是一个开源的 Redis 和 Memcached 代理，主要用于分片和读写操作的负载均衡。

Twemproxy 可以将 Redis 请求路由到不同的实例，使应用程序无需感知底层分片细节。

## 84、Redis 集群的目的是什么？

以下是 Redis 集群的主要目标：

##### 1、数据分片

通过将数据分布在多个 Redis 节点上，Redis 集群可以存储和处理的数据量远超单个 Redis 实例的内存限制，这使得 Redis 集群可以应对大数据量的场景，满足更大规模的应用需求。

##### 2、高可用性

Redis 集群通过主从复制和哨兵机制，提供了高可用性，当主节点出现故障时，集群会自动将对应的从节点提升为新的主节点，保证服务的连续可用。

##### 3、分布式处理

在 Redis 集群中，客户端请求会被自动路由到正确的节点，这样可以在多个节点上并行处理命令，提高了整体的吞吐量和处理能力。

## 85、Redis 集群如何选择数据库？

在 Redis 集群模式下，是不支持使用多个数据库的，这与单实例的 Redis 使用 SELECT 命令来切换数据库不同。Redis 集群将数据自动分片到不同的节点上，每个节点都是一个独立的 Redis 实例，但它们指使用默认的数据库 0。

所以，Redis 集群目前无法做数据库选择，默认在 0 号数据库。

## 86、Redis 集群为什么不支持多数据库？

Redis 集群不支持多数据库的设计决策主要基于以下几个原因：

##### 1、简化集群管理

Redis 集群支持多数据库会增加集群的管理复杂性，包括数据分片、复制、故障转移等方面，还需要确保所有数据库之间的数据一致性，限制为单一数据库可以简化这些操作，使集群管理更加高效。

##### 2、提高性能

Redis 集群如果要支持多个数据库，每个数据库都需要进行数据分片和路由，这会增加额外的计算和管理开销，从而可能影响到整体性能。

##### 3、更好的数据模型设计

Redis 的多数据库功能在单实例模式下主要用于逻辑上隔离不同的数据集。但在分布式环境下，通过键名前缀或其他命名约定来组织数据，可以达到类似的效果，同时还能保持数据模型的清晰和一致。

## 87、Redis 集群怎么保证高可用？

Redis 集群使用了**主从复制模型**，即每个节点都可以多个复制品。

比如集群有这三个主节点：

> A, B, C

如果其中一个挂了，集群就不可用了，所以现在为每个节点分配一个从节点：

> A1, B1, C1

这样，如果 A 挂了，A1 就会顶上来，集群继续正常工作。

## 88、Redis 集群最少需要几个主节点？

Redis 集群**至少需要 3 个主节点**来构建一个稳定运行的集群环境。

这是因为 Redis 集群使用了一种叫做投票的机制来处理故障转移和决定哪个节点是不可用的，在一个拥有至少 3 个主节点的集群中，即使一个主节点发生故障，集群中的其他节点仍然可以**通过多数投票的方式**来决定如何进行故障转移，从而保证集群的高可用性。

如果集群中只有 1 个或 2 个主节点，那么在发生节点故障时，集群将无法进行有效的多数投票来决定故障转移，这会影响到集群的可用性和数据的一致性。

因此，为了确保 Redis 集群的高可用性和稳定性，建议至少部署 3 个主节点。此外，为了提供数据冗余和故障恢复能力，每个主节点还可以配置一个或多个从节点。

## 89、Redis 集群主从复制的原理是？

Redis 集群主从复制采用的是异步复制机制。比如，现在有以下节点：

> A -> A1,A2, A3
>
> B -> B1, B2, B3
>
> C -> C1, C2, C3

具体的复制流程如下：

> （1）客户端向主节点 C 写数据
>
> （2）主节点 C 回复该命令状态
>
> （3）主节点 C 再向其他从节点（C1，C2，C3）复制数据

## 90、Redis 集群是怎么做数据分片的？

Redis 集群没有使用一致性 hash 算法，而是引入了哈希槽的概念。

Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点复制一部分 hash 槽。

举个例子，比如当前集群有 3 个节点，那么：

- 节点 A 包含 0 到 5500 号哈希槽
- 节点 B 包含 5501 到 11000 号哈希槽
- 节点 C 包含 11001 到 16383 号哈希槽

当一个客户端发送一个命令到 Redis 集群时，集群首先会根据键值来确定键属于哪个哈希槽。然后，集群将命令路由到复制该哈希槽的节点上进行处理。

这种哈希槽的数据分片繁时确保了数据存储的均衡和高可用性。如果一个节点宕机，集群会自动将故障节点负责的哈希槽重新分配到其余节点上，保证数据的可用性。

## 91、Redis 集群会不会出现写丢失？

Redis 集群不是强一致性，它是最终一致的，会出现丢失写操作数据的情况，以下是可能导致写丢失的几种情况。

##### 1、网络分区

如果集群中的某个主节点与其从节点置键发生网络分区，而再这种情况下客户端仍然向主节点写入数据，这时如果主节点失效，而从节点因为网络分区没有接收到最新的写入，那么当从节点被提升为新的主节点时，这部分数据就会丢失。

##### 2、异步复制

因为再主从复制模式下，数据的写入首先发生在主节点上，然后异步复制到从节点，如果再数据复制到从节点之前主节点发生故障，那么：

- 这些尚未复制的数据可能会丢失；
- 如果客户端从从节点读取数据，可能读到的是还未更新的数据。

这就造成了数据一致性问题。

##### 3、故障转移时的窗口期

在主节点故障后，集群会进行故障转移操作，选举出新的主节点。在这个过程中，有一个短暂的窗口期，在这个窗口期内，写入到故障主节点的数据可能会丢失。

##### 4、配置不当

如果 Redis 集群的配置不当，比如没有足够的从节点或者没有正确配置持久化，也可能增加数据丢失的风险。

## 92、Redis 中的哨兵系统是什么？

Redis Sentinel：哨兵，放哨，看中文名字就知道它是一种 Redis 高可用解决方案，主要是针对 Redis 主从模式实现主从节点监控、故障自动切换。

没有 Redis Sentinel 架构之前，如果主节点挂了，需要运维人员手动进行主从切换，然后更新所有用到的 Redis IP 地址参数再重新启动系统，所有恢复操作都需要认为干预，如果半夜挂了，如果系统很多，如果某个操作搞错了，等等，这对运维人员来说键值就是噩梦。

有了 Redis Sentinel，主从节点故障都是自动换切换，应用程序参数什么也不用改，对于客户端来说都是透明无缝切换的，运维人员再也不用担惊受怕了。

如一个 1 主 3 从的 Redis 架构如下：

![](/images/Redis/92_1.jpg)

加入 Redis 哨兵之后的架构如下：

![](/images/Redis/92_2.jpg)

为了保证 Redis Sentinel 架构自身的高可用性，自身也不能单点，一般也要由 3 个或以上 Sentinel 节点组成，一起负责监控主从节点，当大部分 Sentinel 节点认为主节点不可用时，会选一个 Sentinel 节点进行故障切换。

> 需要注意的是：
>
> Redis 中的 Sentinel 和 Spring Cloud Alibaba 中的 Sentinel 组件是两码事，两者没有任何关联。

## 93、Redis 哨兵系统的工作原理是什么？

Redis 哨兵（）的工作原理分为下面三个步骤：

##### 1、监控

在监控阶段，哨兵对 Redis 的主节点和从节点进行持续的健康检查，定期发送 PING 命令来检查节点是否响应。

如果主节点在配置的超时时间内没有响应哨兵的 PING 请求，哨兵会将该主节点标记为主观下线。

##### 2、通知

当哨兵将一个主节点标记为[主观下线]后，它会与其他哨兵节点进行通信，如果多数哨兵都认为该主节点不可达，那么该节点会被标记为客观下线。

##### 3、故障转移

一旦主节点被标记为[客观下线]，哨兵会自动开始故障转移过程。

首先，哨兵会从现有的从节点中选举出一个新的主节点，选举出新的主节点后，哨兵会通知其他从节点更新它们的复制配置，使它们成为新主节点的从节点。

故障转移过程完成后，哨兵会继续监控新的主节点和从节点，确保系统的稳定运行。

## 94、Redis 可以保证数据强一致性吗？

Redis 只能保证数据的最终一致性，它不能保证数据的强一致性。

> **举个例子：**
>
> 如果使用 Redis 的主从复制特性，数据首先会在主节点上写入，然后异步复制到其他多个从节点上，在复制过程中，如果主节点或者网络发生异常，而从节点还没有接收到最新的数据，那么从节点就会出现数据丢失，从而导致系统可能会出现数据不一致的情况。

尽管 Redis 可以通过某些配置来强化数据的一致性保证，但是在分布式部署和网络分区的情况下，Redis 无法保证强一致性，同时也会牺牲性能和可用性。

回到 CAP 原理，即当发生网络分区（P）时，不能同时满足一致性（C）和可用性（A）。

## 95、Redis 支持的 Java 客户端有哪些？

常用的 Redis 的 Java 客户端有以下几个：

##### 1、Jedis

Jedis 是 Redis 的一个轻量级 Java 客户端，他提供了简单直接的 API 来操作 Redis。Jedis 支持几乎所有的 Redis 命令，并且可以通过连接池来管理连接资源。

##### 2、Lettuce

Lettuce 是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式。Lettuce 基于 Netty，它的连接是非阻塞的，可以在多个线程间共享单个连接。

##### 3、Redisson（官方推荐）

Redisson 是一个在 Redis 的基础上实现的 Java 分布式可伸缩的 Java 数据结构。除了提供对基本操作的支持外，Redisson 还提供了许多高级功能，如分布式锁、集合、映射、发布/订阅、流、时间序列等。

##### 4、Spring Data Redis

Spring Data Redis 是 Spring 框架提供的一个模块，它提供了对 Redis 的高级抽象，使得在 Spring 应用中使用 Redis 变得更加方便。Spring Data Redis 支持 Jedis 和 Lettuce 作为底层连接库。

## 96、Redisson 是什么框架？

Redisson 是 Redis 官方推荐的一个高级的分布式协调 Redis 客户端。

Redisson 在基于 NIO 的 Netty 框架上，充分的利用了 Redis 键值数据库提供的一系列优势，在 Java 使用工具保重常用接口的基础上，为使用者提供了一些列具有分布式特性的常用工具类。

使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度，同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。

## 97、Redis 和 Redisson 有什么关系？

Redisson 是一个在 Redis 基础上构建的 Java 客户端库，它不仅提供了对 Redis 基本操作的封装，还提供了一系列高级功能，如分布式数据结构、分布式服务、分布式锁和同步器、以及其他各种各样的实用工具。

Redisson 旨在为 Java 应用程序提供易于使用的、高级的、可扩展的 Redis 客户端。

## 98、jedis 和 Redisson 对比有什么优缺点？

jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。

Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。

Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

## 99、Redis 为什么不提供 Windows 版本？

以下是一些具体原因：

##### 1、兼容和性能问题

Windows 和 UNIX 操作系统在系统调用层面有很大的不同，Redis 使用了很多 UNIX 系统特有的系统调用，这些在 Windows 上没有直接对应的实现，或者性能表现不佳。

##### 2、开发和维护成本

Redis 团队的资源有限，支持 Windows 需要额外的开发和维护工作。

##### 3、社区和市场需求

因此，社区和市场对于 Windows 版本的需求相对较小，因为大多数使用 Redis 的开发者和公司都在 Linux 操作系统上，这些系统通常用于服务器和生产环境。

## 100、Redis 怎么在 Windows 下使用？

官方没有提供 Windows 版本，不过，微软提供了开源的 Windows 版本：

> https://github.com/MicrosoftArchive/redis/releases

![](/images/Redis/100.jpg)

Windows 版本基于 Redis 3.2.1，好几年没有更新了，所以我也不建议大家在 Windows 下使用 Redis，在 Windows 下装个 Docker 再跑 Redis 也是个不错的方案。

## 101、Redis 如何设置密码访问？

##### 命令设置密码

这种方式是临时的，重启后需要重新设置。

> config set requirepass 123456

##### 配置设置密码

redis.conf 中添加配置：

> requirepass 123456

##### 授权密码：

有两种方式：

> auth 123456

> $ redis-cli -h 127.0.0.1 -p 6379 -a 79695859

## 102、Redis 如何分析慢查询操作？

##### 什么是慢查询

和 MySQL 的慢 SQL 日志分析一样，Redis 也有类似的功能，来帮助定位一些慢查询操作。

Redis slowlog 是 Redis 用来记录查询执行时间的日志系统。

查询执行时间指的是不包括像客户端响应（talking）、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。

另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。

##### 慢查询参数

首先来关注下慢日志分析对应的两个参数：

1、**slowlog-log-slower-than**：预设阈值，即记录超过多少时间的记录，默认为 10000 微秒，即 10 毫秒。

2、slowlog-max-len：记录慢查询的条数，默认为 128 条，当超过设置的条数时最早进入队列的将被移除。线上建议增大数值，如：1000，这样可减少队列移除的频率。

![](/images/Redis/102_1.jpg)

可以用 config set 对这两个参数进行调整，或者在配置文件中设置。

![](/images/Redis/102_2.jpg)

##### 慢查询命令

> 语法：slowlog subcommand [argument]

如，进行查询慢查询、获取慢查询记录的数量、重置慢查询日志等操作：

![](/images/Redis/102_3.jpg)

## 103、什么是缓存预热？

缓存预热是指在系统在上线之前，将常用的缓存数据提前加载到缓存系统中，这样可以确保用户请求时能够直接从缓存中获取数据，避免了查询数据库然后再缓存数据的过程。

## 104、为什么需要缓存预热？

1、应对流量峰值

系统上线初期通常会面临流量高峰，通过预热缓存，可以有效应对大量请求并发而不会冲击数据库。

##### 2、减轻数据库压力

如果没有预热，Redis 在初始状态下没有缓存数据，系统上线初期的所有请求都会直接访问数据库，对应高并发的流量，这会给数据库带来巨大的压力，甚至导致性能下降或服务中断。

##### 3、提高响应速度

缓存预热可以缩短请求的响应时间，避免用户等待数据库查询的延迟，提高整体用户体验。

## 105、缓存预热怎么实现？

##### 1、系统上线前加载

系统上线前，可以提前手动编写脚本，或者定时任务，将需要的数据加载到缓存中，以确保在系统上线后直接可用。

##### 2、系统启动时加载

可以在系统启动时运行一个后台线程，自动将重要数据预加载到缓存中，这种适合缓存数据量不大的情况下，加载数据量过大会影响应用程序的正常运行。

## 106、什么是缓存热备？

缓存热备是一种可用性策略，用于确保缓存服务的稳定性和数据的持续可用性，在这种策略中，会同时运行两个或多个缓存系统：

- 一个作为主要的活动的缓存系统；
- 另一个或多个作为热备份系统；

##### 缓存热备的目的：

1、多个缓存系统之间会实时同步数据，确保它们的数据状态保持一致，也可以降低因单点故障导致数据丢失的风险。

2、如果主缓存系统发生故障，可以迅速切换到热备系统，减少系统的停机时间，提高服务的可用性。

## 107、缓存热备怎么实现？

在 Redis 中可以通过主从复制（Master-Slave-Replication）和哨兵（Sentinel）系统来实现缓存热备。

##### 1、主从复制（Master-Slave Replication）

在 Redis 中，可以设置一个主节点（Master）和一个或多个从节点（Slave）。

主节点负责处理所有的写操作，从节点则复制主节点的数据，并负责所有的读请求，当主节点发生故障时，可以手动将一个从节点提升为新的主节点。

##### 2、哨兵系统（Sentinel）

Redis 哨兵系统是用于管理多个 Redis 服务器的系统，它提供了监控、通知、自动故障转移和服务发现等功能。哨兵可以用来自动完成主从切换，提供更加自动化的缓存热备方案。

## 108、什么是缓存雪崩？

缓存雪崩指的是，在高并发情况下，由于缓存的原因，即 Redis 停机，或者缓存在某个时刻大规模失效，导致大量请求到达后端数据库，从而导致数据库崩溃。

## 109、如何解决缓存雪崩？

##### 1、设置随机过期时间

对于缓存的过期时间，可以设置一个随机的时间范围，避免大量缓存同时失效，这样可以分散缓存失效时的请求，减轻数据库负载。

##### 2、热点数据不设置过期时间

如果某些热点数据确实访问量很多，可以不用设置过期时间。

##### 3、限流降级

给系统设置限流降级方案，比如当流量达到一定的阈值时，就不让请求达到后端服务了，直接返回系统繁忙之类的提示或错误页面，这样至少能保证正常访问量的用户请求，多余的请求多尝试刷新几次就好了。

## 110、什么是缓存穿透？

缓存穿透指的是，在高并发场景下，如果某个键在缓存中未被命中时，这些请求会试图从数据库中获取相应数据，如果该键所对应的数据本身就是空的，这会导致数据库执行大量不必要的查询操作，进而对后端数据库造成巨大的冲击和压力。

## 111、如何解决缓存穿透？

##### 1、缓存空对象

对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非 null），如果是缓存单个对象，可以通过字段标识类区分。这样避免请求穿透到后端数据库。

同时，也需要保证缓存数据的时效性。这种方式实现起来成本较低，比较适合命中不高，但可能被频繁更新的数据。

##### 2、单独过滤处理

使用布隆过滤器（Bloom Filter）存储所有数据，布隆过滤器可以判断元素**可能存在**和元素**一定不存在**两种情况，**但不能判断元素一定存在**，所以在查询缓存前先查询布隆过滤器，不存在就直接返回，不让请求到达缓存以造成缓存穿透。

![](/images/Redis/111.jpg)

## 112、什么是缓存击穿？

缓存击穿是缓存雪崩的一个特例，缓存击穿与缓存雪崩的区别在于，缓存击穿是针对某个特定的[**热点数据**]失效的，而雪崩是大规模或者全部数据。

当某个[热点数据]的缓存到达失效时间时，此时如果有大量的请求到达应用系统，由于没有了缓存层的保护，这些请求同样的会到达 DB 从而可能引起故障。

## 113、如何解决缓存击穿？

##### 1、使用二级缓存

在缓存失效的情况下，可以考虑使用二级缓存，即备用缓存，用于存储在主缓存失效期间的数据。

##### 2、使用互斥锁/分布式锁

在缓存失效的时候，可以使用互斥锁，确保只有一个请求能够重新加载缓存，其他请求需要等待缓存加载完成。这样可以避免多个请求同时穿透到后端。

如果系统是分布式的，可以考虑使用分布式锁来保护缓存的加载操作，确保只有一个节点进行加载，其他节点等待。

##### 3、设置随机过期时间

对于缓存的过期时间，可以设置一个随机的时间范围，避免大量缓存同时失效。这样可以分散缓存失效时的请求，减轻数据库负载。

##### 4、热点数据不设置过期时间

如果某些热点数据确实访问量很多，可以不用设置过期时间。

## 114、什么是缓存抖动？

缓存抖动是指高并发的情况下，缓存项频繁地被置换出缓存的现象，一般发生在缓存空间有限，访问又非常活跃且分布不均匀的情况下。

比如，当一些热点数据不断地被替换出缓存，然后又因为访问需求而被重新加载到缓存中，这种频繁的置换操作会导致缓存命中率下降，增加了会后端数据库的访问压力，进而影响整体的系统性能。

## 115、如何解决缓存抖动？

##### 1、增加缓存容量

确保缓存有足够的容量来存储需要频繁访问的数据，减少因容量限制导致的频繁置换。

##### 2、优化缓存淘汰策略

使用更合适的缓存淘汰算法，如最不经常使用（LFU）算法，可以减少热点数据被置换出缓存的概率。

##### 3、热点数据分离

对于访问频率极高的热点数据，可以将它们单独存储，避免与其他数据竞争缓存空间。

##### 4、设置合理的过期时间

对于不同的数据设置合理的过期时间，避免大量数据同时过期导致缓存抖动。

##### 5、使用缓存层级

通过构建多级缓存架构，即使一级缓存发生抖动，二级缓存仍然可以提供支持。

## 116、什么是缓存无底洞？

Facebook 在 2010 年左右遇到了一个挑战，他们的 Memcached 节点数量已经达到了 3000 个，用于缓存数千 GB 的内容。

##### 在这个规模下，Facebook 的工程师们发现了一个问题：

> 随着 Memcached 连接频率的增加，系统的效率开始下降，为了解决这个问题，他们尝试增加更多的 Mecached 节点，但是问题并没有得到解决，效率问题依旧存在，这个现象被称为缓存无底洞。

因为在现代的数据库、缓存、NoSQL 和搜索中间件等技术中，分片技术被广泛支持，以满足高性能、高并发、高可用和可扩展性的需求。每一次操作都可能与不同的节点进行网络通信以完成任务，节点的数量越多，网络通信的开销就越大，对性能的影响也就越明显。

缓存无底洞现象并不是一个常见的问题，在大多数公司中可能永远都不会遇到这种情况。

## 117、如何解决和缓存无底洞？

可以从以下几个方面避免和优化：

##### 1、不同的数据分布方式

有些业务数据可能适合 Hash 分布，而有些业务适合采用范围分布，这样能够从一定程度避免网络 IO 的开销。

##### 2、IO 优化

可以充分利用连接池、NIO 等技术来尽可能降低连接开销，增强并发连接能力。

##### 3、一次性获取大的数据集

一次性获取大的数据集，会比分多次获取小数据集的网络 IO 开销更小。

## 118、如何解决 Redis 和数据库双写一致性问题？

解决 Redis 和数据库双写一致性问题是一个复杂的问题，涉及到数据同步、更新顺序、网络延迟等多个因素。

以下是常见的解决策略：

##### 1、读写分离策略

所有的写操作都先写数据库，然后再更新缓存，所有的读操作先读缓存，如果缓存中没有，再读数据库并将数据写入缓存。

##### 2、延迟双删策略

在更新数据时，先更新数据库，然后删除缓存，最后再次删除缓存。

第二次删除缓存是为了处理在第一次删除缓存和更新数据库之间，有其他请求将旧数据加载到缓存的情况。

第二次删除缓存的操作可以延迟一段时间执行，比如几百毫秒，以确保在这段时间内，数据库的数据已经更新，即使有其他请求查询数据并加载到缓存，也是最新的数据。

## 119、Redis 有哪些危险命令？如何防范？

##### 还有哪些危险命令？

Redis 的危险命令主要有以下几个：

- keys

客户端可查询出所有存在的键。

- **flushdb**

> Delete all the keys of the currently selected DB. This command never fails.

删除 Redis 中当前所在数据库中的所有记录，并且此命令从不会执行失败。

- **flushall**

> Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.

删除 Redis 中所有数据库中的所有记录，不只是当前所在数据库，并且此命令从不会执行失败。

- **config**

客户端可以修改 Redis 配置。

##### 怎么禁用或重命名危险命令？

看下`redis.conf`默认配置文件，找到`SECURITY`区域，如以下所示。

![](/images/Redis/119_1.jpg)

看说明，添加``配置即可达到安全目的。

##### （1）禁用命令

![](/images/Redis/119_2.jpg)

##### （2）重命名命令

![](/images/Redis/119_3.jpg)

上面的 XX 可以定义新命令名称， 或者用随机字符代替。

经过以上的设置之后，微信命令就不会被客户端执行了。

## 120、你们的 Redis 开发规范是怎样的？

这个不同的公司有不同的约定，这里以阿里云为例说几个阿里云的 Key 设计规范：

- 设计合理的 Key 中 Value 的大小，推荐小于 10KB。
- 设计合理的 Key 名称与长度。
- 对于支持子 Key 的复杂数据结构，应避免一个 Key 中包含过多的子 Key（推荐低于 1000）。
- 推荐使用串行化方法将 Value 转变为可读的结构。
