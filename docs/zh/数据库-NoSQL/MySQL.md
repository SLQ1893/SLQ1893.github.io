## 1、主键、外键有什么区别？

**主键**：用来表示一条记录的唯一标识，不能有重复的，不允许为空，默认为聚集索引，用来保证数据完整性。

**外键**：表的某列是另一表的主键，外键可以有重复的，可以是空值，用来和其他表建立关联用的。

## 2、什么是范式化？

所谓**范式化**，就是一系列设计数据库模型的规范，范式化的目的是减少数据冗余，提高数据完整性。

## 3、什么是反范式化？

所谓**反范式化**，是一种对范式化设计的数据库的性能优化策略，通过在表中增加冗余或重复的数据来提高数据库的读取性能。

没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式化标准，适当保留冗余数据。具体操作就是在一个表中增加另一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。

## 4、三范式分别是指哪三个？

三范式（3NF）是关系数据库设计中的一种规范化形式，用于帮助减少冗余并提高数据库结构的性能和可维护性。三范式定义了三个规则，数据库表必须满足这些规则才能被视为符合三范式。

这三个规则分别是：

##### 第一范式（1NF）

表中的每一列都包含不可再分的原子数据，即每个数据单元都是不可再分的。

##### 第二范式（2NF）

在满足第一范式的基础上，还要求表中的每条数据是可唯一标示的，并且要求表中的非主键列必须完全依赖于整个主键，而不是仅依赖于部分主键。

如果存在不完全依赖，就需要将表分解成更小的表，以满足第二范式。

##### 第三范式（3NF）

在满足第二范式的基础上，要求表中的非主键列之间不应该存在传递依赖关系，即数据表中的每一个非主键字段都和主键字段直接相关，任何非主键列都不应该依赖于其他非主键列。

如果存在非主键列之间的传递依赖，需要进一步分解表以满足第三范式。

## 5、范式化有什么优缺点？

##### 范式的优点：

（1）数据库更新起来更加快；

（2）可以只修改更少的数据；

（3）更少的 distimct/group by 语句；

（4）表更小，可以在内存中执行；

##### 范式的缺点：

范式化没有冗余数据，查询会产生较多关联，并且不能创建符合索引，所以查询性能会大大降低。

## 6、反范式化有什么优缺点？

##### 反范式化的优点：

（1）可以避免关联查询；

（2）可以设计有效的索引；

（3）可以提高查询速度；

##### 反范式的缺点：

表内如果有冗余字段，删除被冗余表的数据时候会造成冗余表有些有用的信息丢失。

## 7、数据库设计时怎么使用范式？

在设计数据库时，不一定强制要求使用标准范式化设计，可以进行一定的调整。

一般的设计是混用范式化和反范式化，适度进行数据冗余，以提高查询性能。

## 8、什么是事务？

事务是指一系列的数据库操作，是数据库应用的基本逻辑单位，如果事务中的任何一个语句操作失败，那么整个事务中的操作就失败，所有操作就会回滚到操作前状态。

事务就是为了保证要么全部执行成功，要么全部执行失败。

## 9、事务有哪几个特性？

数据库事务正确执行的 4 个特性：**ACID**，包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。

##### 1、原子性

事务要么全部被执行，要么就全部不被执行。

##### 2、一致性

事务必须始终保持系统处于一致的状态，不管在任何给定的时间**并发**事务有多少。

##### 3、持久性

在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

## 10、什么是脏读、幻读、不可重复读？

幻读是指一个事务内，同一条 SQL 语句的多次查询的记录条数不一致。

隔离级别与脏读、幻读、不可重复读的关系

| 隔离级别                    | 脏读   | 不可重复读 | 幻读   |
| --------------------------- | ------ | ---------- | ------ |
| READ UNCOMMITED（读未提交） | 允许   | 允许       | 允许   |
| READ COMMITED（读已提交）   | 不允许 | 允许       | 允许   |
| REPEATABLE READ（可重复读） | 不允许 | 不允许     | 允许   |
| SERIALIZABLE（串行化）      | 不允许 | 不允许     | 不允许 |

## 11、MySQL 有哪些事务隔离级别？

##### MySQL 支持四种隔离级别：

##### （1）读未提交（READ UNCOMMITTED）

允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。

##### （2）读已提交（READ COMMITTED）

只能读取到已经提交的数据，Oracle 等多数数据库默认都是这个级别。

##### （3）可重复读（REPEATABLE READ）

可重复读，指在同一个事务内的查询都是事务开始时刻一致的，MySQL InnoDB 的默认级别。

在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻像读。

##### （4）串行化（SERIALIZABLE）

完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

| 隔离级别                    | 脏读   | 不可重复读 | 幻读   |
| --------------------------- | ------ | ---------- | ------ |
| READ UNCOMMITED（读未提交） | 允许   | 允许       | 允许   |
| READ COMMITED（读已提交）   | 不允许 | 允许       | 允许   |
| REPEATABLE READ（可重复读） | 不允许 | 不允许     | 允许   |
| SERIALIZABLE（串行化）      | 不允许 | 不允许     | 不允许 |

## 12、MySQL 默认的事务隔离级别是？

MySQL 默认的隔离级别为：**可重复读**。

## 13、MySQL 事务默认提交模式是？

MySQL 事务默认是**AUTO COMMIT**模式，即“**自动提交**”模式。

如果不显示的开启一个事务，每条 SQL 就会默认当作一个事务进行自动提交。

## 14、MySQL 事务如何开启、禁用自动提交？

查看当前是否自动提交事务模式：

![](/images/MySQL/14_1.jpg)

设置自动提交事务模式：

![](/images/MySQL/14_2.jpg)

1：自动提交事务

0：不自动提交事务

## 15、MySQL 中哪些存储引擎支持事务？

MySQL 中只有**InnoDB**和**NDB Cluster**存储引擎支持事务处理。

## 16、MySQL 切换数据库用什么命令？

使用`use`命令：

![](/images/MySQL/16.jpg)

## 17、MySQL 查看所有数据库有什么命令？

使用`show databases`命令：

![](/images/MySQL/17.jpg)

## 18、MySQL 查看当前库所有表用什么命令？

使用`show tables`命令：

![](/images/MySQL/18.jpg)

## 19、MySQL 有哪些整数数据类型？

MySQL 提供了 5 中整形数据类型：

| 类型        | 字节 |                              | 范围（有符号）     |
| ----------- | ---- | ---------------------------- | ------------------ |
| `TINYINT`   | 1    | （-128， 127）               | （0， 255）        |
| `SMALLINT`  | 2    | （-32768， 32767）           | （0， 65535）      |
| `MEDIUMINT` | 3    | （-8388608， 8388607）       | （0， 16777215）   |
| `INT`       | 4    | （-2147483648， 2147483647） | （0， 4294967295） |
| `BIGINT`    | 8    | （-2^63，2^63 - 1）          | （0， 2^64 - 1）   |

## 20、MySQL 中的`init(1)`和`int(10)`的区别？

一般 int 后面的数字（N），如果不配合 zerofill 一起使用就没有什么区别。

---

如果配合 zerofill 一起使用，不足 N 位则前面补 0，如：

```sql
order_no int(10) zerofill NOT NULL
```

如果插入数据：2024001，只有 7 位，则实际查询出来会显示：000202401

此时的 N 则表示要展示的字符宽度，和存储大小、范围没关系，实际存储还是 202401

## 21、MySQL 有哪些浮点型数据类型？

MySQL 提供了 2 种浮点型数据类型：

| 类型   | 字节 | 说明   |
| ------ | ---- | ------ |
| FLOAT  | 4    | 单精度 |
| DOUBLE | 8    | 双精度 |

## 22、MySQL 浮点型会丢失精度吗？

**浮点型（float、double）会存在精度丢失问题**，即存取数据不一定插入数据库时的精确值，而是近似值。

> 对应精度要求比较高的，比如：金额，建议使用定点型：**decimal**

## 23、MySQL 中的 decimal 和 float，double 的区别？

（1）decimal 是定点型数据类型，float/double 是浮点型数据类型；

（2）decimal 是以字符串形式进行保存，float/double 存储的是近似值（丢失精度）；

（3）当不指定精度时，decimal 默认为 decimal(10, 0)，float/double 默认为实际精度。

## 24、MySQL 中的 decimal 和 numeric 的区别？

这两个都是定点型数据类型，用来存储精确的数据（如货币）。

两者的区别如官网描述：

> In MySQL, `NUMERIC` is implemented as `DECIMAL`, so the following remarks about `DECIMAL` apply equally to `NUMERIC`.

即：numeric 和 decimal 同义。

## 25、MySQL 中的 unsigned 关键字有什么用？

unsigned 为”无符号“的意思，表示”非负数“，即不允许插入负数。

unsigned 可用来增长数据的长度，例如：

> tinyint 有符号范围（-128， 127），最大值是 127
>
> tinyint 无符号（unsigned）范围（0， 255），最大值就可以达到 255

## 26、MySQL 支持 Bit 数据类型吗？

支持的，MySQL 中的 Bit(M)用来存储 Bit 值，如`b'111'`and`b'10000000'`表示数字 7 和 128。

M 表示 1~64 个长度，如果制定了 Bit(M)，插入数据的长度不够 M 位会自动补 0。

## 27、MySQL 支持哪几种时间类型？

MySQL 中常见的时间类型有三种：

| Type      | 范围                                              | Remark             |
| --------- | ------------------------------------------------- | ------------------ |
| DATE      | 1000-01-01 ~ 9999-12-31                           | 只有日期，没有时间 |
| DATETIME  | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59         | 日期 + 时间        |
| TIMESTAMP | 1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC | 日期 + 时间        |

## 28、MySQL DATETIME 和 TIMESTAMP 怎么选？

一般用 DATETIME，但想根据时区自动显示对应时间的选择 TIMESTAMP，但要注意这个时间范围：

> 1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC

## 29、MySQL DATETIME 和 TIMESTAMP 的区别？

1、时间范围不一样，TIMESTAMP 要小很多；

> ​ DATETIME 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
>
> TIMESTAMP 1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC

2、DATETIME 原样存储和返回，TIMESTAMP 具有时区属性，以 UTC 格式存储，能自动检索当前时区并进行转换；

3、DATETIME 占用 8 字节，TIMESTAMP 占用 4 字节；

4、DATETIME 默认值为 null，TIMESTAMP 默认值为系统当前时间（current_timestamp）。

## 30、MySQL 的自增 ID 如果用完了，会怎么样？

如果主键自增使用的是 INT UNSINGED，则最大值为：4294967295，**如果用完了，即达到了上限，得到的值保持不变（还是最大值：4294967295，再次插入则会报主键冲突错误。**一般 INT UNSINGED 够用了（上亿了）），数据量特别大的可以考虑使用 BIGINT UNSIGNED。

## 31、MySQL 的自增 ID 一定是连续的吗？

MySQL 自增主键并不一定是连续的值，在某些情况下可能存在间隔或不连续的情况。

##### 比如以下几个场景：

---

##### 1、删除记录

如果从表中删除了一些记录，即使是中间的记录，下一次插入的新记录的自增主键值也不会填补已删除记录的空缺，自增主键只会基于最大的已存在值进行递增，所以此时删除的记录就会造成不连续了。

##### 2、回滚操作

如果执行了一个事务，并在事务回滚之后重新执行该事务，但是之前已经生成的自增主键值将会被跳过，不会被重新使用。

##### 3、批量插入

当使用批量插入语句`INSERT INTO ... VALUES (), (), ()...`插入多个记录时，自增主键的值将递增，但它们之间可能存在间隔。

##### 4、主键冲突

如果插入记录时发生了主键冲突（比如 username 重复），数据库下次插入会继续递增，从而跳过了已生成的值。

## 32、MySQL 是否支持序列？

**MySQL 不支持序列，Oracle 才有序列的概念，但是，MySQL 可以通过实现一个自定义函数来实现序列。**

MySQL 是使用自增主键来生成唯一的标识符的，自增主键通过使用``属性来实现，可以在插入新记录时自动递增，如以下示例：

```sql
CREATE TABLE user (
  id INT AUTO_INCRMENT PRIMARY KEY,
    name VARCHAR(50)
)
```

## 33、什么是索引？

在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

数据库使用索引可以使 SQL 语句执行得更快，可快速访问数据库表中的特定数据。

## 34、索引有什么用？

##### 优点：

（1）可以大大加快数据的检索速度，这也是创建索引的最主要的原因；

（2）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

（3）可以加速表和表之间的连接， 特别是在实现数据的参考完整性方面特别有意义；

##### 缺点：

（1）索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；

（2）创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；

（3）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；

## 35、索引为什么能提高查询效率？

（1）索引数据的存储是有序的；

（2）因为有序，通过索引查询数据是无需遍历所有记录的；

（3）极端情况下，数据索引的查询效率为二分查询效率，趋近于 log2(N)

## 36、索引的设计有哪些原则？

（1）对于经常查询的字段，建议创建索引。

（2）索引不是越多越好，一个表如果有大量索引，不仅占用磁盘空间，而且会影响 INSERT，DELETE，UPDATE 等语句的性能。

（3）避免对经常更新的表进行过多的索引，因为当表中数据更改的同时，索引也会进行调整和更新，十分消耗系统资源。

（4）数据量小的表建议不要创建索引，数据量小时索引不仅起不到明显的优化效果，对于索引结构的维护反而消耗系统资源。

（5）不要在区分度低的字段建立索引。比如性别字段，只有“男”和“女“，建索引完全起不到优化效果。

（6）当唯一性是某字段本身的特征时，指定唯一索引能提高查询速度。

（7）在频繁进行排列分组（即进行 group by 或 order by 操作）的列上建立索引，如果待排序有多个，可以在这些列上建立组合索引。

## 37、索引对数据库有什么负面影响？

##### 索引建立是有开销的：

1、创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；

2、不光是数据库表需要占用数据空间，每个索引也都需要占用额外物理空间；

3、当对表进行增、删、改时，索引也要动态维护，减低了数据的维护速度；

## 38、什么情况下应不建或少建索引？

##### 以下几种情况不适合建立索引：

（1）表中数据太少；

（２）经常插入、删除、修改的表；

（３）表数据重复且分布平均的表字段；

等等。。。

## 39、MySQL 索引的种类有哪些？

MySQL 的索引有两种分类方式：**逻辑分类和物理分类**。

##### 1、按照逻辑分类，索引可分为：

- **普通索引**，仅加速查询（MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。）
- **唯一索引**：加速查询 + 列值唯一（可以有 null）
- **主键索引**：加速查询 + 列值唯一（不可以有 null） + 表中只有一个。
- **复合索引**：多个列组成一个索引，用于多个字段组合搜索。
- **全文索引**：目前只能在 MyISAM、InnoDB 引擎上才能使用，只能在 CHAR，VARCHAR，TEXT 类型字段上使用全文索引，可以通过每个关键字找到该字段所属的记录行。

##### 2、按照物理分类，索引可分为：

- **聚集索引**：也叫聚簇索引，是指数据行的物理顺序与列值（）的逻辑顺序相同，一个表中只能拥有一个聚簇索引。**MySQL 中一般默认主键为聚集索引**。
- **非聚集索引**：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。

| 动作描述           | 使用聚集索引 | 使用非聚集索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 小数目的不同值     | 应           | 不应           |
| 大数目的不同值     | 不应         | 应             |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |

## 40、MySQL 索引命名有什么规范？

##### 一般命名规则如下：

##### 1、主键索引（primary）

pk\_字段名，如：pk_id;

##### 2、唯一索引（unique）

uk\_字段名，如：uk_idcard;

##### 3、普通索引（index）

idx\_字段名，如：idx_name_age;

## 41、MySQL 二级索引是什么？

二级索引即非聚集索引，聚集索引之外的其他索引都属于**二级索引**，也叫辅助索引。

比如：唯一索引、普通索引、前缀索引等都是二级索引。

## 42、MySQL 有了聚簇索引为啥还要二级索引？

因为聚簇索引的叶子节点存储的是一行完整的数据，而二级索引只存储了主键值，所以相比于聚簇索引，二级索引占用的空间要少很多。

如果全部都是聚簇索引，那将占用大量的空间，所以在 MySQL InnoDB 引擎中，只有主键建立的索引才是聚簇索引，其他的都是非聚簇索引。

## 43、MySQL 索引最左匹配原则怎么理解？

**索引最左匹配原则**：就是指在 MySQL 复合索引中从最左边开始匹配的原则，如果你的 SQL 语句中用到了复合索引中的做左边的索引，那么这条 SQL 语句就可以利用这个联合索引进行匹配。

**如：建立 abc 三个字段的复合索引，就相当于建立了索引：（a），（a, b），（a, b, c）**

索引字段可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。

值得注意的是，当遇到范围查询（>、<、between、like）就会停止匹配，如：

![](/images/MySQL/43_1.jpg)

另外，（a, c）只会用到 a 索引。
![](/images/MySQL/43_2.jpg)

## 44、MySQL 中的隐藏索引是什么？

MySQL 8.0 虽然发布很久了，但可能大家都停留在 5.7x，甚至更老，其实 MySQL 8.0 新增了许多重磅新特性，比如“**隐藏索引**”或者“**不可见索引**”。

隐藏索引 字面意思就是把索引进行隐藏，即不可见，它不是用来查询优化的，所以它不会被优化器使用到。隐藏索引适用于除主键索引（显示或者隐式设置）之外的索引，意味着主键索引是不能通过任何方式隐藏的。

MySQL 数据库默认创建的索引都是可见的，要显式控制一个索引的可见性，可以在 CEREATE TABLE，CREATE INDEX 或 ALTER TABLE 的索引定义命令中使用`VISIBLE`或`INVISIBLE`关键字。

如下面示例所示：

```SQL
CREATE TABLE user (
 age INT,
 weight INT,
 tall INT,
 INDEX age_idx (age) INVISIBLE
) ENGINE = InnoDB;
CREATE INDEX weight_idx on user (weight) INVISIBLE;
ALTER TABLE user ADD INDEX tall_idx (tall) INVISIBLE;
```

要变更现有索引的可见性，可以在 ALTER TABLE .... ALTER INDEX 命令中使用`VISIBLE`或`INVISIBLE`关键字。

##### 年龄索引变更为不可见（隐藏）：

```sql
ALTER TABLE user ALTER INDEX age_idx VISIBLE;
```

怎么知道一个表中的索引可见还是不可见，可以从 INFORMATION_SCHEMA.STATUSTCS 表，或者 SHOW INDEX 命令输出中获得。例如：

![](/images/MySQL/44_1.jpg)

##### 隐藏索引有什么用？

从上面隐藏索引介绍我们知道，隐藏索引可以不被优化器所使用，那么我们可以把某个表的某个索引设置隐藏，然后再测试 SQL 语句的查询性能。

即可以利用隐藏索引快速测试删除索引后对 SQL 查询性能的影响，而无需进行索引删除、重建操作，如果需要该索引，再设置可见就好了，这在大表测试中无疑非常有用，因为对于大表索引的删除和重新添加很耗性能，甚至影响表的正常工作。

##### 隐藏所以设置

如果一个索引被设置成隐藏了，但实际上又需要被优化器所使用，有几种表索引情况缺失对查询造成的影响：

（1）SQL 查询语句中包含了索引提示指向不可见索引会发生错误；

（2）性能模式数据中显示了受影响 SQL 查询语句的负载增高；

（3）SQL 查询语句进行 EXPLIAN 时出现了不同的执行计划；

（4）SQL 查询语句出现在了慢查询日志中（之前没有出现）；

系统变量 optimizer_switch 的**use_inbisible_indexes**标志的值，控制了优化器执行计划构建时是否使用隐藏索引。

如果 use_inbisible_indexes 值设置为**off**关闭状态（默认值），优化器默认会忽略隐藏索引，即和加入该参数之前的效果一样。

如果 use_inbisible_indexes 值设置为**on**打开状态，隐藏索引仍然保持不可见，但优化器会把隐藏索引加入到执行计划的构建中。

如果想要在某条单个 SQL 查询语句上启用隐藏索引，可以使用 SET_VAR 优化器提示来临时更新 optimizer_switch 的值，如下所示：

![](/images/MySQL/44_2.jpg)

索引的可见性不会影响索引的自身维护，例如，不管索引是可见还是不可见，每次表数据行的更改索引都会更新，并且唯一索引也可防止插入重复数据。

没有显式主键的表如果在 NOT NULL 列上有任何一个唯一索引，则仍可能成为有效的隐式主键。在这种情况下，第一个这样的索引会对表数据行施加与显式主键相同的约束，并且该索引不能设置为不可见。

如以下表定义：

```sql
CREATE TABLE user (
  age INT NOT NULL,
    weight INT NOT NULL,
    UNIQUE weight_idx (weight)
) ENGINE = InnoDB;
```

该表定义不包含任何显式主键，但是 weight 列为 NOT NULL，在该列上创建的唯一索引在数据行上与主键具有相同的约束，并且不能使其不可见：

```
mysql > ALTER TABLE user ALTER INDEX weight_idx INVISIBLE;
ERROR 3522 (HY000): A primary key index cannot be invisible.
```

假设现在我们将一个显式主键添加到表中：

```sql
ALTER TABLE user ADD PRIMARY KEY (age);
```

显式主键不能设置为不可见，此时，weight 列上的唯一索引不在充当隐式主键，因此可以使其设置不可见。

```
mysql > ALTER TABLE user ALTER INDEX weight_idx INVISIBLE;
Query OK,0 rows affected (0.03sec)
```

##### 总结

本文介绍了 MySQL 8.0 中的新特性：隐藏（不可见）索引，这个索引并不是新加的索引类型，而是可以控制索引是否加入到执行计划的构建之中。

在实际生产中也可以利用隐藏索引进行 SQL 语句的性能测试，或者对索引进行逻辑删除，以及索引的灰度发布测试等，用处还是蛮大的。

## 45、MySQL 索引实现是什么数据结构？

MySQL 不同的索引对于索引有不同的支持。

InnoDB 和 MyISAM 索引使用的是 B + Tree，而 Memory 索引使用的是 Hash。

## 46、MySQL 一个表最多创建多少个索引？

A：8

B：16

C：64

D：无限制

---

答案可参考 MySQL 8.0 文档说明：

![](/images/MySQL/46.jpg)

## 47、MySQL 索引最多包含多少个列？

A：8

B：16

C：64

D：无限制

---

答案可参考 MySQL 8.0 文档：

![](/images/MySQL/47.jpg)

## 48、MySQL 支持哈希索引吗？InnoDB 引擎呢？

MySQL 支持哈希索引，不过**只有 MEMORY 数据库引擎支持哈希索引**，MySQL 绝大多数都是 B+树索引，比如：**PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT**，它们都是 B+树索引存储的。

MySQL 的 InnoDB 引擎不支持哈希索引，如官方文档：

> https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html

![](/images/MySQL/48.jpg)

虽然 InnoDB 引擎不支持主动创建哈希索引，但 InnoDB 引擎为了提升热点数据的等值查询效率，其内部使用了哈希表实现了自适应哈希索引功能。

## 49、MySQL 中的自适应哈希索引是什么？

MySQL 中的自适应哈希索引，英文全称为：**Adaptive Hash Index**，它是 MySQL InnoDB 存储引擎**优化热点数据查询性能**的一种策略，它通过动态地根据查询模式创建哈希索引来**提高等值查询的速度**，特别是一些热点数据的等值查询。

##### 使用场景：

自适应哈希索引主要适用于具有频繁等值查询的热点数据，对于范围查询和排序等操作不适用，这些操作适用于 B+树索引。

##### 工作原理：

MySQL 自适应哈希索引底层使用的是**哈希表**来存储数据的，当某个表的某一列的等值查询非常频繁时，InnoDB 会自动创建自适应哈希索引，并将这个值及其相关的行添加到哈希索引中。

自适应哈希索引会根据查询模式的变化进行动态调整，如果某个值的查询频率减少，哈希索引可能会相应地缩小。反之，如果某个值的查询频率增加，哈希索引可能会扩大。

> ##### 需要注意的是：
>
> 自适应哈希索引的创建、使用、更新和删除等操作是由 MySQL InnoDB 自身内部决定的，用户是无法主动干预/进行这些操作。

自适应哈希索引在 InnoDB 存储引擎中默认是开启的，但是可以通过`innodb_adaptive_hash_index`配置参数进行控制关闭，也可以通过服务端启动时添加`--skip-innodb-adaptive-hash-index`参数进行关闭。

## 50、MySQL 索引为什么选用 B + Tree 作为数据结构？为什么不是其他？

MySQL 选择使用 B + Tree 作为索引的数据结构，主要是因为 B + Tree 在数据库索引的应用场景中提供了一系列的优势。

下面是一些 B + Tree 相比于其他数据结构的优点：

##### 1、查询效率高

B + Tree 是一种平衡多路查找树，它可以保证每个叶子节点的高度相同，所有的查询操作都能在 O（log n）时间复杂度内完成。

##### 2、支持范围查询

由于 B + Tree 的叶子节点之间是相互链接的，所以它非常适合顺序访问，以及执行范围查询操作。

##### 3、磁盘 I/O 性能优化

B + Tree 的设计考虑到了磁盘 I/O 操作的成本，通过减少磁盘访问次数来提高性能。节点的大小通常与磁盘页的大小相匹配，这样可以最大化地利用磁盘预读特性。

##### 4、动态数据维护

B + Tree 支持高效地数据插入、删除操作，同时可以保持树地平衡。

---

相比之下， 其他数据结构如二叉搜索树、红黑树等虽然在理论上也可以用于索引，但它们在数据库索引的应用场景中存在一些局限性：

- 普通的二叉搜索树在最坏情况下会退化成链表，导致查询效率大幅下降；
- 红黑树虽然是平衡的，但其节点存储的键值较少，不适合磁盘页的大小，会增加磁盘 I/O 操作；
- 哈希表虽然在最佳情况下可以提供常数时间的查询效率，但它不支持范围查询和顺序访问，且在处理大量冲突时性能会下降。

所以，B + Tree 成为了 MySQL 索引的首选数据结构。

## 51、MySQL B + 树索引和哈希索引的区别？

##### 主要有以下 4 点区别：

（1）哈希索引适合等值查询，但是无法进行范围查询；

（2）哈希索引无法利用索引完成排序；

（3）哈希索引不支持多列联合索引的最左匹配规则；

（4）如果有大量重复键值的情况，就可能存在哈希碰撞问题，哈希索引的效率会很低；

所以说，B + 树索引绝对适用于大多数场景，用 B + 树索引就可以了。

## 52、MySQL B + 树的一个节点为多大？

一页，页是 MySQL 自定义的单位，MySQL 的 InnoDB 引擎一页的默认大小是：16K，存取数据的时候都是这样一页一页的获取索引文件中节点数据的。

## 53、MySQL 索引在哪些情况下会失效？

##### MySQL 索引失效常见的场景：

1、不符合索引最左匹配原则，详情见另外一道题；

2、like 模糊查询以%开头，如%张；

3、索引列上使用了函数、表达式计算；

4、数据类型出现隐式转化，即查询条件索引列类型和查询值数据类型不一致；

5、JOIN 条件中索引列数据类型不一致；

6、条件存在 NULL 值，如：name is not null；

7、使用了!=、<>、IN、NOT IN 判断条件；

8、查询条件使用了 or，要想索引生效，or 中的每个列都加上索引；

...

## 54、where 1=1 是什么意思？

来看这个 SQL：

```sql
select * from test
where 1 = 1
and type = "微信小程序"
and name = "Java面试题"
```

如果后面两个条件（and）是根据值动态拼接的，如果条件 type 不成立，没有 1 = 1 会是这样：

```sql
select * from test
where
and name = "java面试题"
```

即前面的条件不成立，后面的条件就会成为第一个条件，然而多了一个 and 就会报错，1 = 1 的写法就是为了避免这种情况，不管后面哪个参数不成立都不会说多一个 and 报错。

## 55、where 1 = 1 会导致索引失效吗？

MySQL 中的 where 1 = 1 是不会影响索引的正常命中的，反正这种无意义的条件会被优化掉。

但是，最好别这么写，如果存在过多的 where 1 = 1 也可能会有效率影响，毕竟优化也是需要消耗资源的。

## 56、一定要写 where 1 = 1 吗？有没有其他方案？

where 1 = 1 当然不是必须的，在 MyBatis 中至少有两种方案：

（1）使用 where 标签

（2）使用 trim 标签

如果实在 Java 代码中，也有很多方法来判断，只不过没有 where 1 = 1 方便了。

## 57、MySQL 中的 IN 和 NOT IN 会走索引吗？

##### 答案：不一定。

IN 正常是走索引的，但如果 IN（）范围过大会导致索引失效。

NOT IN 也不一定，走不走索引，也有很多前提条件，MySQL 查询优化器会根据当前表的情况选择最优方案。

## 58、MySQL 中为什么要尽量避免使用 IN 和 NOT IN？

主要有以下几个原因：

（1）如果条件范围过大，则会导致索引失效而全表扫描；

（2）容易出现问题，或者查询结果和预期不一致（如数据字段存在 NULL 值，则结果可能有误）；

## 59、MySQL 中的 IN 和 NOT IN 有什么替代方案？

（1）使用 EXISTS 或 NOT EXISTS 代替；

（2）使用 JOIN 连接代替；

## 60、MySQL 统计 count(\*)，count(字段)，count(1)，推荐用哪个？

MySQL 中建议直接使用 count(_)，它并不会把全部字段取出来统计，因为底层已经对 count(_)做了深度优化了。

它们的性能可以这样排序：

> count(\*) > count(1) > count(主键) > count(字段)

## 61、MySQL 中的 distinct 和 group by 那个性能更好？

##### 1、语义相同，有索引的情况

如果都能使用索引，使用 distinct 和 group by 性能近乎相同。

##### 2、语义相同，无索引的情况

这时需要看 MySQL 的版本：

- **MySQL 8.0 之前**：distinct 的性能要高于 group by，因为虽然 distinct 和 group by 都会进行分组操作，但在 MySQL 8.0 之前，group by 会进行隐式排序，所以会导致 SQL 效率低下。
- **MySQL 8.0+**：distinct 和 group by 的性能是近乎相同的，MySQL 8.0+中删除了 group by 中的隐式排序。

## 62、MySQL 如果删除主键，会发生什么？

如果 MySQL 表删除了主键，或者没有创建主键，也没有非空唯一索引（如果有，则为主键），MySQL 会生成一个长度为 6 位字节的默认主键（rowid）。

如果表有创建主键的话，rowid 就是该主键 ID。

## 63、MySQL 默认最大的连接数是多少？

MySQL 5.5，5.6，5.7：默认的最大连接数都是 151，上限为：100000。

![](/images/MySQL/63.jpg)

## 64、MySQL 数据库引擎怎么选择？

##### MySQL 的四种存储引擎对比：

| 功能 |     |     |     |
| ---- | --- | --- | --- |
|      |     |     |     |
|      |     |     |     |
|      |     |     |     |
|      |     |     |     |
|      |     |     |     |
|      |     |     |     |
|      |     |     |     |

## 65、MySQL 默认数据库引擎是什么？

MySQL 5.5 之前默认的事务型引擎是：

**MyISAM**

MySQL 5.5 开始默认的事务型引擎修改为：

**InnoDB**

## 66、MySQL 引擎 MyISAM 和 InnoDB 的区别？

##### 主要区别：

1、MyISAM 不支持事务，InnoDB 支持事务；

2、MySIAM 只支持表级锁，InnoDB 支持表锁和行级锁；

3、MyISAM 不支持外键，InnoDB 支持；

4、MyISAM 允许没有任何索引和主键，InnoDB 必须要有；

5、MyISAM 表和索引分两个文件存储，InnoDB 表和索引都保存在同一个数据文件中；

## 67、MySQL InnoDB 引擎的物理存储文件？

##### MySQL InnoDB 引擎在磁盘上存储了两个文件：

##### 1、.frm

存储与表相关的元数据信息，包括表结构的定义信息等；

##### 2、.idb

存储 InnoDB 所有表数据和索引；

---

注意：MySQL 8.0+ 没有.frm 了，元数据都存储在系统表空间里。

## 68、MySQL MyISAM 引擎的物理存储文件？

##### MySQL MyISAM 引擎在磁盘上存储了三个文件：

##### 1、.frm

存储与表相关的元数据信息，包括表结构的定义信息等；

##### 2、.myd

存储 MyISAM 引擎的表数据；

##### 3、.myi 文件

存储 MyISAM 引擎的表索引相关数据；

## 69、MySQL 中 char 和 varchar 的区别？

##### 1、char 是固定长度的，而 varchar 是可变长度的

字段 b：类型 char(10)，值为：abc，存储为：abc（abc + 7 个空格）

字段 d：类型 varchar(10)，值为：abc，存储为：abc（自动变为 3 个的长度）

2、char 最多可以存放 255 个字符，varchar 的最大长度为 65535 个字节

## 70、MySQL 支持 JSON 数据类型吗？

MySQL 5.7+可以支持 JSON 类型，包括以下两种类型：

- JSON 对象
- JSON 数组

JSON 类型的好处就是无需创建预留字段，可以灵活扩展字段信息，建议用在不怎么更新的静态数据字段上。

## 71、MySQL 怎么存储用户画像比较好？

用户画像即用户标签，比如：

- 80 后
- 本科
- 爱网购
- 宅男
- 程序员
- 单身
- 。。。

##### MySQL 有以下几种方案：

- 单独建表存储（占用过多资源）
- 使用一个字符型字段存储，用某个分隔符分开（不利于搜索）
- 使用 JSON 数组类型存储（**利于搜索，推荐使用**）

## 72、常用的 SQL JSON 连接及区别？

##### SQL JOINS 连接大全图：

![](/images/MySQL/72.jpg)

##### 常用的有以下几种：

INNER JOIN：两个表中记录匹配时才返回匹配的行。

LEFT JOIN：以左表为参考匹配，返回左表中的所有行，右表中如果有匹配行则返回，没有匹配项则返回 null。

RIGHT JOIN：以右表为参考匹配，返回右表中的所有行，左表中如有匹配行则返回，没有匹配项则返回 null。

FULL JOIN：它结合了 LEFT JOIN 和 RIGHT JOIN 的所有记录。

## 73、MySQL 驱动表和被驱动表的区别？

驱动表，即总是先读取的表，被驱动表反之。

## 74、MySQL 驱动表和被驱动表怎么区分？

| 连接方式      | 驱动表     | 被驱动表   |
| ------------- | ---------- | ---------- |
| left join     | 左表       | 右表       |
| right join    | 右表       | 左表       |
| join          | 优化器决定 | 优化器决定 |
| straight_join | 左表       | 右表       |

## 75、MySQL 连表查询时，用哪个表作驱动表？

##### 小表驱动大表！！！

总是应该用**小表**作为驱动表，即参与过滤后的总数据量较小的表。

## 76、MySQL 到底能不能使用连表查询（join）？

有的公司 的 DBA 禁止使用 join，其实这是不正确的。

##### 用不用 join 得分情况！！！

在使用 join 之前可以使用 explain 命令分析下 SQL 语句，看看 Extra 上使用到的 join 算法信息：

- Index Nested Loop Join：这个表示被驱动表上了索引，是可以正常使用 join 的。
- Block Nested Loop Join：这个表被驱动表没有用到索引，会导致全表扫描，大量占用系统资源，所以性能会非常差，不建议使用 join。

## 77、为什么有的公司禁止使用 join？

**用的不好会严重影响 MySQL 的性能及系统资源。**

## 78、MySQL 连表查询（join）有什么要注意的？

（1）超过 3 个表最好不要使用 join；

（2）需要 join 的字段，数据类型保持绝对一致，保证 join 字段用上索引；

（3）使用 explain 分析表索引、SQL 的性能，再决定是否用 join；

## 79、MySQL 连表查询（join）有什么优化措施？

以下几点供你参考：

（1）总是以小表驱动大表；

（2）参与 join 的字段必须用上索引，如被驱动表索引，可以考虑先过滤到临时表再 join；

（3）Block Nested-Loop Join 算法改为 Batched Key Access 算法

> set
>
> optimizer_switch='mrr=on, mrr_cost_based=off, batched_key_access=on';

## 80、MySQL 中的 straight_join 是什么？

STRAIGHT_JOIN 与 JOIN 类似，表示固定让左边的表驱动右边的表，即左表始终在右表之前读取，能改变优化器对于连表查询的执行顺序。

使用示例：

```sql
select * from t1 straight_join t2 t1.id = t2.tid;
```

这样会固定使用左表 t1 作为驱动表。

## 81、MySQL 中的 straight_join 和 join 的区别？

假如有表 t1，t2：

如果直接使用 join，则 t1，t2 都有可能会被优化器选作驱动表。

如果使用 straight_join，则固定指定左边的 t1 为驱动表。

## 82、MySQL 中的 straight_join 适用哪些表连接？

MySQL 中的 straight_join 只能用于内连接，因为 left/right join 这种连接方式明确指定了连接的驱动表。

## 83、MySQL 中的 straight_join 怎么用比较合适？

一般有以下几个用途：

（1）一般连表查询的话，建议是小表放在左边， 以驱动大表。所以如果你事先知道哪个表的连表查询数据量较小的话，可以使用 straight_join 这种连接方式固定左表为驱动表，以此进行 SQL 优化。

不建议使用，防止乱用出错，另外，优化器往往比人要聪明，除非优化器选择错误，可以手动指定。

（2）可以用来进行 SQL 语句的性能测试、调优等。

## 84、SQL 中的笛卡尔积是什么？

笛卡尔积又叫笛卡尔乘积，是一个叫笛卡尔的人提出来的，是在多表进行联合查询的时候会出现的一种情况，返回一张表乘以另一张表的结果， 很少用到。

比如下面查询两张表：

```sql
select student_name, class_name from student,class
```

如果 student 表有 10 条记录，class 表有 5 条记录，即每个学生都对应了每个课程，那么查询结果就是 10 \* 5 = 50 条记录了，这样就会出现笛卡尔积。

MySQL 中使用 CARTESIAN JOIN 连接方式就是笛卡尔积。

## 85、如何避免 SQL 出现笛卡尔积？

##### 如何避免 SQL 笛卡尔积：

1、使用查询条件、连接时是唯一关联字段；

2、如果关联字段不唯一，先使用 DISTINCT 去重再连接；

## 86、union 和 union all 的区别？

**union**：对两个查询结果集进行合并，不包括重复行，会进行默认排序；

**union all**：对两个查询结果集进行合并，包括重复行，不会进行排序；

## 87、为什么不建议用 union 而用 union all？

因为**union**会进行数据驱虫过滤操作，另外还会进行默认排序，所以性能很慢。

除非必要，一般要使用**union all**来进行结果合并操作。

## 88、什么是存储过程？

我们平时写的 SQL 语句都是一条一条的，而存储过程则是一组特定功能的 SQL 语句。储存过程可以理解为是一个函数，可以有输入、输出值，它可以像写代码一样完成一系列的逻辑。

MySQL 创建存储过程语法参考：

> create procedure 存储过程名（参数列表）
>
> begin
>
> // ...存储过程体
>
> end;

## 89、为什么要有存储过程？有什么优势？

##### 使用存储过程的好处：

（1）存储过程可以在数据库端实现一个特定的、复杂的功能；

（2）存储过程可以重复使用，减少冗余；

（3）一次编译，永久有效，减少了与服务器连接交互的次数（减少了编译次数和成本）；

（4）存储过程 SQL 参数化，可以有效预防 SQL 注入攻击；

## 90、存储过程需要编译吗？每次执行时编译还是？

SQL 是每次执行都会进行编译，而存储过程只需要一次编译，预先编译， 可多次执行。

## 91、阿里巴巴禁止使用存储过程，为什么？

阿里巴巴禁止使用存储过程，这是阿里巴巴的 Java 开发手册中规定的。

##### 原因主要有以下几点：

（1）难以调试和扩展；

（2）一致性较差；

## 92、什么是触发器？

触发器也是数据库表有关的数据库对象，当满足预设的条件时触发，并执行触发器中定义的语句集合。

举个例子：

> 当删除 A 表的某条数据时，如果有触发器，就会触发删除 B 表的某条数据。

## 93、MySQL 中都有哪些触发器？

MySQL 中有 6 种触发器：

（1）Before Insert

（2）After Insert

（3）Before Update

（4）After Update

（5）Before Delete

（6）After Delete

## 94、为什么不建议使用触发器？

触发器现在基本很少使用了，尽量少使用触发器，也不建议使用。

##### 原因主要有以下几点：

（1）太消耗资源；

（2）难以调试和扩展；

（3）移植性较差；

（4）用的不好还会造成难以排查的问题；

## 95、MySQL 的 drop、delete、truncate 的区别？

**drop** 是删除表的数据及表结构，以及被依赖的约束（constrain）、触发器（trigger）、索引（index）。

**truncate** 是清空物理文件，同时清空表中的所有内容，但不删除表结构。

**delete** 是逻辑删除数据，按行删除，而且可以通过 where 语句选择要删除的行。

速度上，**drop > truncate > delete**。

## 96、MySQL 怎么实现分页查询？

##### MySQL 分页查询语法：

> SELETE \* FROM table LIMIT [offset,] rows | rows OFFSET offset

LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。

LIMIT 接受一个或两个数字参数，参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。

初始记录行的偏移量是 0（而不是 1）：为了与 PostgreSQL 兼容，MySQL 也支持语法：LIMIT # OFFSET #。

查询第 5 ~ 29 行记录示例：

> select \* from table limit 4, 16

4 代表偏移量，16 代表要返回的记录条数。

## 97、MySQL 的高可用方案有哪些？

##### 常用的解决方案如下：

1、主从复制

2、MySQL Cluster

3、MySQL + MMM

4、MySQL + MHA（成熟，常用）

## 98、如何分析一条 SQL 语句的执行计划和性能？

在 MySQL 中使用 explain 命令，如：

> explain select \* from test where ...

![](/images/MySQL/98.jpg)

##### 通过 explain 语句可以知道如下内容：

（1）表的读取顺序。（对应 id）

（2）数据读取操作的操作类型。（对应 select_type）

（3）哪些索引可以使用。（对应 passible_keys）

（4）哪些索引被实际使用。（对应 key）

（5）表直接的引用。（对应 ref）

（6）每张表有多少行被优化器查询，但对于 InnoDB 来说只是个预估数值，不一定精确。（对应 rows）

。。。

## 99、MySQL 查询优化有哪些方法？

##### 比如以下 10 个：

（1）不要在索引列上使用表达式计算；

（2）不要在索引列上使用 IS NULL 和 IS NOT NULL

（3）避免子查询，用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN；

（4）尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引；

（5）不要 select \*；

（6）尽量别使用外键；

（7）索引字段不要使用范围查询（>、<、between、like）；

（8）尽量避免大事务操作，提高系统并发能力；

（9）where 判断 null 影响效率，尽量给字段一个默认值；

（10）学会用 explain 命令进行分析；

。。。

## 100、MySQL 为什么不建议默认 null 值？

##### 主要有以下几个原因：

（1）值比较复杂

（2）索引的效率会下降很多，因为它们使得索引、索引的统计信息以及比较运算更加发杂

（3）NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回永远为空结果，查询容易出错

更多查询的坑~~

## 101、MySQL 为什么尽量选择最小数据类型？

因为最小的数据类型会占用更小的磁盘、内存、CPU 缓存和周期，所以也会更快

## 102、MySQL 模糊查询会导致索引失效吗？

用 like 模糊查询时，%和\_通配符放在前面会导致索引失效：

![](/images/MySQL/102_1.jpg)

通配符放到后面不会影响索引：

![](/images/MySQL/102_2.jpg)

## 103、MySQL 模糊查询怎么匹配一个字符？

使用\_下划线通配符可以匹配单个字符，如：

![](/images/MySQL/103.jpg)

只能匹配一个，不能是 0 或者多个。

## 104、MySQL 模糊查询怎么匹配多个字符？

使用%百分号通配符可以匹配多个字符，如：

![](/images/MySQL/104.jpg)

可以匹配 0 个或者多个字符，但不能匹配 NULL 值。

## 105、MySQL 怎么记录慢查询语句？

可以在 MySQL 中开启慢查询日志：

```conf
# 开启慢查询
slow_query_log=1

# 指定记录慢查询语句的日志文件
slow_query_log_file=slow_query.log

# 指定慢查询阈值，超过这个值将记录日志，默认10s
long_query_time=10
```

## 106、MySQL 支持查询结果缓存吗？

可以的，开启了缓存的情况下，当查询同一条语句时，如果命中缓存，MySQL 会跳过解析、优化和执行，立刻返回结果，并且缓存结果是被所有会话共享的。

##### 不过，MySQL 8.0 已经废除了该功能：

![](/images/MySQL/106.jpg)

这个功能也不太建议使用，建议还是在应用层使用 Redis 之类的缓存。

## 107、MySQL 如何解决单表数据量过大，查询变慢的问题？

MySQL 数据库表中的数据越来越多，查询变慢，新增操作也会变慢，如何解决呢？

##### 1、表分区

表分区可以在区间内查询指定的数据，降低查询范围，并且对索引分区也可以进一步提高命中率，提升查询效率。

##### 2、分库分表

分库分表后的数据可以分摊到不同的 MySQL 数据库、表，这样就可以更彻底的解决 MySQL 单表容量产生的问题。

##### 3、冷热归档

其实就是分表的另外一种用法，比如以下场景：

> 某些业务可能只需要查最近一个月、一个季度、一年的数据，它们称为热数据，而之前的历史数据（冷数据）不会提供给终端查询。

这时就可以把历史数据（冷数据）归档到其他的表中，然后删除原始数据，提升热数据的查询效率。

## 108、怎么理解数据库中的乐观锁？

##### 乐观锁

乐观锁相当于 Java 的 CAS 算法，所以多条数据同时过来的时候，不用等待，可以立即进行返回。

乐观锁可以采用版本号的方式，及当前版本号如果对应上了就可以写入数据，如果判断当前版本号不一致，那么就不会更新成功，比如：

```sql
update table set column = value where version = ${version} and otherKey = ${otherKey}
```

相对悲观锁，乐观锁更适用于谢少读多的情景，如果同时写比较多，循环次数比较多会造成数据库性能下降。

## 109、怎么理解数据库中的悲观锁？

##### 悲观锁

悲观锁相当于 Java 的 synchronized，reentrantLock 锁等，大量数据过来的时候，一条数据同时只用一个事务可以更新，其他的数据需要等待，执行完成后下一条数据可以继续。

悲观锁实现的机制一般是在执行更新语句的时候采用 for update 方式，比如：

```sql
update table set column = 'value' for update
```

这种情况 where 条件一定要涉及到数据库对应的索引字段，这样才会是行级锁，否则会是表锁，这样执行速度会变慢。

相对乐观锁，悲观锁更适用于写多读少的情景。

## 110、MySQL 中的 for update 锁的是什么？

##### 开启事务：

**如果是主键或者索引字段**：for update 会锁住主键、索引字段对应行的数据；

**如果是普通字段**：for update 会锁住整张表，所以说要注意使用索引。

比如，如果一条语句 A 使用了`FOR UPDATE`，那么就会锁住相应的数据；

- 其他事务不能修改 A 语句锁定的数据；
- 如果查询语句 B 也使用了`FOR UPDATE`，语句 B 会被阻塞，知道语句 A 释放相应的锁；
- 如果查询语句 C 没有使用`FOR UPDATE`，语句 C 可以正常查询。

---

##### 未开启事务：

for update 不会锁任何数据。

## 111、MySQL 中的 MVCC 是指什么？

MVCC 全称：Nutil-Version Concurrency COntrol，即多版本并发控制。

MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

MVCC 可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此开销更低。

MVCC 的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。

## 112、MySQL InnoDB 的 MVCC 实现机制？

InnoDB 的 MVCC 实现是通过保存数据在某个时间点的快照来实现的。

一个事务，不管其执行多长时间，其内部看到的数据是一致的，也就是事务在执行的过程中不会相互影响。

**通过在每行记录后面保存两个隐藏的列来实现：**

一个保存了行的创建时间，一个保存行的过期时间（删除时间），当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增。

## 113、MySQL 中的 MVCC 支持哪些事务隔离级别？

| 事务隔离级别 | MVCC   |
| ------------ | ------ |
| 读未提交     | 不支持 |
| 读已提交     | 支持   |
| 可重复读     | 支持   |
| 串行化       | 不支持 |

读未提交每次读取的是最新数据行，而不是读取符合当前事务版本的数据行。

串行化则会对所有读取的行加锁，所以也不存在事务版本。

## 114、MySQL 锁的种类有哪些？

![](/images/MySQL/114.jpg)

## 115、MySQL 支持哪三种级别的锁？

MySQL 的锁级别有以下三种：行级锁、表级锁、页级锁。

| 类型   | 开销 | 加锁速度 | 死锁 | 锁定粒度 | 锁冲突概率 | 并发读 |
| ------ | ---- | -------- | ---- | -------- | ---------- | ------ |
| 行级锁 | 大   | 慢       | 会   | 最小     | 最低       | 最高   |
| 表级锁 | 小   | 快       | 不会 | 最大     | 最大       | 最低   |
| 页级锁 | 适中 | 适中     | 会   | 适中     | 适中       | 适中   |

## 116、MySQL InnoDB 支持什么锁？

MySQL InnoDB 引擎支持以下锁：

- Shared and Exclusive Locks（共享/排他锁）
- Intention Locks（意向锁）
- Record Locks（记录锁）
- Gap Locks（间隙锁）
- Next-Key Locks（临键锁）
- Insert Intention Locks（插入意向锁）
- AUTO-INC Locks（自增锁）
- Predicate Locks for Spatial Indexs（空间索引的谓词锁）

## 117、MySQL 中的共享锁是什么？

共享锁，全称为：**Shared Locks**，又可称为[**读锁**]、[**S 锁**]，多个事务可以同时对同一数据持有共享锁，持有共享锁的事务只能读取数据，不能修改数据。

共享锁可以防止其他事务修改数据，其他事务只有等数据行上的共享锁释放后，才能修改数据。比如当某个事务进行数据的读操作时，可以通过`SELECT ... LOCK IN SHARE MODE`的方式对数据加上共享锁，示例如下：

```sql
-- 开启事务
START TRANSACTION;

-- 添加共享锁
SELECT * FROM t_order WHERE id = 1 LOCK IN SHARE MODE;
```

这样，其他事务可以正常读取数据，但如果想要修改这行数据，则会进入阻塞状态，直到数据行上的共享锁释放或锁超时。

## 118、MySQL 中的独占锁是什么？

独占锁，全称为：**Exclusive Locks**，又可称为[**排他锁**]、[**写锁**]、[**X 锁**]，独占锁只能有一个，当事务对数据添加独占锁后，其他事务不能再添加任何锁，它与独占锁和共享锁都是互斥的。

比如当某个事务对数据进行写操作（INSERT、UPDATE、DELETE）时，MySQL 默认会给相关数据添加独占锁，但 SELECT 语句默认不会添加，可以使用`SELECT ... FOR UPDATE`主动添加独占锁，示例如下：

```sql
-- 开启事务
START TRANSACTION;

-- 添加独占锁
SELECT * FROM t_order WHERE id = 1 FOR UPDATE;
```

这样，其他事务就不能通过`LOCK IN SHARE MODE`和`FOR UPDATE`的方式获取数据，否则则会进入阻塞状态，直到独占锁释放或锁超时。

需要注意的是，其他事务可以通过`SELECT * FROM`直接查询数据，因为普通查询没有任何锁机制。

## 119、MySQL 中的表锁是什么？

表锁，即锁定整个表，分为**表读锁**和**表写锁**。

| 锁类型         | 自己可读 | 自己可写 | 自己可操作其他表 | 他人可读 | 他人可写 |
| -------------- | -------- | -------- | ---------------- | -------- | -------- |
| 表读锁（S 锁） | 是       | 否       | 否               | 是       | 否       |
| 表写锁（X 锁） | 是       | 是       | 否               | 否       | 否       |

使用语句如下：

```sql
LOCK {TABLE | TABLES}
  [tb1_name [[AS] alias] lock_type]...
  [ tb1_name [[AS] alias] lock_type]...

lock_type: {
  READ [LOCAL] | [LOW_PRIORITY] WEITE
}

UNLOCK {TABLE | TABLES}
```

使用示例如下：

```sql
-- 对表上读锁
lock table t_user read;

-- 对表上读锁
lock table t_user write;

-- 查看上锁的表
show open tables where in_use > 0;

-- 释放表锁
unlock tables;
```

## 120、MySQL 中的表锁有哪些？

表级锁有以下几种：

- 表锁
- 元数据锁
- 意向锁
- 自增锁

## 121、MySQL 中的元素据锁是什么？

元数据锁，全称为：**Metadate Locking**，简称[]锁，属于[**MDL**]锁，MySQL 使用[**表级**]定来管理对数据库对象的并发访问并确保数据一致性；

> **举个例子：**
>
> 如果一条 SQL 正在查询数据，另外又有人再改变表结构，比如删除了表中的一个列，这样就会导致查询出问题，所以，元数据锁的机制就是为了保证数据一致性的。

具体实现机制，当 MySQL 执行 DML、DDL 语句时都会申请元素据锁，DML 操作需要申请元素据读锁，DDL 操作需要申请元素据写锁。多个 DML 操作之间不会阻塞，可以并发执行，但 DML 操作之间不会阻塞，多个 DDL 操作也会互相阻塞。

另外，元数据锁是 MySQL 底层自动控制的，用户无法直接干预。

## 122、MySQL 中的意向锁是什么？

意向锁（Intention Locks）是 MySQL InnoDB 引擎中的一种表级锁，它是一种允许表锁和行锁共存的一种锁，用于协调事务间的加锁机制，以避免冲突和死锁问题。

当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。

如果自己需要一个共享锁定，就申请一个**意向共享锁**。如果需要的是某行（或者某些行）的排他锁定，则申请一个**意向排他锁**。

**比如**：事务 A 锁住表中的**一行（行锁）**，事务 B 锁住**整个表（表锁）**。

没有意向锁就会互相产生冲突，有了意向锁之后，事务 A 在申请行锁（写锁）之前，会自动先给事务 A 申请表的意向排他锁，当事务 B 去申请表的写锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的写锁时会被阻塞。

> 需要注意的是：
>
> 意向锁是 MySQL 自行维护的一种协调事务加锁的机制，用户并不能直接使用，他在事务创建行锁和表锁时创建，在事务提交或回滚之后自动释放。

## 123、MySQL 中的意向锁的分类？

意向锁包括：

##### 1、意向共享锁（IS 锁）

全称为：**Intention Shared Locks**，事务打算给数据行共享锁，事务在请求某些行的共享锁（S 锁）前，要先获得表的 IS 锁。

##### 2、意向排他锁（IX 锁）

全称为：**Intention Exclusive Locks**，事务打算给数据行加排他锁，事务在请求某些行的排他锁（X 锁）前，要先获得表的 IX 锁。

| 请求锁模式/是否兼容/当前锁模式 | X    | IX   | S    | IS   |
| ------------------------------ | ---- | ---- | ---- | ---- |
| X                              | 冲突 | 兼容 | 冲突 | 冲突 |
| IX                             | 冲突 | 兼容 | 冲突 | 兼容 |
| S                              | 冲突 | 冲突 | 兼容 | 兼容 |
| IS                             | 冲突 | 兼容 | 兼容 | 兼容 |

## 124、MySQL 中的意向锁是表锁还是行锁？

MySQL 中的意向锁（Intention Lock）是表锁（Table Lock）。

意向锁用于协调事务对表的锁定操作，是为了支持事务并发控制而引入的概念，当一个事务要对某个表中的行进行操作时，可以先获取该表的意向共享锁（IS 锁）或意向排他锁（IX 锁），以表示该事务将对表中的某些行进行读取或写入操作，以实现更好的并发控制和性能。

## 125、MySQL 中的自增锁是什么？

自增锁是一种特殊的表锁，由插入具有`AUTO_INCREMENT`列的表的事务获取，如果表中存在自增字段，MySQL 便会自动维护一个自增锁，该锁会在 INSERT 结束后立即释放。

简单的流程如下：

- 在执行插入语句时，在表上加一个自增锁；
- 为每条待插入记录的自增列分配递增的值；
- 在该语句执行结束后，再把自增锁释放掉。

如果一个事务持有了自增锁，其他事务的插入语句则会被阻塞，直到持有锁的事务释放了自增锁，这样可以保证一个自增列分配的值是递增连续的。

MySQL 有一个`innodb_autoinc_lock_mode`变量，用于控制用于自增锁的算法，它允许我们选择如何在可预测的自动增量值序列和插入操作的最大并发度之间进行权衡。

## 126、MySQL 中的行锁有哪些？

MySQL 中的行级锁包括：

- 记录锁
- 间隙锁
- 临键锁
- 插入意向锁

## 127、MySQL 中的全局锁是什么？

全局锁就是对整个数据库整个实例进行加锁，全局锁的典型使用场景是，对整个数据库进行逻辑备份，就是把数据库中所有表中的数据都读取出来，进行备份。

加表锁命令为：

> FLUSH TABLES WITH READ LOCK;

加锁后，数据库处于只读状态，以下三类语句将会被阻塞：

- 所有 DML 语句；
- 所有 DDL 语句；
- 更新操作的事务提交语句；

释放全局锁的命令如下：

> UNLOCK TABLES;

## 128、MySQL 中的记录锁是什么？

MySQL 中的记录锁，全称为：**Record Locks**，俗称**行锁**。

比如我们常用以下 SQL 语句：

> select \* from t_user where uid = 1 for update;

它会在查询的记录上加上记录锁，其他事务的插入、更新、删除操作都会被阻塞，直到事务结束并释放记录锁或事务超时。

## 129、MySQL 中的间隙锁是什么？

间隙锁全称为：**Gap Locks**，它基于非唯一索引，锁定的是一个范围，用于防止其他事务在某个范围内插入数据，这样可以避免[**幻读**]问题的出现。

比如以下示例：

> select \* from t_user where age between 10 and 15 for update;

由于索引是基于 B+树的结构存储，所以会存在一个索引区间，如果，表中存在范围为(10, 15]的间隙锁，则在 10 ~ 15 之间的插入数据（11，12，13，14）操作就会被阻塞，但是 10 和 15 本身并不会被锁。

间隙锁只作用于可重复读隔离（RR）事务隔离级别，它的存在是为了解决该级别下的幻读问题，因此，多个间隙之间并不互斥，是兼容的关系。

## 130、MySQL 中的临键锁是什么？

临键锁全称为：Next-Key Locks，它是记录锁和间隙锁的组合，不仅能锁定范围内的所有索引记录（左开右闭区间，不锁左边，只锁右边），还能锁定一个范围不能插入数据。

比如以下示例：

> select \* from t_user where age between 10 and 15 for update;

如果，表中存在范围为(10, 15]的临键锁，则在 10 ~ 15 之间的插入数据(11，12，13，14)操作就会被阻塞，同时 15 这条记录也被锁住了。

## 131、MySQL 中的插入意向锁是什么？

插入意向锁，全称为：Insert Intention Locks，它是一种在 INSERT 操作之前设置的一种间隙锁。

插入意向锁表示的是一种插入意图，即当多个不同的事务，同时往同一个索引的同一个间隙中的不同位置插入数据的时候，它们互相之间无需等待，即不会阻塞。

假设有值为 4 和 7 的索引记录，现在有两个事务，分别尝试插入值为 5 和 6 的记录，在获得插入行的排他锁之前，每个事务使用插入意向锁锁定 4 和 7 之间的间隙，但是这两个事务不会相互阻塞，因为行是不冲突的。

> 简单理解，虽然插入意向锁锁定了索引之间的间隙，但是插入意向锁之间并不会互相阻塞。

---

##### 如以下示例：

客户端 A 创建一个包含两条索引记录（90 和 102）的表，然后启动一个事务，对 ID 大于 100 的索引记录设置排他锁，排他锁包括了记录 102 之前的间隙锁：

![](/images/MySQL/131_1.jpg)

此时，上面的事务还没提交，然后客户端 B 开始事务，并以将记录 101 插入到间隙中：

```sql
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```

然后使用`SHOW ENGINE INNODB STATUS`命令，或者在 InnoDB 监视器中会看到以下内容：

![](/images/MySQL/131_2.jpg)

事务在等待获取排他锁时获取了插入意向锁，因为插入意向锁和排他锁是互斥的，但多个插入意向锁之间并不互斥。

## 132、MySQL 行锁是锁的是什么？

MySQL 的行锁并不是直接锁记录，而是**锁索引**。

如果一条 SQL 语句用到了主键索引，MySQL 会锁住键索引，如果一条语句操作了非主键索引，MySQL 会先锁住非主键索引，再锁定主键索引。

## 133、MySQL 行锁实现的几种算法？

##### Record Lock：单个记录上的锁

锁住索引记录，锁住的是 key，如果 InnoDB 存储引擎在建立的时候没有设置任何一个索引，那么这时 InnoDB 会使用隐式的主键进行锁定。

##### Gap Lock：间隙锁，锁定一个范围，但不包含记录本身

锁定索引记录间隙，确保索引记录的间隙不变，防止其他事务的插入操作，以此防止幻读。

##### Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

在 Next-Key Lock 算法下，InnoDB 对于行的查询都是采用这种锁定的算法，可以有效的防止幻读。

当查询的索引含有唯一属性时，InnoDB 存储引擎会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。

当查询的索引为辅助索引时，默认使用 Next-Key Locking 技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。

## 134、MySQL 什么情况会发生死锁？

两个或两个以上事务在执行过程中因争抢锁资源而造成的互相等待就是**死锁**。

![](/images/MySQL/134.jpg)

## 135、MySQL 产生死锁有哪些必要条件？

##### 产生死锁的四个必要条件：

##### （1）互斥条件

一个资源每次只能被一个进程使用；

##### （2）请求与保持条件

一个进程因请求资源而阻塞时，对已获得的资源保持不放；

##### （3）不剥夺条件

进程已获得的资源，在未使用完之前，不能前行剥夺；

##### （4）循环等待条件

若干进程之间形成一种头尾相接的循环等待资源关系；

## 136、MySQL 死锁怎么排查？

##### （1）查看当前事务中是否有锁信息

```sql
select trx_id, trx_state, trx_started, trx_requested_lock_id, trx_weight from information_schema.innodb_trx;
```

##### （2）查看锁信息（表锁 or 行锁，锁的那张表）

```sql
select lock_id, lock_trx_id, lock_mode, lock_type, lock_table, lock_index from information_schema.innodb_locks;
```

##### （3）查看锁在等待哪些事务

```sql
select * from information_schema.innodb_lock_waits;
```

## 137、MySQL 如何解决死锁？

##### MySQL 有两种死锁处理方式：

**1、超时等待**（innodb_lock_wait_timeout=50s）

**2、死锁检测**，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）

由于性能问题，一般推荐使用死锁检测来进行处理死锁。

##### 死锁检测

死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在既有死锁。

##### 回滚

检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。

## 138、MySQL 如何避免死锁？

##### 1、按顺序加锁

如：

Transaction 1：更新表 A -> 更新表 B

Transaction 2：更新表 B -> 更新表 A

这类问题要从程序上避免，所有的更新需要按照一定的顺序。

##### 2、添加合理的索引

如果 SQL 不走索引将会为表的每一行记录添加上锁，死锁的概率大大增加。

##### 3、减少持有锁的时间

保证没有长事务，尽量早提交事务，锁就越早释放。

等待。。。

## 139、MySQL 和 MariaDB 的区别？

MariaDB 数据库治理体系是 MySQL 的一个分支，主要由开源社区在维护，采纳 GPL 授权许可。

开发这个分支的缘故原由之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，是以社区采纳分支的方式来避开这个风险。

MariaDB 的目标是完全兼容 MySQL，使之能轻松成为 MySQL 的取代品。

## 140、MySQL 有哪些类型的日志？

| 名称           | 描述         |
| -------------- | ------------ |
| general log    | 一般查询日志 |
| slow query log | 慢查询日志   |
| binlog         | 二进制日志   |
| errorlog       | 错误日志     |
| relay log      | 中继日志     |
| redo log       | 重做日志     |
| undo log       | 回滚日志     |

## 141、MySQL 中的 binlog 日志是什么？

binlog 日志也叫归档日志，是一种以二进制形式（binary）存储的日志，它记录了 MySQL 中所有的 DDL 和 DML 日志，只记录数据库的更改操作，select / show 等无影响的命令除外。

## 142、MySQL 中的 binlog 日志有什么用？

##### binlog 日志的主要用途：

##### 1、主从同步：

Master 记录 binlog 日志，并传递给 Slaves 以保持主从数据同步；

##### 2、数据恢复：

可以使用 mysqlbinlog 工具恢复数据；

## 143、MySQL 中的 relay log 日志是什么？

relay log 和 binlog 差不多，它是主从同步时用到的一种中继日志。

从服务器的 IO 线程读取到主服务器的 binlog 日志，然后写入到自己的 relay log 日志文件中，后续再由 SQL 线程读取并解析 relay log 日志进行数据复制。

## 144、MySQL 日志 undo 和 redo 的区别？

undo log 主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚；

redo log 主要记录的是物理层面的数据页、偏移量，MySQL 异常宕机后，可以将没来得及提交的事物数据重做出来，用来保证事务的持久性，即事务 ACID 中的 D；

## 145、MySQL 中的 Change Buffer 是什么？

**MySQL 的 Change Buffer 是一种在内存中的缓存机制，可用于优化插入、更新和删除操作，提升数据写入性能。**

MySQL 5.6.2+中的 Change Buffer 大小可以通过配置参数 innodb_change_buffer_max_size 进行配置，该参数默认值为 25%的缓冲池大小，最大可设置为 50%的缓冲池大小。

> Change Buffer 实现原理如下：
>
> 当执行一个插入、更新或删除操作时，MySQL 会将数据的变更记录到 Change Buffer 中，而不是直接写入磁盘，之后再通过一定的策略将这些变更写入到磁盘上的数据文件中，这样可以避免频繁地更新磁盘数据，提高写入性能；

---

Change Buffer 适用于如下情况：

- **大量的插入、更新和删除操作**：如果一个表包含大量的插入、更新和删除操作，使用 Change Buffer 可以减少磁盘 I/O 操作，提高数据修改的性能。
- **磁盘性能较差的情况**：如果磁盘的随机读写性能较差，使用 Change Buffer 可以避免频繁的磁盘 I/O 操作，提高数据修改的性能。

---

Change Buffer 也有一些限制和缺点：

- **Change Buffer 的大小是有限的**：Change Buffer 的大小是有限的，当缓存区满时，MySQL 会将记录直接写入磁盘，这样会影响插入、更新和删除的性能。
- **Change Buffer 只能用于非唯一索引**：Change Buffer 只能用于非唯一索引，不能用于唯一索引，因为唯一索引需要进行校验和重复检查。

## 146、MySQL 中的 Buff Pool 是什么？

MySQL 中的 Buff Pool 是一个内存缓存区，用于缓存 MySQL 中的数据，可以显著提高 MySQL 的查询性能，特别是在高并发、大数据量的情况下。

当执行查询操作时，MySQL 会先从 Buff Pool 中读取数据，如果 Buff Pool 中存在相应的数据，则直接返回结果。否则，MySQL 会从磁盘中读取数据，并将其写入 Buff Pool 中。

Buff Pool 的大小可以通过配置参数`innodb_buffer_pool_size`来进行设置，默认是 128MB，一般情况下，建议将 Buff Pool 的大小设置为系统可用内存的 50%~80%左右，但不能超过可用的物理内存。

> 需要注意的是：
>
> （1）Buff Pool 中的数据是不稳定的，如果 MySQL 异常退出或者关闭，buffer pool 中的数据会丢失。因此，在使用 Buff Pool 缓存数据时，需要定期备份数据以防止数据丢失。
>
> （2）如果 Buff Pool 的大小设置过大，会占用过多的内存资源，影响系统的性能。因此，在使用 Buff Pool 时，需要根据实际情况进行配置和调整，以达到最优的性能和效率。

## 147、MySQL 中的 Change Buffer 和 Buff Pool 区别？

MySQL 中的 Change Buffer 和 Buffer Pool 是两个不同的概念，**它们分别用于优化 MySQL 的数据修改（Change Buffer）操作和优化数据查询操作（Buffer Pool）**，它们优化的目标操作不一样。

MySQL 通过合理的配置和使用 Change Buffer 和 Buffer Pool，可以进一步提高 MySQL 的读写性能。

## 148、MySQL 中的 Log Buffer 是什么？

Log Buffer，即：日志缓冲区，它是要写入到磁盘上日志文件的数据的一块内存区域，日志缓冲区的内容会定期刷新到磁盘。

##### Log Buffer 的几个相关参数：

| 参数名                         | 作用 |
| ------------------------------ | ---- |
| innodb_log_buffer_size         |      |
| innodb_flush_log_at_trx_commit |      |
| innodb_flush_log_at_timeout    |      |

大型日志缓冲区允许大事务运行，而无需在事务提交之前将 redo 日志数据写入磁盘，所以，如果有更新、插入或删除大量数据行的事务，则可以增加日志缓冲区的大小以提升磁盘的 I/O 效率。

## 149、MySQL 支持哪几种数据复制方式？

##### 1、异步复制

最简单，也是性能最好的，但是主备之间数据不一致的概率很大。

##### 2、全同步复制

全同步复制牺牲了一定的性能，保证数据安全，不丢失数据。

##### 3、半同步复制（MySQL 5.5+）

性能和数据安全按行都介于异步和全同步复制之间

##### 4、组复制（MySQL 5.7+）

数据一致性和系统可用性更高。

## 150、MySQL 默认的数据复制方式是什么？

MySQL 默认的数据复制方式是：**异步复制**。

## 151、MySQL 中的异步复制你怎么理解？

MySQL 的异步复制原理，主要是依靠数据库的二进制日志（Binlog）文件进行数据复制的。

![](/images/MySQL/151.jpg)

##### 大概过程如下：

1、Master 进行数据更新；

2、Master 将当前事务 Binlog 事件写入到 Binlog 文件中；

3、Master 的 Dump 线程通知 Slave 有新的事务并发送 Binlog；

4、Slave 的 IO 线程接收到 Binlog 并写入到自己的 relay log 文件中；

5、Slave 的 SQL 线程再写入到本地数据库完成数据同步；

## 152、MySQL 异步复制丢失数据吗？

异步复制会出现数据丢失的情况。

因为主库事务是不管数据有没有同步到从库都会提交的，主库只是将事务 Binlog 事件写入到 Binlog 文件中，并由另外一个 Dump 线程进行发送 Binlog 日志，然后主库继续处理提交操作，并不保证这些 Binlog 是否会成功传到任何一个从库节点上。

所以，如果主库出现故障，主库已经提交的事务如果没有及时同步到从库上，就会导致数据丢失。

## 153、MySQL 中的半同步复制你怎么理解？

如图，相比全同步复制，半同步复制不需要等所有 Slave 节点完成接收、提交等操作，而只需要任意一个 Slave 完成即可，然后 Master 再确认提交，最后再返回客户端。

![](/images/MySQL/153.jpg)

所以这种同步方式性能和数据安全性都介于异步和全同步复制之间。

## 154、MySQL 中的全同步复制你怎么理解？

全同步复制即组复制，如图，相比异步复制，全同步复制需要所有 Slave 节点完成接收、提交等操作后，然后 Master 再确认提交，最后再返回客户端。

![](/images/MySQL/154.jpg)

所以这种同步方式可以保证数据不会丢失，但性能也会受很大影响。

## 155、MySQL 中的组复制你怎么理解？

**组复制**（也叫：**全同步复制**），即 MGR 架构（MySQL Group Replication），是 MySQL 5.7.17 提供的高可用、高扩展、高可靠的集群方案，它是通过 Paxos 算法来保证集群数据的高可用性的，是一种全同步复制解决方案。

![](/images/MySQL/155.jpg)

具体的算法是，基于原生的主从复制，然后将个节点归入到一个组中，添加一个一致性层，提交事务之前发送集群广播（Paxos 算法），只有获得一致性层同意之后才能提交事务。

## 156、MySQL 数据库如何全量备份？

##### 1、加全局锁备份

使用全局锁，然后通过官方自带的逻辑备份`mysqldump`命令备份数据，完成后释放全局锁。

使用示例如下：

```sql
FLUSH TABLES WITH READ LOCK;
mysqldump -u root -p 123456 test > test.sql
UNLOCK TABLES;
```

全局锁很方便，但缺陷挺大的：

- 如对主库使用全局锁进行备份，大概率会导致业务停滞；
- 对从库使用全局锁进行备份，又会有主从延迟的问题；

因此，我们需要一个更好的方案。

##### 2、不加锁备份

不加全局锁，使用`mysqldump`命令并添加`single-transaction`参数，使用示例如下：

```sql
mysqldump -u root -p 123456 --single-transaction test > test.sql
```

在导数据之前就会启动一个事务，并在事务中读取数据，其导出过程中读到的数据是一个快照，以确保在备份过程中始终处于一致的状态。

这种方案对生产环境影响较小，它可以避免在备份大型数据库时出现长时间的阻塞，并且在备份过程中还不影响其他事务的数据更新操作。

> 需要注意的是：
>
> 备份的数据库引擎必须支持事务，必须使用事务隔离级别，比如：，如果使用的是等不支持事务的引擎，该选项将被忽略。

## 157、MySQL 数据库如何增量备份？

全量备份在数据量较大时，备份时间会比较长，如果增量备份可以解决问题，可以考虑增量备份，增量备份一般只备份最近一次全量备份之后的变动数据，因此备份数据量会比较小，备份时间也不会也会可控。

##### 1、使用 mysqlbinglog 命令

使用 MySQL 自带的二进制日志文件读取工具：mysqlbinlog，它可以用来查看和备份二进制日志文件，使用示例如下：

> mysqlbinlog mysql-bin.000001 > backup_file.sql

##### 2、使用 xtrabackup 工具

Xtrabackup 是由 Percona 团队免费开源的一款 MySQL 备份工具，支持在线热备份，不锁表，备份速度快，占用磁盘空间小，是目前普遍使用的 MySQL 备份工具。

## 158、MySQL 单表的最大记录数是多少？

MySQL 存储架构并没有对单表最大记录数进行限制，这个数值取决于操作系统对单个文件的限制。

## 159、什么是表分区？

表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。

从逻辑上看，分区只有一张表，但是底层却是有多个物理分区组成。

## 160、表分区有什么好处？

（1）存储更多数据；

（2）优化查询性能；

（3）更容易维护；

（4）避免表扩展瓶颈；

等等。。

## 161、表分区与分表的区别？

**分表**：指的是通过一定规则，将一张表分解成多张不同的表，比如将用户订单记录根据时间成多个表。

**分表与分区的区别在于**：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。

## 162、MySQL 支持的分区类型有哪些？

##### （1）RANGE 分区

这种模式允许将数据划分不同范围。

例如可以将一个表通过年份划分成若干个分区。

##### （2）LIST 分区

这种模式允许系统通过预定义的列表的值来对数据进行分割。

按照 List 中的值分区，与 RANGE 的区别是 RANGE 分区的区间范围值是连续的。

##### （3）HASH 分区

这种模式允许通过对表的一个或多个列的 HashKey 进行计算，最后通过这个 Hash 码不同数值对应的数据区域进行分区。

例如可以建立一个对表主键进行分区的表。

##### （4）KEY 分区

是 Hash 模式的一种延伸，这里的 Hash Key 是 MySQL 产生的。

## 163、MySQL 分区表有哪些限制因素？

1、一个表最多只能有 1024 个分区。

2、MySQL5.1 中，分区表达式必须是整数，或者返回整数的表达式，在 MySQL5.5 中提供了非整数表达式分区的支持。

3、如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。

4、分区表中无法使用外键约束

5、MySQL 的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。

## 164、MySQL 批量插入，如何不插入重复数据？

##### 1、insert ignore into

插入数据出现错误时（如重复数据），将不返回错误，而是返回警告，所以要注意 SQL 本身语法问题。

![](/images/MySQL/164_1.jpg)

##### 2、on dplicate key update

当主键或者唯一约束重复时执行 update 语句，否则执行 insert 语句。

![](/images/MySQL/164_2.jpg)

##### 3、insert ... select ... where not exist

根据 select 条件判断是否插入，如：

![](/images/MySQL/164_3.jpg)

##### 4、replace into

如果存在主键或者唯一约束相同的记录，则先删除再插入新记录。

## 165、MySQL 中为什么不建议使用 UTF-8？

因为 MySQL 中的“UTF-8”实际上不是真正的 UTF-8。

MySQL 中的“**utf8mb4**”才是真正意义上的“UTF-8”，所以永远不要再使用“UTF-8”。

## 166、MySQL 为什么不建议用 UUID 做主键？

##### 主要有以下几点原因：

（1）MySQL InnoDB 使用的是 B+树索引，所以数据必须是有序的，如果无序就会导致 page（页）产生分裂、合并操作，这样就会大大影响数据插入的性能，这是主要原因；

（2）UUID 一般为 36 位字符串，比数字要长很多，占用空间比较大，从而下降数据库 IO 性能；

（3）UUID 不像数字那样有序，不是顺序增长，就会导致 B+树索引在写的时候有过多的随机写操作，随机 IO 很严重；

## 167、MySQL 提高并发可以调整哪些参数？

##### max_connections

最大连接数量，默认为 151；

##### back_log

积压请求栈的大小，默认为 151；

##### table_open_cache

打开表缓存的数量，默认为 4000；

##### thread_cache_size

数据库端连接池的大小，默认为 9；

##### innodb_lock_wait_timeout

行锁的等待超时时间，默认为 50s；

> 版本：8.0.22

## 168、MySQL 日期 NOW 和 SYSDATE 的区别？

NOW()在语句执行时就确定好了，不会改变，而 SYSDATE 是实时获取的。

![](/images/MySQL/168.jpg)

如图，等待 3 秒后，SYSDATE 值大了 3 秒，而 NOW 值没有变化。

## 169、MySQL 怎么查看当前数据库版本？

![](/images/MySQL/169.jpg)

## 170、MySQL 常用的客户端有哪些？

##### 常用的主流的有以下几款：

1、MySQL WorkBench（官方）

2、Navicat

3、DBeaver

4、SQLyog

5、Toad

6、DataGrip

个人觉得用的最多的，最好用的还是 Navicat

## 171、MySQL 回表是什么？怎么避免？

回表是数据库查询操作中的一个概念，它是指在使用「**非主键索引（非聚簇索引）**」查询时，需要「**二次查询**」才能得到结果：

1、先通过**非主键索引**查询出数据所在的行。

2、再通过主键 ID 查询出所有需要的数据。

> ##### 为什么非主键索引（非聚簇索引）需要回表？
>
> 因为**主键索引（聚簇索引）的叶子结点存储的是索引和数据**，所以只要一次索引就能得到目标数据。
>
> 而**非主键索引（非聚簇索引）的叶子节点存储的是索引值和主键**，所以没办法一次查询索引就能得到目标数据，需要二次查询，这就是回表。

回表操作会导致数据库的查询性能下降，因为它需要进行额外的索引查找操作，所以为了避免回表，MySQL 中可以使用**索引覆盖**和**索引下推**来进行优化。

## 172、MySQL 索引覆盖是什么？

索引覆盖是一种数据库查询优化技术，**它是指一个查询可以完全通过使用索引来获取所需数据，而无需再去查询数据表的实际数据行。**

也就是说，**所有需要的数据都被包含在索引中**，因此可以避免查询数据表本身，因为索引一般要比数据表小，所以查询索引要比查询数据表要更快，这样就可以减少磁盘 I/O 操作，从而大大提高查询性能。

如果一个索引包含了需要查询的所有字段，那么这个索引就是覆盖索引。

举个例子：

> 假设我们有一个 user 表，表中有 id、name、phone、email 四个字段，**对 id 字段建立了主键索引 l，并对其他三个字段建立了联合索引。**

查询 SQL 语句如下：

```sql
select name, phone, email from user here name = "shelly";
```

因为我们把 name,phone,email 字段建立了联合索引 l，**一个索引覆盖了要查询的所有字段**，那么数据库可以仅通过查找索引就得到结果，而无需再去访问数据表的实际数据行，这样就避免了回表，这就是索引覆盖。

> 索引覆盖默认是开启的，并没有开关可以进行手动控制，而是基于查询语句和索引设计自动工作的。

## 173、MySQL 索引下推是什么？

索引下推是 MySQL5.6 版本引 I 入的一种查询优化技术，其核心思想是**将 WHERE 子句中的与索引相关的条件直接下推到存储引擎的索引扫描操作中**，从而减少不必要的数据行检索，提高查询效率。

举个例子：

> 假设我们有一个 user 表，表中有 id、name、age 三个字段，对 id 字段建立了主键索引 l，name 和 age 建立了联合索引。

查询 SQL 语句如下：

```sql
elect * from user where name like '周%' and age = 20;
```

对于联合索引 l，因为查询条件中有范围查询（like），所以 name 右边所有列都无法命中索引了，所以以上 SQL 只命中了 name 索引，age 索引无法命中，此时「索引下推」就能派上用场了。

在没有「**索引下推**」的情况下：

- 根据 name 在索引上找到满足条件的所有 id；
- 后用 id 根据主键索引找到匹配的所有数据行，**如果有大量数据姓周，那就会产生大量回表操作**；
- 后在 MySQL Sever 层根据 age=20 条件进行过滤，**如果有大量数据姓周，也会影响 Server 层性能**。

如果有了「**索引下推**」，**数据过滤就不需要上推到 Server 层处理了，而是由存储引擎通过使用索引来完成**。

因为建立了 name 和 age 朕合索引 l，MysQL 在扫描索引 l 的过程中，就可以直接判断 age 字段是否等于 20 并得到具体 id，这样就大大减少了不必要的数据行访问和筛选，也减少了回表次数，从而大大提高了查询效率。

> ##### 索引下推默认是开启的，可以通过命令手动开关：
>
> set optimizer_switch='index_condition_pushdown=off';
>
> set optimizer_switch='index_condition_pushdown=on';

##### 总结—下：

1、索引下推的前提必须是联合索引。

2、查询语句只使用了满足「最左匹配原则」 的部分字段。

3、索引下推可以看做是满足「最左匹配原则」但未充分使用联合索引的优化补充。
