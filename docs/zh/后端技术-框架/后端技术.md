## 1、你怎么理解对象池？

对象池是一种系统优化技术，将频繁使用到的对象放到一个池中（比如说放到数组、集合中），避免反复创建影响系统性能。

##### 常见的对象池有：

- 数据库连接池
- 线程池

## 2、什么是连接池？

连接池维护一个数据库连接的集合，当系统需要访问数据库时，不需要额外创建连接，只需要从连接池中获取连接使用即可，使用完之后再归回给连接池。

## 3、为什么要使用连接池？

连接池是一种性能优化技术，因为数据库连接的创建和销毁都是十分消耗系统资源的，如果不使用连接池频繁进行连接的创建和销毁操作，势必给系统带来性能影响。

## 4、常用的连接池技术有哪些？

##### 常用的连接池技术有：

- Druid (阿里开源)
- HikariCP
- DBCPProxool
- C3P0

后面两个用的比较少了。

## 5、连接池常用的参数有哪些？

常用的参数拿 Druid 连接池举例：

- name
- url
- username
- password
- driverClassName
- initialSize
- maxActive
- maxldle
- minldle
- maxWait
- testOnBorrow
- testOnReturn
- testWhileldle
- ....

这些常用的参数要说的出来。

## 6、连接池如何避免获取到已失效的连接？

一般的连接池都会有类似`testOnBorrow`的参数，即在申请连接时，检测连接是否有效，但这个配置会降低系统性能。

如在 Druid 连接池中：

| testOnBorrow  | true  | 申请连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能。                                                                                |
| ------------- | ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| testOnReturn  | false | 归还连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能。                                                                                |
| testWhileldle | false | 建议配置为 true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行 validationQuery 检测连接是否有效。 |

Druid 建议打开`testWhileIdle`参数，不影响系统性能，还能保证安全性。

## 7、常用的本地缓存框架有哪些？

常用的有以下三种：

- Guava Cache
- Ehcache
- **Caffeine(推荐，Spring 5+默认支持)**

## 8、常用的日志门面都有哪些？

##### 常用的日志门面有：

- SLF4J（简单日志门面：Simple Logging Facade For Java）
- Apache Commons-Logging

建议使用 SLF4J，目前主流日志门面，能很方便切换到其他主流日志框架。

## 9、常用的日志框架都有哪些？

##### 常用的日志框架有：

- Apache Log4j 1.x (已停止维护)
- **Apache Log4j 2.x**
- **Logback**
- JUL (即: java.utillogging，JDK 1.4+ 自带)
- System Logger (JDK 1.9+ 自带)

目前用的最多的是**Log4j2.x（性能最好）**和**Logback（SpringBoot 默认日志框架）**。

## 10、SLF4J, Logback, Log4j 有什么区别和联系？

SLF4J 是日志门面，是一种日志接口规范，Logback 和 Log4j,Log4j2 是具体的日志实现框架。

Logback 是 SLF4J 原生实现，Log4j2 则不是，所以，如果需要 SLF4」+Log4j2 一起用，则需要一个桥接包。

##### SLF4J+Log4j2 需要的包：

- slf4j-api
- log4j-api
- log4j-core
- log4j-slf4j-impl(桥接包)

---

如果是 Logback，因为是原生 SLF4J 实现，则不需要桥接包。

##### SLF4J+logback 需要的包：

- slf4j-api
- logback-core
- logback-classic(集成包)

## 11、可以直接使用 Log4j 中的 API 吗？为什么？

##### 不可以，不建议，需要用到日志门面

如阿里 Java 开发手册中的日志定义：

![](/images/后端技术/11.jpg)

面对接口编程，方便日后想换其他日志框架。

## 12、日志输出都有哪些规范？

##### 定义日志变量

```java
 protected Logger logger = LoggerFactory.getlogger(this.getclass());
```

日志变量类型定义为门面接口（如 slf4j 的 Logger），实现类可以是 Log4j、Logback 等实现框架，不要把实现类定义为变量类型，否则日志切换不方便，也不符合抽象编程思想。

##### 使用参数化形式

```java
logger.debug("save order with order no: [{}], and order amount: [{}]");
```

这种可读性好，而且只有真正准备打印的时候才会处理参数。

如果日志框架不支持参数化形式，且日志输出时不支持该日志级别时会导致对象冗余创建，浪费内存，此时需要使用 isXXEnabled 判断，如：

```java
if(logger.isDebugEnabled()){
    logger.debug("Save order with order no: " + orderNo + ", and order amount: " + orderAmount);
}
```

至少 DEBUG 级别是需要开启判断的，线上日志级别至少应该是 INFO 以上的。

##### 使用`[]`进行参数隔离

```java
logger.debug("save order with order no: [{}], and order amount: [{}]");
```

这样一看就知道[]里面是输出的动态参数，方便定位问题。

##### 输出不同级别的日志

项目中最常用有日志级别是`ERROR`、`WARN`、`INFO`、`DEBUG`四种了。

##### ERROR

程序中发生的任何异常都用 ERROR 级别记录，并记录完整堆栈信息，如捕获异常后又抛出了自定义业务异常，此时无需记录错误日志，由最终捕获方进行异常处理。

```java
logerg·error("获取合同[{}]信息时出错"，contractNo，ex);
```

其他日志级别这里不再赘述，总之就是要合理使用日志级别，能帮助我们分析定位线上问题。

不要滥用日志级别，我曾经看过同事使用 info 来打印 error 日志，结果线上死活看不到错误信息。

## 13、你怎么理解日志级别？

日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。

日志优先级别标准顺序为：

> ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF

如果日志设置为 L，一个级别为 P 的输出日志只有当 P >=L 时日志才会输出。

即如果日志级别 L 设置 INFO，只有 P 的输出级别为 INFO、WARN，后面的日志才会正常输出。

具体的输出关系可以参考下图：

![](/images/后端技术/13.jpg)

## 14、常用的日志级别有哪些？

下面拿最普遍用的 Log4j 日志框架来做个日志级别的说明，其他大同小异。

LOg4j 的级别类`org apache.log4j.Level`里面定义了日志级别，日志输出优先级由高到底分别为以下 8 种:

| 日志级别 | 描述                                                                                                                                           |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| OFF      | 最高级别，关闭所有日志输出。                                                                                                                   |
| FATAL    | 致命日志，用于记录非常严重的错误，可能导致系统无法继续运行。                                                                                   |
| ERROR    | 错误日志，用于记录错误事件，这些错误可能不会影响到系统运行。                                                                                   |
| WARN     | 警告日志，用于记录可能会有害的情况，但不一定会导致系统错误。例如，磁盘空间快要满或者数据库连接数过多等，这些情况可能导致在不远的将来发生错误。 |
| INFO     | 信息日志，常用的日志级别，记录关键运行信息以了解系统运行状况。                                                                                 |
| DEBUG    | 调试日志，常用于开发调试。                                                                                                                     |
| TRACE    | 追踪日志，一般用于跟踪代码的执行流程，比 DEBUG 更详细。                                                                                        |
| ALL      | 最低级别，启动所有日志记录。                                                                                                                   |

低级别的日志会包含比它级别高的所有日志信息，比如，如果设置日志级别为 DEBUG，那么 INFO、WARN 及以上级别的日志信息也会输出出来。

## 15、常用的 JSON 框架有哪些？

下面是国内常用的几大 JSON 框架：

| 特点             | Jackson                  | Gson                     | Fastjson                 |
| ---------------- | ------------------------ | ------------------------ | ------------------------ |
| 性能             | 高                       | 一般                     | 高                       |
| 功能丰富度       | 高                       | 中                       | 高                       |
| 使用难度         | 中                       | 低                       | 低                       |
| 可定制性         | 高                       | 中                       | 高                       |
| 注解支持         | 完善                     | 有限                     | 有限                     |
| 处理复杂数据类型 | 强大支持                 | 有限                     | 强大支持                 |
| 社区支持         | 非常活跃                 | 活跃                     | 活跃                     |
| 平台兼容性       | 跨平台(Java、Android 等) | 跨平台(Java、Android 等) | 跨平台(Java、Android 等) |

大家可以根据项目的具体需求和优先级来选择最适合的 JSON 框架，一般在项目中可以结合使用。

## 16、为什么都不推荐使用 Fastjson？

Fastjson 是一个功能强大、性能优异的 JSON 框架，但是，近年来 Fastjson 在安全性方面屡屡暴露漏洞，因此国内很多公司不推荐使用 Fastjson。

以下是 Fastjson 出现过的几个漏洞：

| 漏洞             | 描述                                                                                                                                  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 反序列化漏洞     | Fastjson 曾经存在反序列化漏洞，攻击者可以利用这些漏洞执行恶意代码。尽管开发团队已经修复了许多漏洞，但在旧版本中仍然可能存在安全问题。 |
| 默认反序列化配置 | Fastjson 的默认反序列化配置相对宽松，可能会导致一些安全风险，例如允许非法访问私有字段或执行不受信任的代码。                           |
| JSONP 攻击       | Fastjson 在某些情况下可能受到 JSONP（JSON with Padding）攻击，攻击者可以利用此漏洞执行跨域脚本攻击。                                  |

Fastjson 漏洞太多了，早不是什么新鲜事了，来看最新的版本发布都还在修复漏洞：

![](/images/后端技术/16.jpg)

所以，如果你的项目非常重要，需要评估使用 Fastjson 的风险。

## 17、什么是 JWT？

JWT 全称：JSON Web Token，是一种开放标准(RFC 7519)，它定义了一种紧凑独立的基于 JSON 对象在各方之间安全地传输信息的方式。这些信息可以被验证和信任，因为它是数字签名的。

让我们进一步解释这个定义的一些概念。

- 紧凑

由于其较小的体积，JWT 可以通过 URL、POST 参数或 HTTP 头部参数进行传递，体积小也意味着其传输速度会相当快。

- 独立

有效负载包含了所需要的关于用户的所有信息，避免了多次查询数据库的需要。

##### JWT 由以下三部分组成：

1. Header (头部)
2. Payload (载荷)

因此，JWT 通常看起来如下：

> xxxxx.yyyyy.zzzzz

##### JWT 的优点：

- 因为 JSON 数据格式的通用性，所以 JWT 是可以跨语言的，主流语言都可以支持。
- payload 部分可以存储其他业务逻辑所必要的非敏感信息。
- JWT 构成简单，字节占用很小，所以非常便于传输的。
- 不需要在服务端保存会话信息，易于应用的扩展和安全等。

##### JWT 的使用注意：

1、不要在 payload 存放敏感信息，因为该部分是可解密的。

2、保存好 secret 私钥十分重要。

3、尽量使用 https 协议

## 18、JWT 的应用场景有哪些？

##### JWT 的应用场景：

- ##### 认证

这是使用 W/T 最常见的场景，一旦用户登录后，每个后续的请求都会包含 JVT token，允许用户访问该 token 所允许的路由、服务、资源等。

如单点登录是目前广泛使用 WT 的一项功能，因为它的开销很小，而且在不同的域名中很容易使用。

- ##### 信息交换

JWT 是一种在多方之间传递数据比较好的方式，因为 JWT 能使用签名，能确保发送者是谁，也可以验证传递过来的的信息是否被篡改。

## 19、OAuth2 是什么？

OAuth 2.0 是一个用于授权的行业标准协议，它是一种协议，而不是指具体的框架。

## 20、为什么需要 OAuth2？用户密码不行吗？

举一个例子：

微信管理了上亿用户，别的公司如果需要通过微信来登录应用，就需要获取微信用户的信息，腾讯不可能把微信内部系统用户名、密码告诉第三方吧？更不可能把数据库提供出去吧？

那怎么让第三方授权访问公司内部资源呢？

不管是用户密码、还是使用 key，都不太好管理，安全性都不高，这时候就需要通过 OAuth2 协议进行资源授权，通过 OAuth2 进行统一管理、颁发、吊销令牌。

## 21、Auth2 的应用场景有哪些？

##### 典型的应用场景有：

##### 1、开放系统之间的授权

最典型的就是社交平台登录，比如：微博、淘宝等 APP 通过微信登录：

![](/images/后端技术/21.jpg)

##### 该模式整体流程为：

1）第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数；

2）通过 code 参数加上 ApplD 和 AppSecret 等，通过 API 换取 access_token；

3）通过 access_token 进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。

2、**微服务安全认证**

3、**企业系统单点登录**

## 22、OAuth2 有哪几种授权模式？

OAuth2 定义了 4 种授权模式：

##### 1、授权码模式(authorizationcode)

它是功能最完整、流程最严密、使用最广泛的的授权模式。

##### 2、隐式授权模式(implicit)

##### 3、密码模式(resource owner password credentials)

##### 4、客户端模式(client credentials)

## 23、OAuth2 的运行流程介绍一下？

##### 用的最多的授权码模式流程图：

![](/images/后端技术/23.jpg)

##### 流程说明：

1、客户端请求用户给予授权；

2、用户同意给予客户端授权，并返回授权码；

3、客户端通过授权码再向认证服务器申请令牌；

4、认证服务器对客户端进行认证并返回令牌；

5、客户端使用令牌向资源服务器获取资源；

6、资源服务器验证令牌，并返回资源；

## 24、OAuth2 使用什么框架比较好？

之前一般都使用 Spring 家族的 Spring Security OAuth 开源项目，但是在 2019 年不再支持授权服务了：

![](/images/后端技术/24.jpg)

现在 Spring Security OAuth 项目也不维护了，把将相关功能集成到了 Spring Security，并且，**SpringAuthorization Server** 项目在 2021/08/17 正式上线，所以现在可以通过 **Spring Security +SpringAuthorization Server** 实现 OAuth2 认证。

## 25、OAuth2 和 JWT 的区别？

OAuth2 和 JWT 是两个不同的安全协议，两者作用的场景不同。

JWT 的加密 token 包含三段：

![](/images/后端技术/25.jpg)

所以，JWT 不仅可以用作安全认证、单点登录，Data 域还可以用来传输数据，比如前后端分离没有 Session 的场合，可以通过 JWT 生成 token 来实现接口安全认证。

而 OAuth2 中的 token 不包含任何数据，仅用作认证授权，一般在第三方的资源访问授权用的比较多，当然 JWT 也能实现，但 OAuth2 在这方面是更标准和广泛使用的。

## 26、什么是单元测试？

单元测试：UT（Unit Test）是指对软件中的最小单元进行测试和验证其正确性，最小单元可以是：某个接口、方法。

## 27、为什么要做单元测试？

因为把每个单元的测试做的够细，所以做单元测试的好处有：

1）减少线上出故障的概率；

2）提高和优化代码质量；

3）提高开发和联调效率；

4）提高系统的稳定性和可靠性；

5）一次编写，可以用到后续反复验证；

....

## 28、什么是 Mock 测试？

mock 中文就是**“模拟”、“仿真”**的意思，放到单元测试里面也是一样，可以模拟任何你不方便测试的接口、类、方法等。

比如你开发了一个需要和第三方接口联调的功能，但对方还没有开发好，你总不能等它开发好你再测试吧？

所以 Mock 测试的好处就是，可以通过创建一个模拟的 Mock 对象来代替真实的对象，所有调用这个第三方的接口就返回 Mock 模拟对象，这样就可以避开第三方的依赖而继续完成自己模块的测试。

## 29、单元测试常用的框架有哪些？

主要用到 JUnit 单元测试，一般要结合 Mock 框架进行测试，比如：Mockito、PowerMock、JMock、TestableMock 等。

> Mock + Mockito 用的比较多！

## 30、为什么很多开发不愿意做单元测试？

主要是要花不少时间！！！

写单元测试用例，写单元测试代码，进行各种测试，确实是要花不少时间，平时开发任务就催的要命，时间很紧的情况，开发人员自然不愿意写。

## 31、怎么保护项目中的敏感配置？

有以下几种方案：

1）第三方配置中心，可支持自动加解密那种；

2）自已实现加解密机制，配置可存储项目或者数据库；

3）Spring Boot 可以使用 Jasypt Spring Boot 开源项目，开源地址：

> https://github.com/ulisesbocchio/jasypt-spring-boot
