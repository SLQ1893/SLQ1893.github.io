## 1、编程实现删除 HashMap 集合中的元素

##### 假设有以下数据：

```java
public Map<string, String> initMap = new HashMap<>() {{
    put("user1", "张三");
    put("user2"，"李四");
    put("user3", "张三");
    put("user4", "李四");
    put("user5","王五");
    put("user6", "赵六");
    put("user7"，"李四");
    put("user8", "王五");
}};
```

> 一般删除 HashMap 集合中的元素，如果知道具体的 Key，并且需要根据 Key 删除元素，使用 remove 方法就可以了。
>
> ##### 但是如何根据 Value 删除 HashMap 集合中的元素呢？这才是你必须掌握的技巧！

##### 1、使用 for 循环删除

```java
/**
* 使用for循环删除
*/
@Test
public void remove1() {
    Set<Map.Entry<String, String>> entries = new CopyonwriteArrayset<>(initMap.entryset());
    for (Map.Entry<string, String> entry : entries) {
        if ("张三".equals(entry.getvalue())) {
            initMap.remove(entry.getKey());
        }
    }
    System.out.println(initMap);
}
```

输出结果：

> {user2=李四,user7=李四,user8=王五,user5=王五,user6=赵六,user4=李四}

使用 HashMap 中实现的 entrySet 方法获取元素的集合，然后再进行循环遍历，先根据 Value 值判断要删除的元素，然后再根据 Key 删除元素。增强的 for 循环底层使用的选代器 Iterator，而 HashMap 是 fail-fast 类型的错误机制， 所以遍历时删除元素会出现`java.util.ConcurrentModificationException`并发修改异常。

所以，这里使用了线程安全的 CopyOnWriteArraySet 封装了一层，避免出现并发修改异常，java.util.concurrent 包中的并发集合类都被设计为 fail-safe（安全失败）类型的，比如 CopyOnWrite\*、ConcerrentHashMap 集合，遍历过程中结构发生变更是安全的，不会抛出以上异常。

> ##### 需要注意的是：
>
> 虽然 CopyOnWriteArraySet 并发性能很好，但每次删除时都会复制一份同等集合，所以要考虑数据过多可能导致的内存消耗问题。

##### 2、使用 forEach 循环删除

```java
/**
* 使用forEach循环删除
*/
@Test
public void remove2() {
    ConcurrentHashMap<string, String> map = new ConcurrentHashMap<>(initMap);
    map.forEach((k, v) -> {
        if ("张三".equals(v)) {
            map.remove(k);
        }
    });
    System.out.println(map);
}
```

输出结果：

> {user2=李四,user7=李四,user8=王五,user5=王五,user6=赵六,user4=李四}

使用 HashMap 自带的 forEach 循环删除指定值的元素，这里为什么使用线程安全的 ConcurrentHashMap 集合包装了一层，同样是为了避免并发修改异常。ConcurrentHashMap 在各版本中都使用了最优的锁设计方案，它的并发性能也是非常优异的。

##### 3、使用 Iterator 选代器删除

```java
/**
* 使用 Iterator 选代器删除
*/
@Test
public void remove3() {
    Iterator<Map.Entry<String, String>> iterator = initMap.entryset().iterator();
    while (iterator.hasNext()) {
        Map.Entry<string, String> entry = iterator.next();
        if （"张三".equals(entry.getvalue()) {
            iterator.remove();
        }
    }
    System.out.printin(initMap);
}
```

输出结果：

> {user2=李四, user7=李四,user8=王五, user5=王五, user6=赵六, user4=李四}

这种方式即正常使用迭代器遍历删除，它不会发生并发修改异常。

> ##### 需要注意的是：
>
> 这种方法虽然不会发生并发修改异常，但 HashMap 并不是线程安全的，在迭代删除元素时，另一个线程可能会删除 HashMap 中的数据，这时使用迭代器删除同样会导致并发修改异常。
>
> 所以，要保证线程安全的删除，在创建选代器之前，可以先用线程安全的 ConcurrentHashMap 集合包装一层。或者使用 synchronized 关键字锁住整个 Map。
>
> 如果没有多线程修改环境，可以不用考虑。

##### 4、使用 removelf 删除

```java
/**
* 使用 removeIf 删除
*/
@Test
public void remove4() {
    initMap.entryset().removeIf(entry"张三".equals(entry.getvalue()));
    System.out.printin(initMap);
}
```

输出结果：

> {user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}

使用 entrySet 的 removelf 删除，它底层使用的是迭代器：

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

所以，它和方法 3 是一样的，只不过把条件写成了 Predicate 函数式接口而已。

> 需要注意的是：
>
> removelf 虽然更方便了，但它仍然不是线程安全的，多线程场景参考方案同方法 3。

##### 5、使用 Stream 删除

```java
/**
* 使用 stream 删除
*/
@Test
public void removes() {
    Map<String, String> map = initMap.entryset().stream().filter(entry -> !"张三".equals(entry.getvalue()))
        .collect(collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    System.out.println(map);
}
```

输出结果：

> {user2=李四,user7=李四, user8=王五,user5=王五, user6=赵六, user4=李四}

利用 Stream 的 filter 方法进行过滤，这个方法也十分简单，一行代码搞定。

##### 实际开发过程中，可能会使用不同的遍历方式，所以重点要考虑多线程场景，如果只是简单的删除元素，使用 removelf 和 Stream 过滤是最省事的。

## 2、编程实现删除 List 集合中的元素

用 Java 编程，删除 list 中包含"a"的元素：

```java
List<string> list1 = new Arraylist<>();
list1.add("tom");
list1.add("john");
list1.add("david");
listl.add("james");
list1.add("lily");
list1.add("san");
```

下面我提供两种常见的删除方法：

```java
public static void main(string[] args) throws Exception {
    List<string> list1 = new Arraylist<>();
    list1.add("tom");
    list1.add("john");
    list1.add("david");
    list1.add("james");
    list1.add("lily");
    list1.add("san");
    System.out.println(list1);

    //使用 Iterator 遍历删除
    List<string> list2 = new Arraylist<>(list1);
    for (Iterator<string> ite = list2.iterator(); ite.hasNext(); ) {
        String str = ite.next();
        if (str.contains("a")) {
            ite.remove();
        }
    }
    System.out.printin(list2);

    //使用 stream快速筛选功能
    List<string> list3 = new Arraylist<>(list1);
    list3 = list3.stream().filter(e -> le.contains("a")).tolist();
    System.out.println(list3);
}
```

输出结果：

> [tom, john, david, james, lily, san]
>
> [tom, john, lily]
>
> [tom, john, lily]

## 3、编程实现删除 List 集合中的重复元素

假设有以下数据：

```java
 public List<string> initList = Arrays.aslist(
 "张三",
 "李四",
 "张三",
 "周一",
 "刘四",
 "李强",
 "李白",
 "张三",
 "李强",
 "王五"
 );
```

> 去除 `List<String>`中的重复元素。

##### List 去重方案

---

##### 1、for 循环添加去重

```java
/**
* for环添加去重
*/
@Test
public void removel() {
    List<string> list = new ArrayList(initList);
    List<string> list2 = new Arraylist<>();
    for (string element : list) {
        if (!list2.contains(element)) {
            list2.add(element);
        }
    }
    System.out.println(list2);
}
```

这个是最基本的实现了，创建一个空的 List，添加前判断一下存在不存在，不存在才添加，这样就保证了元素不重复。

输出结果：

> [张三,李四, 周一, 刘四,李强, 李白,王五]

##### 2、for 双循环去重

```java
/**
* for 双循环去重
*/
@Test
public void remove2() {
    list<string> list = new Arraylist(initlist);
    for (int i = 0; i < list.size() - 1; i++) {
        for (int j = list.size() - 1; j > i; j--) {
            if (list.get(j).equals(list.get(i))) {
                list.remove(j);
            }
        }
    }
    System.out.println(list);
}
```

利用双循环，判断是否有相等的，再进行移除。

输出结果：

> [张三,李四, 周一, 刘四, 李强,李白,王五]

##### 3、for 循环重复坐标去重

```java
/**
* for循环重复坐标去重
*/
@Test
public void remove3() {
    List<string> list = new Arraylist(initlist);
    list<string> list2 = new Arraylist(initlist);
    for (string element : list2) {
        if (list.indexof(element) l= list.lastindexof(element)) {
            list.remove(list.lastIndexof(element));
        }
    }
    System.out.println(list);
}
```

这种方式很新颖吧？

复制一个 list2，再循环 List2，判断 list 中的元素的首尾出现的坐标位置是否一致，如果一致，则说明没有重复的，否则重复，再删除重复的位置的元素。

输出结果：

> [张三,李四,周一,刘四,李强,李白,王五]

##### 4、Set 去重

```java
/**
* * set 去重
*/
@Test
public void remove4() {
    List<String> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist(new Hashset(list));
    System.out.println(list2);
}
```

这招也太简单了吧，一行代码搞定！

我们知道 Set 是不包含重复元素的，把 List 先装进 HashSet，然后再装回来，这样就保证了元素的不重复。

输出结果：

> [李强,李四,张三, 周一, 李白, 王五, 刘四]

结果虽然正确，但元素顺序和原始 List 不一致，如果要保证顺序性，可以把 HashSet 换成 LinkedHashSet：

```java
/**
* set 去重
*/
@Test
public void remove4() {
    List<string> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist(new LinkedHashset(list));
    System.out.println(list2);
}
```

输出结果：

> [张三,李四, 周一, 刘四,李强, 李白,王五]

这下顺序对了吧，LinkedHashSet 可以保证元素的顺序性！

##### 5、Stream 去重

```java
/**
* stream 去重
*/
@Test
public void remove5() {
    List<string> list = new Arraylist(initlist);
    list = list.stream().distinct().collect(collectors.tolist());
  System.out.println(list);
}
```

利用 Stream 的 distinct 方法去重，这个方法也十分简单，一行代码搞定！

## 4、编程实现对 List 集合中的元素进行排序

##### 传统排序

---

现在有一个 List 集合：

```java
public static List<User> LIST = new ArrayList() {
    {
        add(new User("Lisa", 23));
        add(new User("Tom", 11));
        add(new User("John", 16));
        add(new User("Jessie", 26));
        add(new User("Tony", 26));
        add(new User("Messy", 26));
        add(new User("Bob", 19));
        add(new User("Yoga", 65));
    }
}
```

jdk8 之前的排序：

```java
/**
* jdk8之前的排序
*/
private static void sortPreJdk8() {
    System.out.println("===-=jdk8 之前的排序==---");
    List<User> list = new ArrayList<>(LIST);

    Collections.sort(list, new Comparator<User>() {
        @Override
        public int compare(User u1, User u2) {
            return u1.getAge().compareTo(u2.getAge());
        }
    });

    for (User user : list) {
        System.out.println(user);
    }
    System.out.println();
}
```

在 Java 8 出来之前，排序基本上要这么写，可是 Java 8 都出来这么多年了，你还在这么排序那就太 Low 了！

##### Java8 中的排序

---

本篇就直接上干货，看我怎么用 Java 8 排序！

```java
@NoArgsConstructor
@AllArgsConstructor
@Data
static class User {
    private static final User USER = new User();
    private String name;
    private Integer age;

    public static int compareAge(User u1, User u2) {
        return u1.getAge().compareTo(u2.getAge());
    }

    public static User getInstance() {
        return USER;
    }

    public int compare(User u1, User u2) {
        return u1.getAge().compareTo(u2.getAge());
    }

    @Override
    public String tostring() {
        return age + ": " + name;
    }
}
```

##### 1、Lambda 排序 (带参数类型)

Java 8 中的 List 接口新增了一个 sort 默认方法：

![](/images/编程题/4_1.jpg)

接收 Comparator 接口参数，这个接口在 Java 8 中被修饰为函数式接口：

![](/images/编程题/4_2.jpg)

然后我们就可以把 Comparator 接口参数改成了用 Lambda 表达式的形式，用 Lambda 表达式干掉了匿名内部类，让代码更简洁。

使用示例如下：

```java
/**
* jdk8 Lambda 排序，带参数类型
*/
private static void sortWithJdk8lambda1() {
    System.out.println("==--jdk8 lambda 排序，带参数类型=====");
    List<User> list = new ArrayList<>(LIST);

    list.sort((User u1, User u2) -> u1.getAge().compareTo(u2.getAge()));

    list.forEach(System.out::println);
    System.out.println();
}
```

##### 2、Lambda 排序(不带参数类型)

Lambda 表达式是可以不用带参数类型的，如下示例：

```java
/**
* jdk8Lambda 排序，不带参数类型
*/
private static void sortWithJdk8Lambda2() {
    System.out.println("===-=jdk8 lambda 排序，不带参数类型=====");
    List<User> list = new ArrayList<>(LIST);

    list.sort((u1, u2) -> u1.getAge().compareTo(u2.getAge()));

    list.forEach(System.out: :println);
    System.out.println();
}
```

代码中的 u1,u2 并没有用 User 类修饰，它会自动推断为 User 类型，因为集合本身就是一个 User 泛型。

##### 3、静态方法引用排序

除了 Lambda 表达式，还可以用类的静态方法引用：

```java
/**
* jdk8静态方法引/用排序
*/
private static void sortWithJdk8staticMethodRef(）{
    System.out.println("=----jdk8 静态方法引|用排序=====");
    List<User> list = new ArrayList<>(LIST);

    list.sort(User::compareAge);

    list.forEach(System.out::println);
    System.out.println();
}
```

使用方法引用之后代码是不是更简洁了？

##### 4、实例方法引用排序

不仅可以用类的静态方法，还可以用类的实例普通方法引用：

```java
/**
* jdk8实例方法引l用排序
*/
private static void sortWithJdk8InstanceMethodRef() {
    System.out.println("=====jdk8 实例方法引|用排序=====");
    List<User> list = new ArrayList<>(LIST);

    list.sort(User.getInstance()::compare);

    list.forEach(System.out::println);
    System.out.println();
}
```

这个 getlnstance 在这里实际上是一个单例，但和单例无关，任何类的实例都可以。

##### 5、Comparator 工具类排序 (升序)

Java 8 在 Comparator 接口中新增了 comparing 方法：

![](./image/编程题/4_3.jpg)

这个工具方法需要提供一个函数式接口参数，也就是要比较的哪个字段，最后还是返回 Comparator 接口实例。

使用示例如下：

```java
/**
* jdk8 升序排序，Comparator 提供的静态方法
*/
private static void sortWithJdk8comparatorAsc(）{
    System.out.println("==-=jdk8 升序排序===-=");
    List<User> list = new ArrayList<>(LIST);

    list.sort(Comparator.comparing(User::getAge));

    list.forEach(System.out::println);
    System.out.println();
}
```

既然是函数式接口，所以又可以用 Lambda、方法引用形式作为参数传入。

##### 6、Comparator 工具类排序（降序）

还可以使用 Comparator.reversed/ reversedOrder 方法进行降序：

```java
/**
* jdk8 Comparator 工具类排序（降序)
*/
private static void sortwithJdk8comparatorDesc(）{
    System.out.println("---jdk8 降序降序=====");
    List<User> list = new ArrayList<>(LIST);

    list.sort(Comparator.comparing(User: :getAge) .reversed());

    list.forEach(System.out::println);
    System.out.println();
}
```

Comparator.reversed 和 reversedOrder 的区别在于，reversedOrder 适用于基本数据类型的集合的自然排序，而 reversed 是对 Comparator 自身的封装，适用于对象的自定义排序。

##### 7、组合排序

如果要先按用户的年龄排序，年龄相同的再按姓名排序，可以使用 Comparator 接口中的 thenComparing 默认方法：

```java
private static void sortGroupWithJdk8() {
    System.out.println("=====jdk8 组合排序=====");
    List<User> list = new Arraylist<>(LIST);
                list.sort(Comparator.comparing(User::getAge).thenComparing(User::getName));
    list.forEach(System.out::println);
    System.out.println();
}
```

输出结果：

> =====jdk8 组合排序=====
>
> 11: Tom
>
> 16: John
>
> 19: Bob
>
> 23: Lisa
>
> 26: Jessie
>
> 26: Messy
>
> 26: Tony
>
> 65:Yoga

注意年龄 26 岁的人又按姓名按自然顺序排序了。

##### 8、Stream 排序

还可以把 List 集合转换为 Stream，然后使用其 sorted 方法：

![](/images/编程题/4_4.jpg)

sorted 方法也是接收 Comparator 接口参数，所以我们也可以使用 Lambda、方法引用、Comparator 接口自身提供的工具方法对其调用：

```java
/**
* jdk8 Stream 排序
*/
private static void sortwithJdk8stream() {
    System.out.println("=====jdk8 Stream 排序====");
    List<User> list = new ArrayList<>(LIST);

    list = list.stream() .sorted(User::compareAge).collect(Collectors.tolist());

    list.forEach(System.out::println);
    System.out.println();
}
```

所以使用 Stream 也可以扩展多种排序方法，见注释部分，这里就不展开了。

##### 9、并行 Stream 排序

有 Stream 排序，那就并行 Stream（parallelStream）排序：

```java
/**
* jdk8 并行 Stream 排序
*/
private static void sortWithJdk8parallelStream() {
    System.out.println("=====jdk8 Stream 排序=====");
    List<User> list = new Arraylist<>(LIST);

    list = list.parallelStream() .sorted(User::compareAge).collect(Collectors.tolist());

    list.forEach(System.out::println);
    System.out.println();
}
```

##### 10、Collections 排序

既然在 Java 8 中，Comparator 接口被定义成了函数式接口，那么我们传统的 Collections 工具类就可以改变了，我们也可以使用 Lambda、方法引用、Comparator 接口自身提供的工具方法对其调用：

```java
/**
* jdk8 CoLLections 排序
*/
private static void sortwithcollections() {
    System.out.println("=----jdk8 Collections 排序===");
    List<User> list = new ArrayList<>(LIST);

    Collections.sort(list, User::compareAge);

    list.forEach(System.out::println);
    System.out.println();
}
```

## 5、编程实现成员变量可见性的例子

```java
public class Test {
    private static volatile int n1 = 0;

    public static void main(String[] args) throws InterruptedException {
        test1();
    }

    private static void test1() {
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            n1 = 1;
        }).start();

        while (n1 == θ) {

        }
        System.out.println("stop");
    }
}
```

这个例子加了 volatil，所以程序正确退出输出 stop。

##### 示例 2：

```java
public class Test {

    private static int n2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test2();
    }

    private static void test2() {
        new Thread(() -> {
            try {
                Thread.sleep(100e);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            n2 = 1;
        }).start();

        while (n2 == θ) {
            System.out.println(n2);
        }
        System.out.println("stop");
    }
}
```

这个例子没有加 volatile，程序也正常退出，输出一堆 O 并也正常输出了 stop，这是为什么呢？

##### 没有加 volatile 为什么也有可见性？

看起来是很诡异的问题，问题是在 while 里面加了一行 System. 输出问题，打开 println 方法源码看一下：

![](/images/编程题/5.jpg)

这个 println 方法里面加了 synchronized 同步块，正是因为这个 synchronized 同步块，因为它具有可见性所以保证了里面变量 × 的可见性，这个诡异的问题也就解开了。

> 而如果去掉 while 循环里面加 System..输出语句，线程对变量 n2 的修改对主线程就不可见了，程序普会一直循环，不会输出任何结果。

## 6、编程实现一个守护线程的例子

如下面的示例：

```java
public class Test {
    public static void execute() {
        for (int i = θ;  i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {

            }
            System.out.println(i);
        }
    }

    public static void main(String[] args) throws IoException {
        Thread thread = new Thread(() -> execute());
        thread.setDaemon(true);
        thread.start();

        System.in.read();
    }
}
```

##### 代码说明：

1）这里的用户线程是指 main 方法当前的主线程，主线程通过 System.in.read 来阻塞程序，只有在用户输入任何一个字符回车后，主线程才会退出；

2）创建一个简单的线程，把一个线程设置 daemon 为 true 即表示守护线程，守护线程每隔一秒打印 i 的值，守护线程守护的是用户主线程，直到主线程输入任何一个字符退出后，守护线程也就会跟就退出不再打印。

运行上面的程序，随便输入一个字符回车，因为用户线程退出了，所以守护线程也就跟着退出了，守护线程停止打印，如下图所示：

![](/images/编程题/6.jpg)

> ##### 需要注意的是：
>
> setDaemon 方法必须设置在线程 start 方法启动之前，不然会抛出异常。

### 7、编程实现让 3 个线程按顺序执行

用 Java 编程实现让 3 个线程按顺序执行。

> 创建 T1、T2、T3 三个线程，让 3 个线程按顺序执行，T2 在 T1 执行完后执行，T3 在 T2 执行完后执行。

---

示例代码：

```java
public class Executeorderly {

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
            System.out.println("T1 执行完成...");
        });

        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(1e00);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("T2 执行完成...");
        });

        Thread t3 = new Thread(() -> {
            System.out.println("T3 执行完成...");
        });

        t1.start();
        t1.join();

        t2.start();
        t2.join();

        t3.start();
    }
}
```

##### 输出结果：

![](/images/编程题/7.jpg)

原理就是使用线程的 join()方法进行阻塞，具体原理请看并发编程中的《join 方法有什么用？什么原理？》面试题。

### 8、编程实现一个线程 join 等待的例子

如以下示例代码：

```java
public static void main(String[] args) throws Exception {
    System.out.println("start");

    Thread t = new Thread(() -> {
        for (int i = θ; i< 5; i++){
            System.out.println(i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
        }
    });

    t.start();
    t.join();

    System.out.println("end");
}
```

结果输出：

> start
>
> 0
>
> 1
>
> 2
>
> 3
>
> 4
>
> end

线程 t 开始后，接着加入 t.join()方法，t 线程里面程序在主线程 end 输出之前全部执行完了，说明 t.join()阻塞了主线程直到 t 线程执行完毕，如果没有 t.join()，end 可能会在 0 ～ 5 之间输出。

### 9、编程实现一个线程谦让（yield）的例子

下面是一个线程谦让（yield）的使用示例：

```java
public static void main(String[] args) {
    Runnable runnable = () -> {
        for (int i = ; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() + "----" + i);
            if (i % 20 == 0) {
                Thread.yield();
            }
        }
    };

    new Thread(runnable, "R哥").start();
    new Thread(runnable,"小蜜").start();
}
```

这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。

##### 运行以上程序，可以有以下两种结果。

结果 1：R 哥让出了 CPU 资源，小蜜成功上位。

> R 哥-29
>
> R 哥-30
>
> 小蜜-26
>
> R 哥-31

结果 2：R 哥让出了 CPU 资源，R 哥继续运行。

> R 哥-28
>
> R 哥-29
>
> R 哥-30
>
> R 哥-31

而如果我们把两个线程加上线程优先级，那输出的结果又不一样。

```java
thread1.setPriority(Thread.MIN_PRIORITY);
thread2.setPriority(Thread.MAX_PRIORITY);
```

因为给小蜜加了最高优先权，R 哥加了最低优先权，即使 R 哥先启动，那小蜜还是有很大的概率比 R 哥先会输出完的，大家可以试一下。

## 10、编程实现一个线程中断的例子

我们来实例演示下线程中断如何用！

##### 示例 1 (中断失败)

```java
private static void test1() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();
        }
    });
    thread.start();
    thread.interrupt();
}
```

请问示例 1 中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。

##### 示例 2： (中断成功)

```java
private static void test2() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();

            //响应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Java技术栈线程被中断， 程序退出。 ");
                return;
            }
        }
    });
    thread.start();
    thread.interrupt();
}
```

我们给示例 2 加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。

##### 示例 3 (中断失败)

```java
private static void test3() throws InterruptedException {
    Thread thread = new Thread(() -> {
        while (true) {
            //购应中断
            if (Thread.currentThread().isinterrupted()) {
                System.out,println("Java技术栈线程被中断， 程序退出。 ");
                return;
            }
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                System.out.println("Java技术栈线程休眠被中断，程序退出。");
            }
        }
    });
    thread.start();
    Thread.sleep(2000);
    thread.interrupt();
}
```

示例 3 sleep()方法被中断，并输出了`Java技术栈线程休眠被中断，程序退出。`程序继续运行....为什么呢？

来看 sleep 的源码：

![](/images/编程题/10.jpg)

可以看出 sleepO 方法被中断后会清除中断标记，所以循环会继续运行。。

##### 示例 4 (中断成功)

```java
private static void test4() throws InterruptedException {
    Thread thread = new Thread(() -> {
        while (true) {
            //购应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out,println("Java技术栈线程被中断， 程序退出。 ");
                return;
            }
            try {
                Thread.sleep(3006);
            } catch (Interruptedexception e) {
                System.out.println("Java技术栈线程休眠被中断，程序退出。");
                Thread.currentthread().interrupt();
            }
        }
    });
    thread.start();
    Thread.sleep(2000);
    thread.interrupt();
}
```

示例 4 全部信息输出并正常退出，只是在 sleep()方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。

## 11、编程实现一个线程分组的例子

如下面的示例代码：

```java
ublic static void main(string[] args) {
    Runnable runnable = () -> {
        System.out.println("Java技术栈线程线程组名称:" + Thread.currentThread().getThreadGroup());
        System.out.println("Java技术栈线程线程名称：" + Thread.currentThread() .getName());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    };

    ThreadGroup userGroup = new ThreadGroup("user");
    userGroup.setMaxPriority(Thread.MIN_PRIORITY);

    Thread userTaskl = new Thread(userGroup, runnable, "user-taski");
    Thread userTask2 = new Thread(userGroup, runnable, "user-task2");

    userTaskl.start();
    userTask2.start();

    System.out.println("Java技术栈线程线程组活跃线程数：" + userGroup.activecount());
    userGroup.list();
}
```

程序输出以下结果：

> Java 技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
>
> Java 技术栈线程线程名称：user-task1
>
> Java 技术栈线程线程组活跃线程数：2
>
> Java 技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
>
> Java 技术栈线程线程名称：user-task2
>
> java.lang.ThreadGroup[name=user,maxpri=1]
>
> Thread[user-task1,1,user]
>
> Thread[user-task2,1,user]

## 12、编程实现一个线程 wait 等待的例子

如下面的使用示例：

```java
public static void main(string[] args) {
    Object lock = new Object();
    Thread t1 = new Thread(() -> {
        synchronized (lock) {
            for (int i = 0; i < 20; i++) {
                System.out.print(i);
                if (i == 10) {
                    try {
                        lock.wait();
                    } catch (Interruptedexception e) {
                        e.printstackTrace();
                    }
                }
            }
        }
    });

    Thread t2 = new Thread(() -> {
        synchronized (lock) {
            try {
                Thread.sleep(50e0);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
            System.out.print("Java技术栈");
            lock.notifyAll();
        }
    });

    t1.start();
    t2.start();
}
```

上面的例子结合 wait/ notifyAll 来演示了它们的相互作用，线程 t1 首先输出`012345678910`，5 秒后继续输出`Java技术栈111213141516171819`。

## 13、编程实现一个多线程死锁的例子

用 Java 编程实现一个多线程死锁的例子。

---

下面是一个多线程死锁的例子：

```java
public class Test {
    private static object lockl = new object();
    private static object lock2 = new object();

     public static void main(string[] args) {
         new Thread(() -> {
             synchronized (lock1) {
                 System.out.println("thread1 get lockl");
                 try {
                     Thread.sleep(100e);
                 } catch (Interruptedexception e) {
                     e.printstackTrace();
                 }
                 synchronized (lock2) {
                     System.out.printin("thread1 get lock2");
                 }
                 System.out.println("thread1 end");
             }
         }).start();

         new Thread(() -> {
             synchronized (lock2) {
                 System.out.println("thread2 get lock2");
                 try {
                     Thread.sleep(1000);
                 } catch (Interruptedexception e) {
                     e.printstacktrace();
                 }
                 synchronized (lock1) {
                      System.out.println("thread2 get lock1");
                 }
                 System.out.println("thread2 end");
             }
         }).start();
     }
}
```

##### 输出结果：

thread1 get lock1

thread2 get lock2

两个线程相互得到锁 1，锁 2，然后线程 1 等待线程 2 释放锁 2，线程 2 等待线程 1 释放锁 1，两个线程互相等待对方释放锁，这样形成死锁。

## 14、编程：使用 LongAccumulator 实现一个 LongAdder

> 用 LongAccumulator 来实现 LongAdder 同样的功能。

##### 定义一个累加规则的 LongAccumulator：

```java
private static LongAccumulator longAcumulatorAdd = new LongAccumulator((left, right) -> left + right, e);
```

##### 使用 LongAccumulator 进行累加：

```java
private static finalint MAX_P0OL_SIZE = 10;

7 private static void add(LongAccumulator longAccumulator, long number) throws InterruptedException {
    long start = System.currentTimeMillis();
    ExecutorService es = Executors.newFixedThreadPool(MAX_POOL_SIzE);
    for (int i = 0; i < MAx_POOL_SIZE; i++) {
        es.execute(() -> {
            for (int j = e; j< MAx_LOOP_SIZE; j++) {
                longAccumulator.accumulate(number);
            }
        });
    }

    es.shutdown();
    es.awaitTermination(5, TimeUnit.MINUTES);
    System.out.printf("LongAccumulator %s*%s +%s 结果: %s, 耗时: %sms.\n",
                     MAX_POOL_SIZE,
                     MAX_LOOP_SIZE,
                     number,
                     longAccumulator.get(),
                     (System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

##### 测试一下：

```java
 public static void main(string[] args) throws InterruptedException {
     // 和LongAdder一致
     add(longAccumulatorAdd, 1);

     // 每次累加2
     add(longAccumulatorAdd, 2);
 }
```

第一次调用方法实现了和 LongAdder 一样的功能，第二次调用方法是每次累加 2，这个是 LongAdder 所办不到的。

##### 输出结果：

![](/images/编程题/14.jpg)

## 15、编程：使用 LongAccumulator 实现求最大值

> 实现一个自定义规则的运算，求所有值的最大值。

##### 定义一个取最大值规则的 LongAccumulator：

```java
private static LongAccumulator longAccumulatorMax = new LongAccumulator(Long::max, 50);
```

这里使用了方法引引用，这也是 Java 8 引进的新语法。

##### 使用 LongAccumulator 进行取最大值：

```java
private static final int MAx_pool_sIzE = 10;

private static void max(LongAccumulator longAccumulator) throws InterruptedException {
    long start = System.currentTimeMillis();
     ExecutorService es = Executors.newFixedThreadPool(MAx_PooL_SIZE);
    for (int i = O; i< MAX_POoL_SIZE; i++) {
        int finall = i;
        es.execute(() -> {
            longAccumulator.accumulate(finall * 10);
        });
    }

    es.shutdown();
     es.awaitTermination(5, TimeUnit.MINUTES);
    System.out.printf(“LongAccumulator 求最大值结果： %s， 耗时： %sms.\n",
                      longAccumulator.get(),
                      (System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

##### 测试一下：

```java
public static void main(string[] args) throws InterruptedException {
    //和LongAdder一致
    add(longAccumulatorAdd, 1);

    //每次累加2
    add(longAcumulatorAdd, 2);

    //求最大值
    max(longAccumulatorMax);
}
```

初始值为 50，循环中的最大值应该是 9＊10=90，来看下测试结果：

![](/images/编程题/15.jpg)

没毛病，结果输出正常。

当然，求最大值远远不会用到这个类，这里只是演示下这个自定义规则而已，你可以求乘积，更复杂的判断运算等其他自定义规则的运算，有了自定义规则，那它所能实现的功能远比 LongAdder 要强大，并且其性能也是旗鼓相当的。

## 16、编程实现使用 ForkJoin 框架的例子

实现一个 Fork/Join 小例子，从 1+2+.10 亿，每个任务只能处理 1000 个数相加，超过 1000 个的自动分解成小任务并行处理；并展示了通过不使用 Fork/小 oin 和使用时的时间损耗对比。

---

如下面的示例代码：

```java
import java.util.concurrent.ForkjoinPool;
import java.util.concurrent.RecursiveTask;

 public class ForkJoinTask extends RecursiveTask<Long> {
     private static final long MAx = 1000000000l;
     private static final long THRESHoLD = 1000L;
     private long start;private long end;

     public ForkjoinTask(long start, long end) {
         this.start = start;
         this.end = end;
     }

     public static void main(string[] args) {
         test();
         System.out.println("---------");
         testForkJoin();
     }

     private static void test() {
          System.out.printin("test");
         long start = System.currentTimeMillis();
         Long sum = oL;
         for (long i = OL; i<= MAx; i++) {
             sum += i;
         }
         System.out.println(sum);
         System.out.println(system.currentTimeMillis() - start + "ms");
     }

     private static void testforkjoin() {
         System.out.println("testForkJoin");
         long start = System.currentTimeMillis();
         ForkJoinPool forkJoinPool = new ForkJoinPool();
         Long sum = forkJoinPool.invoke(new ForkJoinTask(1, MAx));
         System.out.println(sum);
         System.out.printin(System.currentTimeMillis() - start + "ms");
     }

     @override
     protected Long compute() {
         long sum = 0;
         if (end - start <= THRESHOLD) {
             for (long i = start; i <= end; i++) {
                 sum += i;
             }
             return sum;
         } else {
             long mid = (start + end) / 2;

             ForkjoinTask taskl = new ForkjoinTask(start, mid);
             task1.fork();

             ForkJoinTask task2 = new ForkjoinTask(mid + 1, end);
             task2.fork();

             return taski.join() + task2.join();
         }
     }
 }
```

这里需要计算结果，所以任务继承的是 RecursiveTask 类。

ForkJoinTask 需要实现 compute 方法，在这个方法里首先需要判断任务是否小于等于阈值 1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用 fork 方法时，又会进入 compute 方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。

使用 join 方法会阻塞并等待子任务执行完并得到其结果。

程序输出：

> test
>
> 50000000050000000
>
> 4992ms
>
> ---
>
> testForkJoin
>
> 500000000500000000
>
> 508ms

从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。

## 17、编程实现 ThreadLocal 的使用例子

> 使用 ThreadLocal 编程示例，变量类型为 User，并初始化为 tom,12 岁，启动 3 个线程，每个线程循环 3 次，休眠 1 秒，主线程再输出。

参考实现示例如下：

```java
public class Test {

    @Data
    @AllArgsconstructor
    static class user {
        private string username;
        private int age;
    }

    private static Threadlocal<User> tl = ThreadLocal.withinitial(() -> new User("tom", 12));

     static class Testthread extends Thread {
         @Override
         public void run() {
             for (int i = 0; i < 3; i++) {
                 User user = tl.get();
                 user.setUsername(Thread.currentThread() -getName());
                 user.setAge(i):
                 tl.set(user);
                  System.out.println(tl.get());
             }
         }
     }

     public static void main(string[] args) throws InterruptedException {
         for (int i = 0; i < 3; i++) {
             new Testthread().start();
             Thread.sleep(1000);
             System.out.printin(Thread.currentThread()-getName() + tl.get());
         }
     }
}
```

输出结果如下：

> Test.User(username=Thread-0, age=0)
>
> Test.User(username=Thread-0, age=1)
>
> Test.User(username=Thread-0, age=2)
>
> mainTest.User(username=tom, age=12)
>
> Test.User(username=Thread-1, age=0)
>
> Test.User(username=Thread-1, age=1)
>
> Test.User(username=Thread-1, age=2)
>
> mainTest.User(username=tom, age=12)
>
> Test.User(username=Thread-2, age=0)
>
> Test.User(username=Thread-2, age=1)
>
> Test.User(username=Thread-2, age=2)
>
> mainTest.User(username=tom, age=12)

从结果可见每个线程使用的是各自线程的变量副本，并没有影响其他线程和主线程，实现了线程隔离的效果。

## 18、编程实现一个 CountDownLatch 的使用示例

##### 比如有下面一道题：

> 阻塞 N 个线程执行完后，主线再往下执行，并统计所有线程的总耗时。

当然我们可以通过 join 的形式完成这道题，但如果我说统计 100 个、1000 个线程呢？难道要写 1000 个 join 等待吗？这显然是不现实的，这时可以使用 CountDownLatch 类来实现。

废话少说，我们来做一个例子看看上面的题怎么实现：

```java
public class Test {
    public static void main(string[] args) throws InterruptedException {
         CountDownLatch cdl = new CountDownLatch(100);
        long start = System.currentTimeMillis();
        for (int i = e; i < 100; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep(500);
                } catch (Interruptedexception e) {
                    e.printstackTrace();
                } finally {
                    cd1.countDown();
                }
            }).start();
        }

        cdl.await();
        System.out.println(cdl.getcount());
        System.out.println(string.format("耗时: %sms", System.currentTimeMillis() - start));
    }
}
```

输出结果：

> 0
>
> 耗时：521ms

![](/images/编程题/18.jpg)

首先通过 new CountDownLatch(10o) 约定了倒计时器的数量，在这里也是线程的数量，每个线程执行完后再对倒计时器－1。countDown 方法即是对倒计时器－1，这个方法需要放在 finally 中，一定要保证在每个线程中得到释放，不然子线程如果因为某种原因报错倒计时器永远不会清 0，则会导报主线程会一直等待。

await 方法即是主线程阻塞等待倒计器归 0 后再继续往下执行，当然 await 方法也可以带时间进去，等待多久时间后不管倒计时器有没有归 0 主线程继续往下执行。

如上面的例子所示，我们输出了倒计时器最后的数字 0，表示倒计时器归 0 了，也输出了从开始到结束所花费的时间。从这个例子可以完全理解倒计时器的含义，这个工具类在实际开发经常有用到，也很好用。

## 19、编程实现一个 CyclicBarrier 的使用示例

##### 比如有下面一道题：

> 让 5 个线程同时执行，当每个线程都执行了某段代码后再继续往下执行，如果 5 个线程有一个线程还未执行该段代码，否则其他线程一直等待。

从上面的题目，我们来看下面的例子：

```java
public class Test {
     public static void main(string[] args) {
         long start = System.currentTimeMillis();
         CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> {
             System.out.println(string.format("毛: %sms", System.currentTimeMillis() - start));
             System.out.println("cyclicBarrier finished.");
         });

         for (int i = e; i < 10; i++) {
             new Thread(() -> {
                 try {
                     Thread.sleep(3000);
                     cyclicBarrier.await();
                     System.out.printin(Thread.currentThread().getName());
                 } catch (Exception e) {
                     e.printstackTrace();
                 }
             }).start();
         }
     }
}
```

输出结果：

> 耗时:3015ms
>
> CyclicBarrie finished.
>
> Thread-2
>
> 耗时:3021ms
>
> CyclicBarrier finished.
>
> Thread-9
>
> Thread-0
>
> Thread-1
>
> Thread-4
>
> Thread-3
>
> Thread-7
>
> Thread-5
>
> Thread-8
>
> Thread-6

![](/images/编程题/19.jpg)

首先 CyclicBarrier 构造方法接受 5 个线程数和线程聚齐时的回调线程，就是当 5 个线程都调用了 await 方法，这 5 个线程才继续往下执行，执行前先运行到齐时的回调线程。

从例子输出的结果可以看出 CyclicBarrier finished.先运行的，说明 5 个线程都执行完后运行了回调线程，再输出了每个线程名称，我们控制 10 个线程来阻塞等待，而循环栅栏只有 5 个，说明它是可以循环利用的，每到齐 5 个线程阻塞的线程就继续执行。

> ##### 需要注意的是，await 方法会抛出异常：
>
> - 一个是中断异常 InterruptedException，即其他线程中断了这个线程;
> - 一个是 BrokenBarrierException，如果 1 个线程被打断出现 InterruptedException，其他等待在循环栅栏外面的线程就会出现 BrokenBarrierException。因为一个线程被打断了，即打破了循环栅栏的完整性，导致线程不能到齐其他线程永远不能继续执行，这个异常也就避免了线程永远等待的情况。

## 20、编程实现一个 Semaphore 的使用示例

如下面的示例：

```java
public class Test {
    public static void main(string[] args) {
        Semaphore semaphore = new Semaphore(2);
        long start = System.currentTimeMillis();
        for (int i = e; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread()·getName() +"获取许可耗时： " + (System.currentTimeMillis() - start));
                    TimeUnit.SEcoNDs.sleep(3);
                } catch (Interruptedexception e) {
                    e.printstacktrace();
                } finally {
                    System.out.printin(Thread.currentThread()·getName() + " 释放许可");
                    semaphore.release();
                }
            }).start();
        }
    }
}
```

通过 Semaphore 构造了 2 个许可线程，然后开启了 5 个线程同时执行，然后每个线程需要获取 Semaphore 许可才能执行，执行时休眠 3 秒模拟阻塞获取许可的场景，每个线程执行完后需要在 finally 主动释放许可，不然会造成其他线程一直阻塞，除非被中断。

输出结果：

> Thread-0 获取许可耗时：6
>
> Thread-1 获取许可耗时：6
>
> Thread-0 释放许可
>
> Thread-1 释放许可
>
> Thread-2 获取许可耗时：3034
>
> Thread-3 获取许可耗时：3034
>
> Thread-3 释放许可
>
> Thread-2 释放许可
>
> Thread-4 获取许可耗时：6037
>
> Thread-4 释放许可

从输出结果可以看到是有序执行的，释放两个许可，才能继续执行后续两个线程。

## 21、编程实现两个线程彼此交换数据的例子

##### 简单数据交换

来一个两个线程正常数据交换的简单示例：

```java
private static void test1() {
    Exchanger exchanger = new Exchanger();
      try {
            object data="-公众号Java技术栈AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
  }).start();

    new Thread(() -> {
    try {
            object data =："-公众号Java技术栈BBB";
            System.out.println(Thread.currentThread() .getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data):
            System.out.println(Thread.currentThread() .getName() + data) ;
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    }).start();
}
```

##### 这段代码的逻辑：

1、创建并启动两个线程；

2、进行数据交换前先打印出自己线程的数据；

3、进行数据交换；

4、打印数据交换之后的数据；

##### 输出结果：

![](/images/编程题/21_1.jpg)

从结果可以看出，线程 0、1 分别先打印出 A、B，数据交换之后，打印出了 B、A，数据交换正常！

##### 超时数据交换

上面演示了两个线程的正常交换，下面再来一个带超时的示例：

```java
private static void test2() {
    Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            Object data="-公众号Java技术栈AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data, 3000L, TimeUnit.MILLIsEcoNDS);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (Exception e) {
            e.printstackTrace();
        }
    }).start();
}
```

现在只启动了一个线程，并且设置了超时时间 3 秒。

##### 输出结果：

![](/images/编程题/21_2.jpg)

首先线程输出了自己的数据，然后 3 秒后，并没有其他线程和它交换数据，所以抛出了超时异常，最后线程结束运行。

##### 中断数据交换

线程开始交换数据后，会一直阻塞直到其他任意线程和它交换数据，或者被中断、超时，上面演示了超时，下面这个示例演示一下中断。

```java
private static void test3() {
     Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            object data ="-公众号Java技术栈AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (Exception e) {
            e.printstackTrace();
        }
    }).start();
}
```

结果输出：

![](/images/编程题/21_3.jpg)

默认情况下不带超时设置会一直阻塞运行中....

现在我再加入一段中断的逻辑：

```java
private static void test3() throws InterruptedException {
    Exchanger exchanger = new Exchanger();

    Thread thread = new Thread(() -> {
        try {
            Object data ="-公众号Java技术栈AAA";
            System.out.printin(Thread.currentThread()-getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + data) ;
        } catch (Exception e) {
            e.printstackTrace();
        }
    });

    thread.start();

    //线程中断
    Thread.sleep(3000L);
    thread.interrupt();
}
```

主线程休眠 3 秒后，中断该线程。

输出结果：

![](/images/编程题/21_4.jpg)

输出结果 3 秒后，线程被中断了，抛出了中断异常，线程也停止阻塞，最后线程结束运行。

##### 两两数据交换

另外需要知道是，Exchanger 只能用于两个线程之间的数据交换，一个线程开启数据交换之后，会阻塞直到其他任意线程同样开启数据交换达到交换点。

最后来个示例，开启 10 个线程，看它们是怎么两两交换的：

```java
private static void test4() {
     Exchanger exchanger = new Exchanger();

    for (int i = 1; i <= 10; i++) {
        Integer data = i;
        new Thread(() -> {
            try {
                 Object exchange = exchanger.exchange(data);
                 System.out.println(Thread.currentThread().getName() +"-" + exchange);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
        }, "Java技术栈" + i).start();
    }
}
```

输出结果：

![](/images/编程题/21_5.jpg)

可以看到，10 个线程，都两两交换彼此的数据了。

> 这篇介绍了线程之间的数据交换器 Exchanger 类的使用，Exchanger 只能用于多个线程中的两个线程两两交换数据，如果没有对应的线程交换就会一直阻塞，可设置超时，可以中断。

## 22、编程实现一个 LockSupport 阻塞唤醒线程的使用示例

如下面的使用示例：

```java
public class Test {

    public static void main(string[] args) {
        Thread thread1 = new Thread(() -> {
            System.out.println("thread1 start...");
            Locksupport.park();
            System.out.println("thread1 end...");
        });
        thread1.start();

        Thread thread2 = new Thread(() -> {
            System.out.println("thread2 start...");
            try {
                TimeUnit.SECONDSs.sleep(3):
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            Locksupport.unpark(thread1);
            System.out.println("thread2 唤醒了 thread1");
        });
        thread2.start();
    }
}
```

输出结果：

> thread1 star...
>
> thread2 start..
>
> thread2 唤醒了 thread1
>
> thread1 end...

thread1 阻塞后，在 thread2 休眠 3 秒后再唤醒 thread1 后才继续执行。

## 23、编程：基于 Externalizable 序列化和反序列化一个对象

##### 1、类实现 Externalizable 序列化接口

要基于 Externalizable 接口序列化一个对象，这个对象所在类就必须实现 Java 序列化的接口：

> java.io.Externalizable

```java
 public class User implements Externalizable {
     private static final long serialversionuID = 1L;

     public User() {

     }

     private string username;

     private transient string id;

     public String getusername() {
         return username;
     }

      public void setusername(string username) {
          this.username = username;
      }

     public string getid() {
         return id;
     }

     public void setid(string id) {
        this.id = id;
     }

     @Override
     public void writeExternal(objectoutput objectoutput) throws IoException {
       objectoutput.writeobject(id) ;
     }

     @Override
      public void readExternal(objectInput objectInput) throws IOException, ClassNotFoundException {
          id = (String) objectinput.readobject();
      }
 }
```

##### 2、序列化/反序列化

```java
public class ExternalizableTest {
    public static void main(string[] args) throws Exception {
        User user = new User();
        user.setusername("Java技术栈");
        user.setid("javastack");
        objectoutput objectoutput = new objectoutputstream(new Fileoutputstream(new File("javastack")));
        objectoutput.writeobject(user);

        objectInput objectinput :: new objectInputstream(new FileInputstream(new File("javastack")));
        user = (User) objectinput.readobject();

        System.out.println(user.getusername());
        System.out.printin(user.getId());
        objectoutput.close();
        objectInput.close();
    }
}
```

##### 输出结果：

> null
>
> javastack

因为 User 类只手动序列化了 id，usermame 没有序列化所以为 null。

> ##### User 中的 id 被 transient 修饰了，为什么还能序列化出来？
>
> 那是因为 User 实现了接口 Extermalizable，而不是 Serializable， transient 只作用于 Serializable 接口。

## 24、编程：基于 Serializable 序列化和反序列化一个对象

##### 1、类实现 Serializable 序列化接口

要基于 Serializable 接口序列化一个对象，这个对象所在类就必须实现 Java 序列化的接口：

> java.io.Serializable

```java
public class User implements Serializable {

    private static final long serialversionuID = -8475669200846811112L;

    private string username;

    private string address;

    public String getusername() {
        return username;
    }

    public void setusername(string username) {
        this.username = username;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(string address) {
        this.address = address;
    }

    @Override
    public string tostring() {
        return "user{" +
            "username='" + username + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}
```

##### 2、序列化/反序列化

可以借助 commons-lang3 工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。

```java
public class Test {
    public static void main(string[] args) {
        User user = new User();
        user.setusername("Java");
        user.setAddress("china");
        byte[] bytes = Serializationutils.serialize(user);

        User u = Serializationutils.deserialize(bytes);
        System.out.printin(u);
    }
}
```

输出：

> User{username='Java', address='china'}

上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。

---

SerializationUtils 工具类序列化/反序列化方法源码如下：

```java
public static byte[] serialize(final sSerializable obj) {
    final ByteArrayoutputstream baos = new ByteArrayoutputstream(512);
    serialize(obj, baos);
    return baos.toByteArray();
}

public static void serialize(final serializable obj, final outputstream outputstream) {
    Validate.notNull(outputstream, "outputstream");
    try (objectoutputstream out = new objectoutputstream(outputstream)) {
        out.writeobject(obj);
    } catch (final IOException ex) {
        throw new SerializationException(ex);
    }

}

public static <T> I deserialize(final byte[] objectData) {
    Validate.notNull(objectData, "objectData");
    return deserialize(new ByteArrayInputstream(objectData));
}

public static <T> I deserialize(final Inputstream inputstream) {
    Validate.notNull(inputstream, "inputstream");
    try (objectinputstream in = new objectinputstream(inputstream)) {
        @suppressWarnings("unchecked")
        final T obj = (T) in.readobject();
        return obj;
    } catch (final ClassNotFoundException | IoException ex) {
        throw new SerializationException(ex);
    }
}
```

让你知道，如果不用工具类，序列化和反序列化就得这么写。

## 25、编程实现一个序列化对象部分数据的例子

> 给定一个用户类，只有用户名和 ID 成员变量，要求只序列化和反序列化用户名，ID 不需要序列化。

只序列化部分对象数据，关键是使用 transient 关键字修饰不需要序列化的成员变量。

要序列化的用户类：

```java
 public class User implements serializable {
     private static final long serialversionuID = 1L;

     private string username;
     private transient string id;

     public String getusername() {
         return username;
     }

     public void setusername(string username) {
         this.username = username;
     }

     public string getid() {
         return id;
     }

     public void setid(string id) {
         this.id = id;
     }
 }
```

测试程序：

```java
public class TransientTest {
    public static void main(string[] args) throws Exception {
        User user = new User();
        user.setUsername("Java技术栈");
        user.setid("javastack");

        System.out.printin("\n序列化之前");
        System.out.printin("username: " + user.getusername());
        System.out.println("id: " + user.getid());

        Objectoutputstream os = new objectoutputstream(new Fileoutputstream("d:/user.txt"));
        os.writeobject(user);
        os.flush();
        os.close();

        ObjectInputstream is = new objectInputstream(new FileInputstream("d:/user.txt");
        user = (User) is.readobject();
        is.close();

    System.out.println("\n序列化之后");
    System.out.println("username: " + user.getusername());
    System.out.printin("id: "+ user.getid());
    }
}
```

输出结果：

> 序列化之前
>
> username: Java 技术栈
>
> id: javastack
>
> 序列化之后
>
> username: Java 技术栈
>
> id: null

上面的示例在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。

## 26、编程实现一个读写文件的示例

在 Java 中，可以使用 IO 包中的类读写文件。

如下面的示例，读取文件并将其内容写入另一个文件中：

```java
public class Test {
    public static void main(string[] args) {
        String fileName = "java.txt";
        String content = "小程序: Java面试库";

        //写文件
        try (Filewriter filewriter = new Filewriter(fileName)) {
            Bufferedwriter bufferedwriter = new Bufferedwriter(filewriter);
            bufferedwriter.write(content);
            bufferedwriter.flush();
        } catch (Exception e) {
            System.out.println("写文件出错");
        }

        //读取文件
        StringBuilder filecontent = new StringBuilder();
        try (FileReader fileReader = new FileReader(fileName)) {
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            String line;
            while ((line = bufferedReader.readline()) l= null) {
                filecontent.append(line);
                filecontent.append("\n");
            }
        } catch (Exception e) {
            System.out.println("读取文件出错");
        }

        System.out.println("文件内容：" + filecontent);
    }
}
```

输出结果：

![](/images/编程题/26.jpg)

## 27、编程实现一个复制文件的示例

如下面的示例，使用 BufferedReader 和 BufferedWriter 来实现文件的复制。

```java
public class Test {
    public static void main(string[] args) {
        String sourceFile = "java.txt";
        String targetFile = "java2.txt";

        try (BufferedReader br = new BufferedReader(new FileReader(sourceFile));
             Bufferedwriter bw = new Bufferedwriter(new FileWriter(targetFile))) {
            String line;
            while ((line = br.readline()) != null) {
                bw.write(line);
                bw.newLine();
            }
        } catch (IoException e) {
            e.printstackTrace();
        }
    }
}
```

也可以使用 apache/ commons-io 工具包中的 IOutils.copy\* 方法快速复制。

## 28、编程比较两个文件的内容是否相等

示例代码如下：

```java
public class Test {
    public static void main(string[] args) throws Exception {
        // JDK 原生实现
        byte[] file1 = Files.readAlleytes(Paths.get("java.txt"));
        byte[] file2 = Files.readAllBytes(Paths.get("java2.txt"));
        boolean isequals1 = Arrays.equals(file1, file2);
        System.out.printf("两个文件内容是否相等：%s\n"，isEquals1);

        // 使用IoutiLs工具类
        boolean isEquals2 = Ioutils.contentEquals(new FileInputstream("java.txt"), new FileInputstream("java2.txt"));
        System.out.printf("两个文件内客是否相等：%s"， isEquals2);
    }
}
```

## 29、编程实现一个读写直接内存的示例

如下面的示例，从直接内存读写一个字符串：

```java
public class Test {
    public static void main(string[] args) throws Exception {
        //分配直接内存
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

        //获取直接内存的地址
        long address = ((DirectBuffer) buffer).address();

        //写入数据
        buffer.put("小程序: Java面试库".getBytes(Standardcharsets.UTF_8));

        //从直接内存中读取数据
        buffer.flip();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        System.out.printin(new String(bytes));

        //释放直接内存
        Cleaner cleaner = ((DirectBuffer) buffer).cleaner();
        if (cleaner != null) {
            cleaner.clean();
        }
    }
}
```

输出结果：

![](/images/编程题/29.jpg)

## 30、编程输出当前类加载器及所有父类加载器

来看下面的例子：

```java
public static void main(string[] args) throws Exception {
    ClassLoader C = ClassLoader.getSystemClassLoader();
    System.out.printin(c);
    while ((c = c.getParent()) != null) {
        system.out.printin(c);
    }
}
```

输出结果：

![](/images/编程题/30.jpg)

程序首先输出了程序默认的类加载器 AppClassLoader，然后再输出了其父类加载器 ExtClassLoader。

## 31、编程实现一个自定义的类加载器

> 编程实现一个自定义的类加载器，加载自定义目录下 c:/test/com/testjdk/Key.class 这个类。

读取自定义目录的类：

```java
@Tostring
public class Key {
    private string key ="111111";
}
```

自定义 ClassLoader：

```java
public class Customclassloader extends ClassLoader {

    private String classPath;

    public CustomclassLoader(String classPath) {
        this.classpath = classPath;
    }

    @Override
    protected Class<?> findclass(string name) throws ClassNotFoundException {
        try {
            String fileName = name.replaceAll("\.", "/");
            File file = new File(classpath + fileName + ".class");
            if (!file.exists()) {
                return super.findclass(name);
            }
            byte[] bytes = Files.readAlleytes(file.toPath());
            return defineclass(name, bytes, e, bytes.length);
        } catch (IoException e) {
            throw new ClassNotFoundexception(name, e);
        }
    }

     public static void main(string[] args) throws Exception {
         String classpath = "c:/test/";
         CustomClassLoader loader = new CustomclassLoader(classPath);
         Class<?> clazz = loader.loadclass("cn.javastack.test.Key");
         Key key = (Key) clazz.newinstance();
         System.out.printin(key);
     }
}
```

自定义类加载器正常加载到类，程序最后输出：11111

## 32、编程实现一个 hash 冲突的例子

下面使用 **HashMap** 来编程实现一个 hash 冲突的例子：

```java
public class Test {
    public static class Innerclass {
        public int id;

        public int getid() {
            return id;
        }

        public Innerclass(int id) {
            this.id = id;
        }

        @Override
        public boolean equals(object obj) {
            return ((Innerclass) obj).getid() == this.getid();
        }

        @Override
        public int hashcode() {
            return 1;
        }
    }

    public static void main(string[] args) throws Exception {
        Map<Innerclass, Integer> map = new HashMap<>();
        for (int i = 0; i < 20; ++i) {
            Innerclass innerclass = new Innerclass(i);
            map.put(innerclass, i);
        }
    }
}
```

InnerClass 类重写了 equals 和 hashCode 方法，但是使用的是同一个 hash 值 1，以模拟 hash 冲突的场景，然后循环创建作为 key 放入到 HashMap 中，调试结果如下：

![](/images/编程题/32_1.jpg)

当 for 循环 8 次 put 后，数组实际元素长度为 8，但 hash 始终为 1，即 hash 冲突了。

此时链表长度达到 8，数组默认容量为 16，因为数组容量<64 时只会扩容，所以此时还不会转红黑树，链表一旦达到 8 就会继续扩容直到数组容量>= 64：

> 链表长度-数组容量的变化： 8-16,9 －32,10－ 64

然后继续调试，当链表达到了 10，此时数组长度>=64 位长度，此时链表会转换为红黑树：

![](/images/编程题/32_2.jpg)

## 33、编程比较两个对象的内容是否相等

> 比如有两个 User 对象，如何比较它们的内容是否相等？

比较两个对象内容是否相等，需要重写 User 类的 equals 方法和 hashCode 方法，下面是示例代码。

```java
public class User {
    private string name;
    private int age;

    public user(string name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof User)) {
            return false;
        }

        User user = (user) obj;
        return objects.equals(this.name, user.name) && objects.equals(this.age, user.age);
    }

    @Override
    public int hashcode() {
        return objects.hash(this.name, this.age);
    }
}
```

两个对象在比较时，可以使用 equals 方法，或者是 Objects.equals 方法。

## 34、编程实现一个自定义函数式接口，并运用该函数式接口

##### 1、自定义一个函数式接口

```java
@FunctionalInterface
public interface Calcinterface<N, V> {
    V operation(N n1, N n2);
}
```

这里只有一个抽象方法，按规范`@FunctionalInterface`注解可以不用写。

##### 2、新建一个引用函数式接口的类

```java
 public static class Numberoperation<N extends Number, V extends Number> {
     private N nl;
     private N n2;

     public Numberoperation(N nl, N n2) {
         this.n1 = nl;
         this.n2 = n2;
     }

     public V calc(calcinterface<N, V> ci) {
         V v = ci.operation(nl, n2);
         return v;
     }
 }
```

##### 3、测试函数式接口

```java
public static void main(string[] args) {
    Numberoperation<Integer, Integer> np = new Numberoperation(13, 10);

    Calcinterface<Integer, Integer> addoperl = (n1, n2) -> n1 + n2;
    CalcInterface<Integer, Integer> multioperl = (nl, n2) -> n1 * n2;

  System.out.printin(np.calc(addoperl));
    System.out.println(np.calc(multioper1));

  System.out.printin(np.calc((n1, n2) -> n1 + n2));
  System.out.printin(np.calc((n1, n2) -> n1 * n2));
}
```

最后输出：

> 23
>
> 130
>
> 23
>
> 130

## 35、编程实现简单工厂模式(真实应用案例)

比如 XX 公司是做支付的，公司有几大类的客户：电商商户、银行客户、代理商....

创建这些客户的时候我们可以用简单工厂模式来实现看看。

##### 新建客户基类：

可以把所有客户公共的信息放到一个客户基类中，比如：客户名、客户类型等，所有的客户继承这个抽象基类。

```java
/**
* 客户
*/
@Data
@NoArgsconstructor
@AllArgsconstructor
public abstract class Customer {
    /**
    * 客户名称
    */
    private String name;

    /**
    * 客户类型
    */
    private String type;
}
```

##### 新建电商商户类：

```java
/**
* 商户
*/
@Data
@Tostring(callsuper = true)
public class Merchant extends Customer {

    /**
    * 合同类型
    */
    private int contracttype;

    /**
    * 结算周期(天)
    */
    private int settmentDays;

    public Merchant(string name, String type) {
        super(name, type);
    }
}
```

##### 新建银行客户类：

```java
/**
* 银行客户
*/
@Data
@Tostring(callsuper = true)
public class BankPartner extends Customer {

    /**
    * 银行编码
    */
    private string code;

    /**
    * 银行地址
    */
    private String address;

    public Bankpartner(string name, String type) {
        super(name, type);
    }
}
```

##### 新建代理商类：

```java
/**
* 代理商
*/
@Data
@Tostring(callsuper= true)
public class Agent extends Customer {

    /**
    * 代理周期
    */
    private int period;

    /**
    * 代理产品
    */
    private int[] products;

    public Agent(string name, String type) {
        super(name, type);
    }
}
```

##### 新增简单工厂类：

新建一个简单工厂，提供一个公共静态方法，根据不同的客户类型创建不同的客户。

```java
/**
* 客户简单工厂
*/
public class CustomerFactory {
    private static Merchant createMerchant(string type, String name) {
        return new Merchant(type, name);
    }

    private static BankPartner createBankPartner(String type, String name) {
        return new Bankpartner(type, name);
    }

    private static Agent createAgent(string type, String name) {
        return new Agent(type, name);
    }

    public static Customer create(string type, string name) {
        if ("M".equals(type)) {
            return createMerchant(type, name);
        } else if ("B".equals(type)) {
            return createBankPartner(type, name);
        } else if ("A".equals(type)) {
            return createAgent(type, name);
        }
        return null;
    }
}
```

##### 新建测试类：

```java
 public class Test {
     public static void main(string[] args) {
        Customer merchant = CustomerFactory.create("M", "Java技术栈商户");
        System.out.println(merchant);

        Customer bankPartner = CustomerFactory.create("B"， "Java技术栈银行客户");
        System.out.printin(bankPartner);

        Customer agent = CustomerFactory.create("A", "Java技术栈代理商");
    System.out.printin(agent);
     }
 }
```

##### 输出结果：

![](/images/编程题/35.jpg)

可以看出简单工厂的使用很简单，就是耦合性太高了。

第一，对象和基类之间是基于继承的。

第二，工厂类耦合了不同对象的创建，如果对象类型不是固定或者经常变动的，就要频繁修改工厂类，比如我现在要再加一种客户，就必须要改动工厂类，不符开闭原则。

所以，简单工厂只适用于固定类型对象的创建。

## 36、编程实现工厂方式模式 (真实应用案例)

工厂方法就是为某类产品提供一个工厂接口，然后为每个产品提供一个工厂实现类。

废话少说，我们将简单工厂的示例用工厂方法再改造一下。

##### 新建工厂方法接口：

```java
/**
* 工厂方法客户接口
*/
public interface CustomerFactory {
    Customer create(string type, String name);
}
```

##### 新建商户工厂实现类：

```java
/**
* 工厂方法客户接口
*/
public class MerchantFactory implements CustomerFactory {

    @Override
    public Customer create(string type, String name) {
        return new Merchant(type, name);
    }
}
```

##### 新建银行客户工厂实现类：

```java
/**
* 银行客户工厂
*/
public class BankPartnerFactory implements CustomerFactory {
    @Override
     public Customer create(string type, String name) {
         return new Bankpartner(type, name);
     }
}
```

##### 新建代理商工厂实现类：

```java
/**
* 代理商工厂
*/
public class AgentFactory implements CustomerFactory {
    @Override
     public Customer create(string type, String name) {
         return new Agent(type, name);
     }
}
```

##### 新建测试类：

```java
public class Test {
    public static void main(string[] args) {
        System.out.println("---.----工厂模式-工厂方法--·");

        CustomerFactory merchantFactory = new MerchantFactory();
        Customer merchant = merchantFactory.create("M", "Java技术栈商户");
        System.out.println(merchant);

        CustomerFactory bankPartnerFactory = new BankpartnerFactory();
        Customer bankPartner = bankPartnerFactory.create("B", "Java技术栈银行客户");
        System.out.printin(bankpartner);

        CustomerFactory agentFactory= new AgentFactory();
        Customer agent = agentFactory.create("A", "Java技术栈代理商");
        System.out.printin(agent);
    }
}
```

##### 输出结果：

![](/images/编程题/36.jpg)

可以看出，工厂方法也是挺简单易用的，耦合性问题也解决了，每增加一个产品就新增一个产品工厂实现类就行了，扩展性非常好。

但也有一个问题，如果产品非常多，那势必会造成工厂实现类泛滥，另外一种可怕的场景就是，如果涉及到工厂接口变更，工厂实现类的维护简直就是一种恶梦。

## 37、编程实现抽象工厂模式 (真实应用案例)

工厂方法中一个工厂只能创建一个对象，如果现在每次创建客户的时候都需要同时创建一份客户扩展资料，那就可以考虑使用抽象工厂。

##### 新建客户扩展基类：

可以把所有客户公共的扩展信息放到一个客户扩展基类中，比如：客户曾用名、客户扩展说明等，所有的客户继承这个扩展抽象基类。

```java
/**
* 客户扩展
*/
@Data
@NoArgsconstructor
public abstract class CustomerExt {

    /**
    * 客户曾用名
    */
    private String formerName;

    /**
    * 客户扩展说明
    */
    private String note;
}
```

##### 新建商户扩展类：

```java
/**
* 商户
*/
@Data
@Tostring(callsuper= true)
public class MerchantExt extends CustomerExt {

    /**
    * 介绍人
    */
    private int introduceName;

    /**
    * 介绍人电话
    */
    private String introduceTel;
}
```

##### 新建银行客户扩展类：

```java
/**
* 银行客户扩展
*/
@Data
@Tostring(callsuper = true)
public class BankPartnerExt extends CustomerExt {
    /**
    * 分行个数
    */
     private int branchcount;

    /**
    * ATM个数
    */
    private int atmcount;
}
```

##### 新建代理商扩展类：

```java
/**
* 商户
*/
@Data
@Tostring(callsuper = true)
public class AgentExt extends CustomerExt {
    /**
    * 来源
    */
    private string source;


    /**
    * 资质
    */
    private string certification;
}
```

新建抽象工厂接口：

```java
/**
* 抽象工厂窖户接口
*/
 public interface CustomerFactory {
     Customer createcustomer(string type, String name);

     CustomerExt createcustomerExt();
 }
```

##### 新建商户工厂实现类：

```java
/**
* 商户工厂
*/
public class MerchantFactory implements CustomerFactory {
    @Override
    public Customer createcustomer(string type, String name) {
        return new Merchant(type, name);
    }

    @Override
    public CustomerExt createcustomerExt() {
        return new MerchantExt();
    }
}
```

##### 新建银行客户工厂实现类：

```java
/**
* 银行客户工厂
*/
public class BankPartnerFactory implements CustomerFactory {
    @Override
    public Customer createcustomer(string type, string name) {
        return new BankPartner(type, name);
    }

    @Override
    public CustomerExt createcustomerExt() {
        return new BankPartnerExt();
    }
}
```

##### 新建代理商工厂实现类：

```java
/**
* 代理商工厂
*/
public class AgentFactory implements CustomerFactory {
    @Override
    public Customer createcustomer(string type, String name) {
        return new Agent(type, name);
    }

    @Override
    public CustomerExt createcustomerExt() {
        return new AgentExt();
    }
}
```

##### 新建测试类：

```java
public class Test {
  public static void main(string[] args) {
        System.out.println("------工厂模式-抽象工厂----------");

        CustomerFactory merchantFactory = new MerchantFactory();
        Customer merchant = merchantFactory.createCustomer("M", "Java技术栈商户");
        CustomerExt merchantExt = merchantFactory.createcustomerExt();
        System.out.println(merchant);
        System.out.println(merchantExt);

        CustomerFactory bankPartnerFactory = new BankPartnerFactory();
        Customer bankPartner = bankPartnerFactory.createCustomer("B", "Java技术栈银行客户");
        CustomerExt bankPartnerExt = bankPartnerFactory.createcustomerExt();
        system.out.println(bankpartner);
        System.out.println(bankpartnerExt);

        CustomerFactory agentFactory = new AgentFactory();
        Customer agent = agentFactory.createcustomer("A", "Java技术栈代理商");
        pCustomerExt agentExt = agentFactory.createcustomerExt();
        System.out.println(agent);
        System.out.println(agentExt);
    }
}
```

##### 输出结果：

![](/images/编程题/37.jpg)

可以看出，抽象工厂和工厂方法十分类似，只不过工厂方法里面只生产一个对象，而抽象工厂可以生产多个对象。

抽象工厂缺点也很明显，第一就是和工厂方法一样工厂类非常多，第二就是扩展非常麻烦，比如我现在要为每个客户类型再加一份客户特殊资料，那所有涉及到抽象工厂的工厂类都要改，是不是要疯了。。

## 38、编程实现静态代理 (真实应用案例)

##### 举例说明：

如我们想保存用户信息之前打印用户信息，或者保存用户信息之后把这些信息缓存下来，即在运行方法前后插入执行一个别的操作，下面是一个简单的示例。

##### 用户接口：

```java
public interface UserInterface {
    boolean saveuser(user user);
}
```

##### 用户接口实现：

```java
public class UserInterfaceImpl implements UserInterface {
    @override
    public boolean saveuser(User user) {
        System.out.println("保存用户：" + user.getName());
        return true;
    }
}
```

##### 静态代理类：

```java
public class StaticProxy implements UserInterface {

    private final Userinterface userinterface;

    public StaticProxy(Userinterface userInterface) {
    this.userinterface = userinterface;
    }

    @Override
    public boolean saveuser(User user) {
        System,out.println("静态代理-开始保存用户");
        boolean result = userinterface.saveuser(user);
        System.out.printIn("静态代理-保存用户结果："+result);
        System.out.printin();
        return result;
    }
}
```

##### 测试类：

```java
public class ProxyTest {

    /**
    * 测试静态代理
    */
    @Test
    public void teststaticproxy() {
        User user = new User();
        user.setName("tom");
        new StaticProxy(new userInterfaceImpl()).saveuser(user);
    }
}
```

##### 输出结果：

> 静态代理-开始保存用户
>
> 保存用户：tom
>
> 静态代理-保存用户结果：true

通过代码实战的方法学习设计模式，是不是觉得静态代理很简单了？

## 39、编程：用 JDK 实现动态代理(真实应用案例)

把静态代理中的示例用动态代理改编下：

##### 用户接口：

```java
public interface UserInterface {
  boolean saveuser(user user);
}
```

##### 用户接口实现：

```java
public class UserInterfaceImpl implements UserInterface {
  @Override
    public boolean saveuser(user user) {
        System.out.println("保存用户: " + user.getName());
        return true;
    }
}
```

##### JDK 动态代理类：

```java
public class JdkDynamicProxy {
    private static final InvocationHandler UsER_HANDLE = (proxy, method, args) -> {
        System.out,printIn("JDk接口动态代理-开始保存用户：“");
        Object result = method.invoke(new UserinterfaceImpl(), args);
        System,out.println("JDk接口动态代理-保存用户结果："+ result);
        System.out.println();
        return result;
    };

    public static UserInterface getuserProxy() {
        return (UserInterface) Proxy.newProxyInstance(JdkDynamicProxy.class.getclassLoader(),new Class[]{UserInterface.class}, USER_HANDLE);
    }
}
```

##### 测试类：

```java
public class ProxyTest {
    /**
    * 测试 JDK 动态代理
    */
    @Test
    public void testJDKProxy() {
        User user = new User();
        user.setName("tom");
        JdkDynamicProxy.getuserProxy().saveUser(user);
    }
}
```

##### 结果输出：

> JDK 接口动态代理-开始保存用户：
>
> 保存用户：tom
>
> JDK 接口动态代理-保存用户结果：true

### 40、编程：用 CGLib 实现动态代理（真实应用案例）

把静态代理中的示例用动态代理改编下：

##### 用户接口：

```java
public interface UserInterface {
    boolean saveuser(User user);
}
```

##### 用户接口实现：

```java
 public class UserInterfaceImpl implements UserInterface {
     @Override
     public boolean saveuser(user user) {
         System.out.println("保存用户: " + user.getName());
         return true;
     }
 }
```

##### Cglib 基于接口动态代理类实现：

```java
import org.springframework.cglib.proxy.InvocationHandler;
import org.springframework.cglib.proxy.Proxy;

public class CglibDynamicProxy {
    /**
    * CGLIB基于接口实现动态代理
    */
  private static final InvocationHandler INTERFACE_UsER_HANDLE = (proxy, method, args) -> {
        System.out.println("Cglib接口动态代理-开始保存用户");
        Object result = method.invoke(new UserInterfaceImpl(), args);
        System.out.println("Cglib接口动态代理-保存用户结果："+result);
        System.out.println();
        return result;
    };

    public static UserInterface getUserProxy() {
        return (UserInterface) Proxy.newProxyInstance(CglibDynamicProxy.class.getclassLoader(), new Class[]{UserInterface.class}, INTERFACE_USER_HANDLE);
    }
}
```

##### Cglib 基于类动态代理类实现：

```java
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;

public class CglibDynamicProxy {
    /**
    * CGLIB 基于类实现动态代理
    */
    private static final MethodInterceptor CLASS_USER_HANDLE = (obj, method, args, proxy) -> {
        System.out.println("cglib类动态代理-开始保存用户");
        Object result = proxy.invokesuper(obj, args);
        System.out.println("cglib类动态代理-保存用户结果："+result);
        System.out.println();
        return result;
    }

    public static Object getUserProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getclass());
        enhancer.setCallback(CLASS_USER_HANDLE);
        return enhancer.create();
    }
}
```

##### 测试类：

```java
public class ProxyTest {
    /**
    * 测试CGLIB 基于接口的动态代理
    */
    @Test
    public void testCglibInterfaceProxy() {
        User user = new User();
        user.setName("tom");
        CglibDynamicProxy.getUserProxy().saveUser(user);
    }

    /**
    * 测试CGLIB基于类的动态代理
    */
    @Test
    public void testcglibclassProxy() {
        User user = new User();
        user.setName("tom");
        UserInterfaceImpl userImpl = (UserInterfaceImpl) CglibDynamicProxy.getUserProxy(new UserInterfaceImpl());
        userImpl.saveUser(user);
    }
}
```

##### 输出结果：

> Cglib 接口动态代理-开始保存用户
>
> 保存用户：tom
>
> Cglib 接口动态代理-保存用户结果：true
>
> Cglib 类动态代理-开始保存用户
>
> 保存用户：tom
>
> Cglib 类动态代理-保存用户结果：true

## 41、编程实现观察者模式 (真实应用案例)

现在就来实现一个简单的观察者模式的应用场景，模拟公众号文章推送，观察目标是 R 哥我，观察者是你们大家，我在公众号 Java 技术栈推一篇文章，你们都能接收到更新通知并能阅读。

##### 新增观察目标类：

```java
import lombok.Getter;
import java.util.Observable;
@Getter
public class JavaStackobservable extends Observable {
    private String article;

    /**
    * 发表文章
    */
    public void publish(String article){
        //发表文章
        this.article = article;

        //改变状态
        this.setchanged();

        //通知所有观察者
        this.notifyobservers();
    }
}
```

观察目标的逻辑是先发表文章，再改变观察目标的状态，再通知所有观察者。

我们来重点看 notifyObservers 方法的源码：

![](/images/编程题/41_1.jpg)

先获取同步锁，判断状态是否更新，如已更新则清空观察目标状态，然后再使用 for 循环遍历所有观察者，一一调用观察者的更新方法通知观察者更新。

##### 新增观察者类：

```java
import lombok.NonNull;
import lombok.RequiredArgsconstructor;

import java.util.observable;
import java.util.observer;

@RequiredArgsConstructor
public class Readerobserver implements observer {
    @NonNul
    private String name;

    private String article;

    @Override
    public void update(observable o, Object arg) {
        //更新文章
        updateArticle(o);
    }

    private void updateArticle(observable o) {
        Javastackobservable javastackobservable = (Javastackobservable) o;
        this.article = javastackobservable.getArticle();
        System.out.printf("我是读者: %s, 文章已更新为: %s\n", this.name, this.article);
    }

}
```

观察者的逻辑是获取到观察者目标实例对象，然后再用观察目标对象的文章信息更新为自己的文章信息，最后输出某某某的文章已更新。

观察者只要实现 Observer 这个接口的 update 方法即可，用于观察目标进行调用通知。

##### 观察目标和观察者类结构图如下：

![](/images/编程题/41_2.jpg)

##### 新增测试类：

```java
public class ObserverTest {
    public static void main(string[] args) {
        //创建一个观察目标
        Javastackobservable javastackobservable = new Javastackobservable();

        //添加观察者
        javastackobservable.addobserver(new Readerobserver("小B月"));
        javastackobservable.addobserver(new Readerobserver("小张"));
        javastackobservable.addobserver(new Readerobserver("小爱"));

        //发表文章
        javastackobservable.publish("什么是观察者模式？");
    }
}
```

观察目标、观察者的创建并没有先后顺序要求，重点是发表文章通知观察者之前，观察目标要添加观察者列表这一步不能少。

输出结果：

![](/images/编程题/41_3.jpg)

通过这个简单的文章推送实践，大家应该对观察者模式有一个基本的认知了，在实际工作当中也可以有很多场景拿去用，就一对多的依赖关系都可以考虑使用观察者模式。

##### 总结

---

不容易啊，陆陆续续又肝了大半天，你学会观察者模式了吗？

观察者模式的优点是为了给观察目标和观察者解耦，而缺点也很明显，从上面的例子也可以看出，如果观察者对象太多的话，有可能会造成内存泄露。

另外，从性能上面考虑，所有观察者的更新都是在一个循环中排队进行的，所以观察者的更新操作可以考虑做成线程异步（或者可以使用线程池）的方式，以提升整体效率。

本节教程所有实战源码已上传到这个仓库：

> https://github.com/javastacks/javastack

## 42、编程实现策略模式(真实应用案例)

举个实际的例子，XX 公司是做支付的，根据不同的客户类型会有不同的支付方式和支付产品，比如：信用卡、本地支付，而本地支付在中国又有微信支付、支付宝、云闪付、等更多其他第三方支付公司，这时候策略模式就派上用场了。

传统的 if/else/ switch 等判断写法大家都会写，这里就不贴代码了，直接看策略模式怎么搞！

#### 1、定义策略接口

定义一个策略接口，所有支付方式的接口。

##### 策略接口：

```java
/**
* 支付接口
*/
public interface IPayment {
    /**
    * 支付
    */
    PayResult pay(order order);
}
```

##### 订单信息类：

```java
/**
* 订单信息
*/
@Data
public class order {
    /**
    * 金额
    */
     private int amount;

    /**
    * 支付类型
    */
     private String paymentType;
}
```

##### 返回结果类：

```java
@Data
@AllArgsConstructor
public class PayResult {

    /**
    * 支付结果
    */
    private string result;
}
```

#### 2、定义各种策略

定义各种支付策略，微信支付、支付宝、云闪付等支付实现类都实现这个接口。

##### 微信支付实现：

```java
/**
* 微信支付
*/
@Service("WechatPay")
public class WechatPay implements IPayment {
    @Override
    public PayResult pay(order order) {
        return new PayResult("微信支付成功");
    }
}
```

##### 支付宝实现：

```java
/**
* 支付宝
*/
@Service("Alipay") public class Alipay implements IPayment {
    @Override
    public PayResult pay(order order) {
        return new PayResuit("支付宝支付成功");
    }
}
```

##### 云闪付实现：

```java
/**
*
*/
@Service("unionPay")
public class UnionPay implements IPayment {
    @Override
    public PayResult pay(order order) {
        return new PayResult("云闪付支付成功");
    }
}
```

这里我把所有支付方式类都用 @Service 注解生成 Bean 放入 Spring Bean 容器中了，在使用策略的时候就不用 new 支付对象了，可以直接使用 Bean，这样更贴近业务。

#### 3、使用策略

有的文章使用了枚举、HashMap 的方式来根据策略名称映射策略实现类，这样是没有问题，但在使用了 Spring 框架的项目还是有点多此一举，完全可以发挥 Spring 框架的优势，使用 Bean 名称就能找到对应的策略实现类了。

参考示例代码如下：

```java
/**
* 支付服务
*/
@Restcontroller
public class Payservice {
    @Autowired
    private Applicationcontext applicationcontext;

    /**
    *
    */
    @RequestMapping("/pay")
    public PayResult pay(eRequestParam("amount") int amount, @Requestparam("paymentType") String paymentType) {
        Order order = new order();
        order.setAmount(amount);
        order.setPaymentType(paymentType);

        //根据支付类型获取对应的策路bean
        IPayment payment = applicationContext.getBean(order.getPaymentType(), IPayment.class);

        //开始支付
        PayResult payResult = payment.pay(order);
        return payResult;
    }
}
```

看示例代码，我并没有像策略模式结构图中那样新建一个 Context 类持有策略接口，那是标准的策略模式，其实道理是一样的，关键是怎么施放策略。

#### 4、测试一下

> http://localhost:8080/pay?amount=8800&paymentType=WechatPay

![](/images/编程题/42_1.jpg)

![](/images/编程题/42_2.jpg)

测试 OK，传入不同的支付方式会调用不同的策略。

## 43、编程实现模板方法模式（真实应用案例）

我们来把策略模式的案例再用模板方法模式加强一下，，做成模板方法，把支付流程按实现步骤一步步提取出去，抽象类只保留通用的支付步骤，然后和支付类型相关的步骤留给具体的支付子类去实现。

##### 定义抽象类

定义一个包含模板方法的抽象类，并定义一些固定的支付步骤：

```java
/**
* 模板方法模式-抽象支付类
*/
public abstract class AbstractPayment implements IPayment {
  /**
  * 支付方法 (模板方法)
  */
    @Override
    public PayResult pay(order order) {
        //校验支付参数
        CheckPaymentData(order);

        //风控检查
        checkRiskcontrol(order);

        //准备支付渠道数据（子类实现）
        preparePaymentchanneldata(order);

        //调用支付渠道接口（子类实现）
        PayResult payResult = callpaymentchannel(order);

        //校验支付结果(子类实现)
        checkPaymentResult(payResult);

        //发送支付结果通知消息
        sendPaymentResultNotification(payResult);

        return payResult;
    }

    /**
    * 校验支付参故
    */
    protected final void checkPaymentData(order order) {
        System.out.println("支付参数校验已通过！");
    }

    /**
    * 风控检查
    */
    protected final void checkRiskcontrol(order order) {
        System.out.printin("风控检查已通过！");
    }

    /**
    * 准备支付渠道数据（子类实现）
    */
    protected abstract void preparePaymentchannelData(order order);

    /**
    * 调用支付渠道接口（子类实现）
    */
    protected abstract PayResult callpaymentchannel(order order);

    /**
    * 校验支付结果(子类实现)
    */
    protected abstract void checkPaymentResult(PayResult payResult);

    /**
    * 发送支付结果通知消息
    */
    protected final void sendpaymentResultNotification(PayResult payResult) {
        System,out.println("支付结果通知消息已发送！");
    }
}
```

在这个抽象类中，模板方法包含了一系列的步骤，有几个抽象方法是需要支付子类去实现的。

##### 支付子类

如微信支付子类，继承抽象类：

```java
/**
* 微信支付
*/
 public class Wechatpay extends Abstractpayment {
     @Override
     protected void preparePaymentchannelData(order order) {
         System.out.println("准备微信支付数据");
     }

     @Override
     protected PayResult callpaymentchannel(order order) {
         System.out.printin("调用微信支付接口");
         return null;
     }

     @Override
     protected void checkpaymentResult(PayResult payResult) {
         System.out.,printin("检查微信支付结果");
     }
}
```

然后实现微信支付具体的支付子步骤即可，其他支付类型也是同样的逻辑，略。

##### 测试一下

写一个测试类测试一下：

```java
/**
* 支付服务
*/
@SpringBootTest
public class PaymentTest {
    @Test
    public void tesWechatpay() {
        order order = new order();
        order.setAmount(89);
        order.setPaymentType("wx");

        //微信支付
        IPayment wechatPay = new WechatPay();
        Wechatpay.pay(order);
    }

    @Test
    public void tesAlipay() {
        Order order = new order();
        order.setAmount(89);
        order.setPaymentType("alipay");
        //支付宝支付
        IPayment alipay = new Alipay();
        alipay.pay(order);
    }
}
```

微信支付输出结果：

> 付参数校验已通过！
>
> 风控检查已通过！
>
> 准备微信支付数据
>
> 调用微信支付接口
>
> 检查微信支付结果
>
> 支付结果通知消息已发送！

支付宝支付结果：

> 付参数校验已通过！
>
> 风控检查已通过！
>
> 准备支付宝支付数据
>
> 调用支付宝支付接口
>
> 检查支付宝支付结果
>
> 支付结果通知消息已发送！

可以看到，模板方法模式最大的好处就是定义固定步骤，复用公共逻辑代码，其他子类只需要实现自己的特定步骤即可，模板方法模式也可以很好的与一些常用的设计模式结合使用。

## 44、编程实现责任链模式（真实应用案例）

举个实际的例子，XX 公司是做支付的，根据不同的客户类型会有不同的支付方式和支付产品，比如：信用卡、本地支付，而本地支付在中国又有微信支付、支付宝、云闪付、等更多其他第三方支付公司。

之前我们用「策略模式」实现过，这里我以微信、支付宝、信用卡举例来演示，看看用责任链模式怎么来实现。

#### 1、定义支付请求类

这个支付包含所有支付参数，包括支付类型 type，其他略。

```java
@Data
@RequiredArgsconstructor
public class PaymentRequest {
    /**
    * 支付类型，1- WechatPay. 2- ALipay. 3 - Creditcard
    */
    final int type;
}
```

#### 2、定义处理器抽象类

定义一个处理器抽象类，包含处理器公共逻辑，以及一个抽象方法 process，抽象方法每个处理器实现类负责实现，这里其实也是模板设计模式的简单应用。

```java
/**
*
*/
@Data
@RequiredArgsconstructor
public abstract class PaymentHandler {
    /**
    * 支付类型
    */
    private final int type;

    /**
    * 下一个支付处理器
    */
    private PaymentHandler nextHandler;

    /**
    * 处理支付请求(模板方法)
    */
    public final void handleRequest(PaymentRequest paymentRequest) {
        if (paymentRequest.getType() == this.type) {
            System.out.println("找到对应的支付处理器");
            process(paymentRequest);
        } else {
            if (this.nextHandler != null) {
            System.out.println("没找到对应的支付处理器，转发给下一个支付处理器");
            this.nextHandler.handleRequest(paymentRequest);
            } else {
                System.out.printin("支付链处理完成。");
            }
        }
    }

    /**
    * 处理器实现类具体处理逻辑
    */
    protected abstract void process(PaymentRequest paymentRequest);
}
```

#### 3、定义各种处理器实现类

##### 微信支付处理器：

```java
/**
* 微信支付处理器
*/
public class WechatPayHandler extends PaymentHandler {
    public WechatPayHandler() {
        super(1);
    }

    @Override
    protected void process(PaymentRequest request) {
        System.out.println("正在处理微信支付");
        //支付处理逻辑
    }
}
```

##### 支付宝处理器：

```java
/**
* 支付宝处理器
*/
ublic class AlipayHandler extends PaymentHandler {
    public AlipayHandler() {
        super(2);
    }

    @Override
    protected void process(PaymentRequest request) {
        System,out.println("正在处理支付宝支付");
        //支付处理逻辑
    }
}
```

##### 信用卡处理器：

```java
/**
* 信用卡处理器
*/
public class CreditcardHandler extends PaymentHandler {
   public CreditcardHandler() {
       super(3);
   }

    @Override
    protected void process(PaymentRequest request) {
        System.out.println("正在处理信用卡支付");
        //支付处理逻辑
    }
}
```

##### 4、支付客户端

以下仅为测试客户端，实际业务中会有一个类来封装责任链关系。

```java
/**
* 支付客户端
*/
public class Paymentclient {
    public static void main(string[] args) {
        //创建责任链处理器
        PaymentHandler wechatPayPaymentHandler = new WechatPayHandler();
        AliPayHandler aliPayPaymentHandler = neW AliPayHandler();
        PaymentHandler creditcardHandler == new CreditcardHandler();

        //设置支付责任链
        WechatPayPaymentHandler.setNextHandler(aliPayPaymentHandler);
        alipayPaymentHandler.setNextHandler(creditcardHandler);

        //模拟支付宝支付请求
        System.out.println("开始支付宝支付请求");
        WechatPayPaymentHandler.handleRequest(new PaymentRequest(2));
        System.out.println("-----------");

        //模拟微信支付请求
        System.out.println("开始微信支付请求");
        wechatPayPaymentHandler.handleRequest(new PaymentRequest(1));
        System.out.println("-------");

        //模拟信用卡支付请求
        System.out.println("开始信用卡支付请求");
        wechatPayPaymentHandler.handleRequest(new PaymentRequest(3));
    }
}
```

##### 5、测试一下

运行支付客户端，结果输出如下：

> 始支付宝支付请求
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 找到对应的支付处理器
>
> 正在处理支付宝支付
>
> ---
>
> 开始微信支付请求
>
> 找到对应的支付处理器
>
> 正在处理微信支付
>
> ---
>
> 开始信用卡支付请求
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 找到对应的支付处理器
>
> 正在处理信用卡支付

责任链的顺序是：**微信->支付宝->信用卡**

可以看到，当我们发起多个不同的支付请求时，它总会从第一个支付处理器开始走，如果不匹配就转发给它的下一个支付处理器，直到找到匹配的支付处理器为止。

## 45、编程实现装饰器模式（真实应用案例）

##### 装饰器模式实战

---

我们把上面的装修的案例用装饰器模式实现一下。

##### 组件接口类：

```java
/**
* 墙面装修接口
*/
 public interface WallBeautify {
     /**
     * 装修操作
     */
     void operation();
 }
```

##### 组件接口的基本实现类：

```java
/**
* 墙面装修基本实现(清理墙面)
*/
 public class WallBeautifyclean implements WallBeautify {
     @Override
     public void operation() {
         System,out.println("开始清理墙面");
     }
 }
```

##### 装饰器角色类：

这是一个抽象类，实现并持有一个 Component 对象实例，这里使用的是聚合，而不是继承，这也是装饰器模式的要点所在。

```java
/**
* 墙面装修装饰器角色
*/
public abstract class WallBeautifyDecorator implements WallBeautify {

    /**
    * 持有一个component 对象实例
    */
    private WallBeautify wallBeautify;

    public WallBeautifyDecorator(wallBeautify wallBeautify) {
        this.wallBeautify = wallBeautify;
    }

    @Override
    public void operation() {
        WallBeautify.operation();
        decoration();
    }

    /**
    * 装饰器实现类自定义实现方法
    */
    public abstractt void decoration();
}
```

覆写原操作方法，在原操作之后再进行装饰，所以需要提供一个抽象的 decoration 方法供不同的装饰器的实现类去实现。

##### 装饰器的实现类：

这里定义了 3 个装修过程：

> 刮腻子>涂油漆>挂壁画

所以各自去继承 **装饰器角色类** 并实现其装饰方法：

```java
/**
* 墙面装修装饰器角色实现(刮腻子)
*/
 public class WallBeautifyPutty extends WallBeautifyDecorator {
     public WallBeautifyPutty(WallBeautify WallBeautify) {
         super(wallBeautify);
     }

     @Override
     public void decoration() {
         System.out.printin("开始刮腻子");
     }
 }
```

```java
/**
* ：墙面装修装饰器角色实现(涂油漆)
*/
 public class WallBeautifypaint extends WallBeautifyDecorator {
     public WallBeautifyPaint(WallBeautify WallBeautify) {
         super(wallBeautify);
     }

     @Override
     public void decoration() {
         System.out.println("开始涂油漆");
     }
 }
```

```java
/**
* 墙面装修装饰器角色实现(挂壁画)
*/
public class WallBeautifyHang extends WallBeautifyDecorator {
    public WallBeautifyHang(WallBeautify wallBeautify) {
        super(wallBeautify);
    }

    @Override
    public void decoration() {
        System.out.println("开始挂壁画");
    }
}
```

##### 测试一下：

```java
/**
* 装饰器模式测试类
*/
public class DecoratorTest {
    public static void main(string[] args) {
        //清理墙面
        WallBeautify wallBeautifyclean :new WallBeautifyclean();
        WallBeautifyclean.operation();
        System.out.printin("-------------");

        //刮腻子
        WallBeautify wallBeautifyPutty = new WallBeautifyPutty(wallBeautifyclean);
        WallBeautifyPutty.operation();
        System.out.printin("-------------");

        //涂油漆
        WallBeautify wallBeautifyPaint = new WallBeautifyPaint(wallBeautifyPutty);
        WallBeautifyPaint.operation();
        System.out.printin("-------------");

        //挂壁画
        WallBeautify wallBeautifyHang = new WallBeautifyHang(wallBeautifyPaint);
        WallBeautifyHang.operation();
        System.out.printin("-------------");

        //多层嵌套
        WallBeautify wbh = new WallBeautifyHang(
            new WallBeautifyPaint(
                new WallBeautifyPutty(
                    new WallBeautifyClean()
                )
            )
        );
    }
}
```

本节教程所有实战源码已上传到这个仓库：

> https://github.com/javastacks/javastack

输出结果：

> 开始清理墙面
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> 开始挂壁画
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> 开始挂壁画
>
> ---

结果输出正常！

可以看到，装饰器模式的使用还是相对比较简单的，使用装饰器模式可以达到不同的装饰效果，这样即满足了不同客户的需求，而又不用改动原有的代码，还是挺香的。

## 46、编程：使用 SpringAOP 实现一个切面编程功能

> 有一个数字计算服务，要求使用 Spring AOP &Aspect 实现该计算服务的切面编程。

> 本示例代码基于 Spring Boot 3.x

##### 1、添加 Spring AOP 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupid>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

##### 2、创建计算服务接口和实现类：

```java
/**
* 计算服务接口
*/
public interface Calcservice {
  int divide(int x, int y);
}
```

```java
/**
* 计算服务实现
*/
@service
public class CalcserviceImpl implements Calcservice {
    @override
    public int divide(int x, int y) {
        System.out.println("===--== Calcservice 被调用了");
        int result = x / y;
        System.out.println("-Calcservice 调用成功");
        return result;
    }
}
```

##### 3、创建一个切面类

使用 Aspect 注解定义切点和通知：

```java
/**
* 计算切面
*/
@Aspect
@Component
public class CalcAspect {
    @Pointcut("execution(* cn.javastack.springboot.aop.service.CalcService.*(..))")
    private void pointcut() {}

    @Before("pointcut()")
    public void before() {
        System.out.println("************@Before 前置通知");
    }

    @After("pointcut()")
    public void after() {
        System.out.println("*********@After 后置通知")；
    }

    @AfterReturning("pointcut()")
    public void afterReturning() {
        System.out.println("*******@AfterReturning 返回通知");
    }

    @AfterThrowing("pointcut()")
    public void afterThrowing() {
        System.out.println("********@AfterThrowing 异常通知");
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object result;
        System.out.println("环绕通知之前");
        result = proceedingJoinPoint.proceed();
        System.out.println("环绕通知之后");
        return result;
    }
}
```

在切面类中，使用 @Aspect 注解标识这是一个切面类，使用 @Pointcut 注解定义切点，使用 @Before、@AfterReturning、@AfterThrowing、@After、@Around 注解定义通知。

##### 4、创建一个测试接口

写一个接口测试下：

```java
@RequiredArgsConstructor
@RestController
public class CalcController {
    private final Calcservice calcService;

    @GetMapping("/calc/divide")
    public int divide(@RequestParam("param1") int param1,
                      @RequestParam("param2") int param2) {
        return calcservice.divide(paraml, param2);
    }
}
```

##### 访问接口（正常返回）：

> http://localhost:8080/calc/divide?param1=30&param2=3

输出结果：

> `环绕通知之前`
>
> `*******@Before 前置通知`
>
> `========CalcService 被调用了`
>
> `========CalcService 调用成功`
>
> `*******@AfterReturning 返回通知`
>
> `*******@After后置通知`
>
> `环绕通知之后`

##### 访问接口（发生异常）：

> http://ocalhost:8080/calc/divide?param1=30&param2=0

> `环绕通知之前`
>
> `******@Before 前置通知`
>
> `=====CalcService 被调用了`
>
> `******@AfterThrowing 异常通知`
>
> `******@After 后置通知`
>
> 异常信息。。

## 47、编程输出九九乘法表

用 Java 编程打印出九九乘法表：

![](/images/编程题/47.jpg)

---

##### 示例代码：

```java
/**
* 九九乘法表
*/
public class Haskell {
    public static void main(string[] args) {
        for (int i = 1; i <= 9; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print(j + "*" + i + "=" + (i * j) + "\t");
            }
            System.out.println();
        }
    }
}
```

## 48、编程输出 100 以内所有的素数

用 Java 编程输出 100 以内所有的素数个数，并输出所有的素数。

> 素数：又称为质数，它指的是只能被 1 和被自己整除的整数，其中，1 不是素数。

---

##### 示例代码：

```java
/**
*
*/
public class PrimeNumber {
    public static void main(string[] args) {
        int count = 0;
        for (int i = 2; i < 100; i++) {
            boolean isPrime = true;
            for （int j = 2; j< i; j++）{
                if (i % j == θ) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                count++;
                System.out.print(i);
                System.out.print(" ");
            }
        }
    System.out.println();
    System.out.println("108 以内的素数个数是："+count);
    }
}
```

##### 输出结果：

2 3 5 7 11 13 17 19 23 29 3137 41 43 47 53 59 61 67 7173 79 83 89 97

100 以内的素数个数是：25

## 49、编程输出 1000 以内所有的水仙花数

用 Java 编程输出 1000 以内所有的水仙花数个数，并输出所有的水仙花数。

> 水仙花数：是指一个 n 位数（n>=3），它的每个位上的数字的 n 次幂之和等于它本身。
>
> 例如 153 是一个水仙花数，1^3+5^3+3^3=153

---

##### 示例代码：

```java
/**
* 输出1000以内所有的水仙花数
*/
public class NarcissisticNumber {
    public static void main(String[] args) {
        int ge, shi, bai;
        int count = 0;
        for (int i = 100; i < 1000; i++) {
            ge = i % 10;
            shi = i / 10 % 10;
            bai =i / 100;
            int result = (int) (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3));
            if (i == result) {
                System.out.print(i);
                System.out.print(" ");
                count++;
            }
        }
        System.out.println();
        System.out.println("1eee 以内的水仙花数个数是："+count);
    }
}
```

##### 输出结果：

153 370 371 407

1000 以内的水仙花数个数是：4

## 50、编程统计出不同类型的字符个数

给定一行字符，用 Java 编程，分别统计并输出其中英文字母、数字、空格、其它字符的个数。

---

##### 示例代码：

```java
/**
*
*/
public class Charstastics {
    public static void main(String[] args) {
        String str = "19ds$^sljd 2341@06qdj8^&*Q e0sdcka2385 -1!~er,s92";
        char[] chars = str.toCharArray();

        int englishcount = 0;
        int spaceCount = 0;
        int digitcount = 0;
        int otherCount = 0;

        for (int i = 0; i < str.length(); i++) {
            if (Character.isletter(chars[i])) {
                englishcount++;
                continue;
            }
            if (Character.isDigit(chars[i])) {
                digitcount++;
                continue;
            }
            if（(Character.isSpaceChar(chars[i])) {
                spaceCount++;
                continue;
            }
            otherCount++;
        }

        System.out.println("英语字母个数为："+ englishcount);
        System.out.println("数字个数为："+ digitcount);
        System.out.println("空格个数为："+ spaceCount);
        System.out.println("其他字符个数为："+otherCount);
    }
}
```

##### 输出结果：

英语字母个数为：19

数字个数为：17

空格个数为：3

其他字符个数为：10

## 51、编程计算出 1-100 之间的和

用 Java 编程，以及递归算法，计算出 1-100 之间的和。

---

##### 示例代码：

```java
/**
* 递归求和
*/
public class RecursionSum {
    public static void main(string[] args) {
        System.out.println("1-100 递归求和结果为："+ sum(1ee));
    }

    public static int sum(int num) {
        if (num == 1) {
            return 1;
        }
        return num + sum(num - 1);
    }
}
```

##### 输出结果：

1-100 递归求和结果为：5050

## 52、编程输出只出现过一次的数

给定一个整型数组，用 Java 编程，计算并输出其中只出现过一次的数。

---

##### 示例代码：

```java
/**
* 只出现过一次的数
*/
public class OneNumber {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 39, 2, 39, 2, 1, 2, 9, 3, 33, 13, 33};
        for (int i = 0; i < arr.length; i++) {
            int num = 0;
            for (int j = 0; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    num++;
                }
            }
            if (num == 1) {
                System.out.println("这个数只出现了一次："+arr[i]);
            }
        }
    }
}
```

##### 输出结果：

这个数只出现了一次：9

这个数只出现了一次：3

这个数只出现了一次：13

## 53、编程实现数组排序（冒泡排序）

给定一个整形数组，用 Java 编程实现冒泡排序升序排列。

> ##### 冒泡排序：
>
> 依次比较两个相邻的数字，若发现逆序则交换，越小的数字经过不慢交换会慢慢“浮"到数组的顶端（升序），就如同水底的气泡往上冒一样，最终会上浮到顶端，故名：“冒泡排序"。

---

##### 示例代码：

```java
/**
* 冒泡排序
*/
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = { 28, 21, 3, 1, 6, 66, 5, 33, 2, 19 };
        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");
        bubbleSort(arr);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }


    private static void bubblesort(int[] arr) {
        int temp;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j< arr.length - 1 - i; j++) {
                if (arr[j] >arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
             System.out.println();
        }
    }

}
```

##### 输出结果：

![](/images/编程题/53.jpg)

## 54、编程实现数组排序 (快速排序)

给定一个整形数组，用 Java 编程实现快速排序升序排列。

> ##### 快速排序：
>
> 快速排序是对冒泡排序的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

---

##### 示例代码：

```java
/**
* 快速排序
*/
public class Quicksort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");
        quicksort(arr, 0, arr.length - 1);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    public static void quicksort(int arr[], int low, int high) {
        int pivot, pos, i, t;
        if (low < high) {
            pos = low;
            pivot = arr[pos];
            for (i = low + 1; i <= high; i++) {
                if (arr[i]< pivot) {
                    pos++;
                    t = arr[pos];
                    arr[pos] = arr[i];
                    arr[i] = t;
                }
            }
            t = arr[low];
            arr[low] = arr[pos];
            arr[pos] = t;

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.println();

            //分而治之
            //排序左半部分
            quicksort(arr, low, pos - 1);

            //排序右半部分
            quicksort(arr, pos + 1, high);
        }
    }
}
```

##### 输出结果：

![](/images/编程题/54.jpg)

## 55、编程实现数组排序（选择排序）

给定一个整形数组，用 Java 编程实现选择排序升序排列。

> ##### 选择排序：
>
> 第一次从待排序的数据中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。
>
> 选择排序是不稳定的排序方法。

---

##### 示例代码：

```java
/**
* 选择排序
*/
public class Selectsort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为:");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

    //输出排序过程
    System.out.println();
    System.out.println("正在排序...");

         selectSort(arr);

         //排序后输出结果
         System.out.println("排序后为：");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t")
         }
    }

         private static void selectsort(int[] arr) {
             int temp;
             for (int j = 0; j < arr.length - 1; j++) {
                 int min = arr[j];
                 int minIndex = j;
                 for (int k = j + 1; k < arr.length; k++) {
                     if (min > arr[k]) {
                         min = arr[k];
                         minIndex = k;
                     }
                 }
                 temp = arr[j];
                 arr[j] = arr[minIndex];
                 arr[minIndex] = temp;

                 for (int k = 0; k < arr.length; k++) {
                     System.out.print(arr[k] + "\t");
                 }
                 System.out.println();
             }
         }
}
```

##### 输出结果：

![](/images/编程题/55.jpg)

## 56、编程实现数组排序 (插入排序)

给定一个整形数组，用 Java 编程实现插入排序升序排列。

> ##### 插入排序：
>
> 插入排序是指在待排序的元素中，假设前面 n-1(其中 n>=2)个数已经是排好顺序的，现将第 n 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第 n 个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

---

##### 示例代码：

```java
/**
* 插入排序
*/
public class Insertionsort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        insertionsort(arr);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    public static void insertionsort(int arr[]) {
        int i, j, t;
        for (i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                t = arr[i];
                for (j = i - 1; j >= θ & t<arr[j]; j--) {
                    arr[j + 1] = arr[j];
                }

                //插入到适当位置
                arr[j + 1] = t;

                for (int k = O; k < arr.length; k++) {
                    System.out.print(arr[k] + "\t");
                }
                System.out.println();
            }
        }
    }
}
```

##### 输出结果：

![](/images/编程题/56.jpg)

## 57、编程实现数组排序 (希尔排序)

给定一个整形数组，用 Java 编程实现希尔排序升序排列。

> ##### 希尔排序：
>
> 希尔排序是插入排序的一种又称缩小增量排序，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法。
>
> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

---

##### 示例代码：

```java
/**
* 希尔排序
*/
public class Shellsort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        shellsort(arr);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    public static void shellsort(int[] arr) {
        int j, temp;
        for (int incr = arr.length / 2; incr > 0; incr /= 2) {
            for (int i = incr; i < arr.length; i++) {
                temp = arr[i];
                for (j = i; j >= incr; j -= incr) {
                    if (temp < arr[j - incr]) {
                        arr[j] = arr[j - incr];
                    } else {
                        break;
                    }
                }
                arr[j] = temp;
                for (int k = 0; k< arr.length; k++) {
                    System.out.print(arr[k] + "\t");
                }
                System.out.println();
            }
        }
    }
}
```

##### 输出结果：

![](/images/编程题/57.jpg)

## 58、编程实现数组排序(二分排序)

给定一个整形数组，用 Java 编程实现二分排序升序排列。

> ##### 二分排序：
>
> 二分排序是指利用二分法的思想对插入排序进行改进的一种插入排序算法，不同于二叉排序，可以利用数组的特点快速定位指定索引的元素。
>
> 二分法插入排序是在插入第 i 个元素时，对前面的 0 ～ i-1 元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到 eft>right，然后再把第 i 个元素前 1 位与目标位置之间的所有元素后移，再把第 i 个元素放在目标位置上。

---

##### 示例代码：

```java
package cn.javastack.test.example.sort;
/**
* 二分排序
*/
public class Binarysort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        binarySort(arr);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void binarysort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int index = binaryFind(o, i - 1, arr[i], arr);
            insert(index, i, arr[i], arr);

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.println();
        }
    }

    private static int binaryFind(int leftIndex, int rightIndex, int val, int[] arr) {
        int midIndex = ((rightIndex + leftIndex) / 2);
        int midval = arr[midIndex];

        if (rightIndex >= leftIndex) {
            if (midval > val) {
                return binaryFind(leftIndex, midIndex - 1, val, arr);
            } else if (midval < val) {
                return binaryFind(midIndex + 1, rightIndex, val, arr);
            } else if (midval == val) {
                return midIndex + 1;
            }
        } else {
            return leftIndex;
        }
        return -1;
    }

    private static void insert(int index, int last, int value, int[] arr) {
        int i = last - 1;
        while (index <= i){
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = value;
    }
}
```

##### 输出结果：

![](/images/编程题/58.jpg)

## 59、编程实现数组排序 (归并排序)

给定一个整形数组，用 Java 编程实现归并排序升序排列。

> ##### 归并排序：
>
> 归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用。

---

##### 示例代码：

```java
/**
* 归并排序
*/
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        mergesort(arr, 0, arr.length - 1);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void mergesort(int[] arr, int start, int end) {
        if (start<end) {
            int m = (start + end) / 2;

            mergeSort(arr, start, m);
            mergeSort(arr, m + 1, end);

            merge(arr, start, m, end);

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.println();
        }
    }

            public static void merge(int[] arr, int start, int m, int end) {
                int length = end - start + 1;
                int temp[] = new int[length];

                int i = start;
                int j = m + 1;
                int k =0;

                while (i <= m && j <= end) {
                    if (arr[i] < arr[j]) {
                        temp[k++] = arr[i++];
                    } else {
                        temp[k++] = arr[j++];
                    }
                }

                while (i <= m) {
                    temp[k++] = arr[i++];
                }

                while (j <= end) {
                    temp[k++] = arr[j++];
                }

                k = 0;
                for (int t = start; t <= end; t++) {
                    arr[t] = temp[k++];
                }
            }
}
```

##### 输出结果：

![](/images/编程题/59.jpg)

## 60、编程实现数组排序 (堆排序)

给定一个整形数组，用 Java 编程实现堆排序升序排列。

> ##### 推排序：
>
> 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

---

##### 示例代码：

```java
/**
* 堆排序
*/
public class Heapsort {
    public static void main(String[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        heapsort(arr);

        //排序后输出结果
        System.out.println("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void heapsort(int arr[]) {
        for (int i = 0; i < arr.length; i++) {
            heap(arr, arr.length - 1 - i);
            Swap(arr, 0, arr.length - 1 - i);

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.println();
        }
    }

    private static void heap(int[] data, int last) {
        for (int i = last / 2; i >= 0; i--) {
            int parent = i;
            while (2 * parent + 1 <= last) {
                int bigger = 2 * parent + 1;
                if (bigger < last){
                    if (data[bigger] < data[bigger + 1]) {
                        bigger = bigger + 1;
                    }
                }
                if (data[parent] < data[bigger]) {
                    Swap(data, parent, bigger);
                    parent = bigger;
                }else {
                    break;
                }
            }
        }
    }

    private static void swap(int[] data, int i, int j) {
        if (i == j) {
            return;
        }
        data[i] = data[i] + data[j];
        data[j] = data[i] - data[j];
        data[i] = data[i] - data[j];
    }
}
```

##### 输出结果：

![](/images/编程题/60.jpg)

## 61、编程实现一个雪花算法

完整 Java 实现如下：

```java
public class SnowFlake {
    /**
    * 起始的时间戳
    */
    private final static long START_STMP = 1480166465631L;

    /**
    * 每一部分占用的位数
    */
    private final static long SEQUENCE_BIT = 12; //序列号占用的位数
    private final static long MACHINE_BIT = 5;//机器标识占用的位数
    private final static long DATACENTER_BIT = 5;//数据中心占用的位数

    /**
    * 每一部分的最大值
    */
    private final static long MAX_DATACENTER_NUM = -1L ^ (-1l << DATACENTER_BIT);
    private final static long MAX_MACHINE_NUM = -1L ^ (-1L << MACHINE_BIT);
    private final static long MAX_SEQUENCE = -1L ^(-1L << SEQUENCE_BIT);

    /**
    * 每一部分向左的位移
    */
    private final static long MACHINE_LEFT = SEQUENCE_BIT;
    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;
    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;

    private long datacenterId;//数据中心
    private long machineId;//机器标识
    private long sequence = 0L;//序列号
    private long lastStmp = -1L;//上—次时间戳

    public SnowFlake(long datacenterId, long machineId) {
        if (datacenterId > MAX_DATACENTER_NUM II datacenterId < 0) {
            throw new IllegalArgumentException("datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0");
        }
        if (machineId > MAX_MACHINE_NUM Il machineId < O) {
            throw new IllegalArgumentException("machineId can't be greater than MAx_MAcHINE_NUM or less than 0");
        }
        this.datacenterId = datacenterId;
        this.machineId = machineId;
    }

    /**
    * 产生下一个ID
    */
    public synchronized long nextId() {
        long currStmp = getNewstmp();
        if (currStmp <laststmp) {
            throw new RuntimeException("clock moved backwards. Refusing to generate id");
        }
        if (currstmp == laststmp) {
            //相同毫秒内，序列号自增
            sequence = (sequence + 1) & MAX_SEQUENCE;
            //同一毫秒的序列数已经达到最大
            if (sequence == 0L) {
                currStmp = getNextMill();
            }
        } else {
            //不同毫秒内，序列号置为0
            sequence = 0L;
        }

        laststmp = currStmp;

        return（currStmp－START_STMP）<< TIMESTMP_LEFT
            //时间戳部分
            | datacenterId << DATACENTER_LEFT  //数据中心部分
            | machineId << MACHINE_LEFT        //机器标识部分
            sequence;                          //序列号部分
    }

    private long getNextMill() {
        long mill = getNewstmp();
        while (mill <= lastStmp) {
            mill = getNewstmp();
        }
        return mill;
    }

    private long getNewstmp() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        SnowFlake snowFlake = new SnowFlake(2, 3);

        for (int i = 0; i < (1 << 12); i++) {
             System.out.println(snowFlake.nextId());
        }
    }
}
```

> 参考开源工具类:https://github.com/beyondfengyu/SnowFlake
