## 1、为什么要学习数据结构和算法？

个人觉得有以下几点：

1）面试必备：编程基本功，进大厂基本是必问的，可能现场考算法题；

2）训练思维逻辑，形成时间复杂度、空间复杂度思维，能帮你写出性能更好、更优的代码，也能提升看问题的角度及深度；

3）提升个人的核心竞争力，不要只会写 CRUD 代码，工资上不去；

## 2、什么是数据结构？

数据结构是计算机系统存储、组织数据的方式。

数据结构是指一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合，结构就是指数据元素之间的关系。

## 3、数据结构有什么用？

使用恰当的数据结构可以提升程序运行效率、存储效率。

比如：

1）JDK 不同的集合就使用了数组、队列、链表、树等不同的数据结构。

2）MySQL 数据库中的索引就使用了“**树**”这种数据结构，用于提升 IO 存储效率和查询效率。

等等。。

## 4、数据结构按逻辑结构分为几大类？

逻辑结构是指：**数据元素之间的逻辑关系**，主要分为 **线性结构** 和 **非线性结构** 两大类。

##### 也有这种分法：

##### 1、集合结构

集合结构中的元素之间是“同属一个集合”的关系，别无其他关系。

##### 2、线性结构

线性结构中的元素是一对一的相互关系。

##### 3、树形结构

树形结构中的元素是一对多的相互关系。

##### 4、图形结构

图形结构中的元素是多对多的相互关系。

## 5、数据结构按物理结构分为几大类？

物理结构是指：**数据在计算机中的存储形式**，具体可分为以下几类：

- 顺序存储
- 链式存储
- 索引存储
- 散列存储

一种数据结构可表示一种或多种物理结构。

## 6、常用的数据结构有哪些？

##### 常用的数据结构有：

- 数组(Array)
- 栈(Stack)
- 队列(Queue)
- 链表( Linked List)
- 散列表 (Hash)
- 树(Tree)
- 堆(Heap)
- 图(Graph)

## 7、JDK 中都用到了哪些数据结构？

**Vector**：数组

**Stack**：栈，底层是数组

**ArrayList**：数组

**LinkedList**：双向链表

**HashSet**：数组+链表

**HashMap**：数组+链表/红黑树

**ConcurrentHashMap**：数组+链表/红黑树

**TreeMap**：红黑树

**Queue**：队列

等等。。

## 8、常用的线性数据结构有哪些？

常用的线性数据结构有：线性表，栈，队列，循环队列，一维数组等。

## 9、常用的非线性数据结构有哪些？

常用的非线性数据结构有：二维数组、多维数组、广义表、树、图等。

## 10、什么是数组？

数组（Array）是一个有序的元素序列，是一组连续的内存空间，数组是用于储存多个相同类型数据的集合，可以有一维、二维以及多维等表现形式。

![](/images/数据结构和算法/10.jpg)

数组可以有不同的定义类型，如：整型数组、字符串数组、浮点型数组、引用数组等，数组中的元素可以重复。

## 11、数组的优缺点？

##### 优点：

查找速度快 (包括随机查找)

##### 缺点：

1）大小固定，可能浪费空间，不方便扩展；

2）需要连续内存空间，对内存要求高；

3）修改、删除效率慢；

## 12、数组为什么都是从 0 开始编号，而不是从 1 呢？

比如有以下 4 个元素的数组：

> int[] arr = new int[4];

计算机会在内存中随机分配一个首地址，后面再连续分配 16 个字节，每个数组元素占 4 个字节：

> 第一个数组元素 a[0] 起始地址：首地址+偏移地址 0*4 字节；*
>
> *第二个数组元素 a[1] 起始地址：首地址+偏移地址 1*4 字节；
>
> 第三个数组元素 a[2] 起始地址：首地址+偏移地址 2*4 字节；*
>
> *第四个数组元素 a[3] 起始地址：首地址+偏移地址 3*4 字节；

如果数组从 1 开始：

> 第一个数组元素 a[1] 起始地址：首地址+（1-1）_4 字节；_
>
> *第二个数组元素 a[2] 起始地址：首地址+（2-1）*4 字节；
>
> 第三个数组元素 a[3] 起始地址：首地址+（3-1）_4 字节；_
>
> *第四个数组元素 a[4] 起始地址：首地址+（4-1）*4 字节；

从 1 开始总要多一步减法运算，所以从 0 开始更高效，数组从 0 开始是 C 语言设计的，现在的高级语言也都保持了 C 语言数组从 0 开始的习惯。

## 13、什么是栈？

栈是一种受限的线性表，只能在表的固定一端进行插入和删除操作，称为栈顶，另外一端则称为栈底。

栈是按照先进后出（First In Last Out）FILO 的原则存储数据的，数据按进入顺序依次被压入栈底，最后进入的数据在栈顶，所以越晚进入栈的数据就越先从栈中出来。

![](/images/数据结构和算法/13.jpg)

从栈中插入新数据叫：进栈、入栈或压栈，从栈中删除数据叫：出栈。

## 14、什么是链表？

链表是一种按照链式存储结构进行存储数据元素的数据结构。

链表中的每个节点不但包含数据本身，还包含下一个数据元素的指针，数据元素在物理空间上可能是非连续的，逻辑顺序是通过链表中的指针链接顺序来实现的。

![](/images/数据结构和算法/14.jpg)

链表中的数据可能包含重复。

## 15、链表分为哪几类？

##### 链表可以分 3 类：

![](/images/数据结构和算法/15_1.jpg)

##### 1、单链表

单链表中的元素只能指向下一个元素或者指向空，元素之间不能相互指向。

##### 2、双链表

双链表中的每个元素既能指向下一个元素，又能指向上一个元素。

##### 3、循环链表

循环链表是指两种链表中的最后一个节点都指向第一个节点。

![](/images/数据结构和算法/15_2.jpg)

## 16、链表的优缺点？

##### 优点：

1）大小不固定，可灵活扩展；

2）内存利用率高，不会浪费内存；

3）插入、删除效率快；

##### 缺点：

随机查找效率低

## 17、数组和链表的区别？

主要有以下 3 点区别：

1）数组的长度是固定的，链表是动态增减的；

2）数组内存是定义时分配的，链表是运行时申请分配的；

3）数组中的元素顺序由下标确定，链表中的元素顺序由上下节点确定；

## 18、数组和链表怎么选？

##### 使用数组：

经常需要快速查询检索数据，很少对数据进行修改、删除，比如可以使用：ArrayList。

##### 使用链表：

经常需要修改、删除数据，很少查询检索数据，比如可以使用：LinkedList。

## 19、什么是跳表？

跳表，也叫跳跃表，全称为：**SkipList**，是一个用于有序元素序列、快速搜索的随机化的数据结构，它的每个节点通过持有多个其他节点的指针，从而能实现快速搜索节点的目的。

跳表可以在很多应用场景中替代平衡树，跳表的算法与平衡树相比，实现要更简单，并且对于小量数据存储，跳表的性能要更好，占用的内存空间也更少。

> 跳表的平均时间复杂度为：**O(logN)**，最坏复杂度为：**O(N)**，所以其性能可以与平衡树相媲美。

跳跃表主要由以下几部分构成：

| 组成部分    | 说明                             |
| ----------- | -------------------------------- |
| 表头(head)  | 负责维护跳跃表的节点指针         |
| 节点 (node) | 保存元素值，每个节点有一层或多层 |
| 层(level)   | 保存着指向该层下一个节点的指针   |
| 表尾 (tail) | 全部由 NULL 组成，表示跳跃表末尾 |

跳表是在「有序链表」的基础上发展起来的：

![](/images/数据结构和算法/19_1.jpg)

![](/images/数据结构和算法/19_2.jpg)

跳跃表由很多**「层」**组成的，每一层都是一个有序的集合，最底层的链表包含了所有的元素。跳跃表的遍历也总是从高层开始的，然后随着元素值范围的缩小，慢慢降低到低层。

## 20、什么是队列？

队列是一种受限的线性表，队列只能在表的一端（队尾）插入数据，在表的另外一端（队头）删除数据。

队列是按照先进先出（First In First Out）FIFO 的原则存储数据的，所以越早进入队列的数据就越先从队列中出来。

![](/images/数据结构和算法/20.jpg)

从队列中插入数据叫：入队，从队列中删除一个数据叫：出队。

## 21、栈和队列的区别？

##### 主要区别：

栈是先进后出（First In Last Out）FILO，队列是先进先出（First In First Out）FIFO；

![](/images/数据结构和算法/21.jpg)

栈只能在表的一端进行插入和删除，队列只能在表一端进行插入，在表另一端进行删除。

## 22、什么是线性表？

线性表则是在内存中数据的一种组织、存储的方式。

一个线性表是 n 个具有相同特性的数据元素的有限序列，线性表中数据元素之间是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。

## 23、什么是顺序表？

顺序表是在计算机内存中以数组形式存储的线性表，采用顺序存储结构，将表中元素一个接一个的存入一组连续的存储单元中，线性表中的元素数据的逻辑顺序与物理顺序一致。

## 24、线性表分为哪两大类？

##### 线性表分为两大类：

##### 1、一般线性表

就是指我们通常所说的“线性表”，可以自由删除或添加节点。

##### 2、受限线性表

受限表示对节点的操作受限制，主要包括栈和队列。

## 25、线性表有哪几种存储结构？

##### 线性表有两种存储结构：

##### 顺序存储结构：

读取较快，插入删除较慢。

##### 链式存储结构：

读取较慢，插入删除较快。

## 26、常用的线性表数据结构有哪些？

常用的属于线性表的数据结构有：数组、栈、队列、链表。

![](/images/数据结构和算法/26.jpg)

## 27、线性表和链表有什么关系？

线性表是数据结构中的逻辑结构，当采用顺序存储结构时，称为 顺序表，当采用链式存储结构时，称为 链表。

所以，线性表以不同的存储形式可以包括：顺序表和链表。

## 28、数组是线性表吗？

##### 可以说是，但这两者并没有从属关系。

线性表是一种抽象的数据结构，数组是一种具体的、物理的存储数据的数据结构。

线性表即可以用数组实现，也可以用链表实现，数组既可以实现线性表，也可以实现树、图等。

## 29、什么是树？

树是一个由 n(n >= 1) 个有限节点组成的具有层次关系的集合。

为什么叫树，是因为数据结构中的每个节点有零个或多个子节点，看起来就像一棵倒挂的树，树是由根节点和若干颗子树组成的。

![](/images/数据结构和算法/29.jpg)

没有父节点的节点称为根节点，一个树有且只有一个根节点。

每一个子节点有且只有一个父节点，每一个子节点又可以分为多个不相交的子树。

## 30、常用的树数据结构有哪些？

常用的树数据结构有：

![](/images/数据结构和算法/30.jpg)

## 31、什么是二叉树？

二叉树（Binary tree）是 n 个有限元素的集合，是一种树中节点的度不大于 2 的有序树（只能是 0、1、2）。

如图所示：

![](/images/数据结构和算法/31.jpg)

## 32、常用的二叉树数据结构有哪些？

常用的二叉树数据结构有：

![](/images/数据结构和算法/32.jpg)

所有数据结构全系完整高清版，请关注公众号 Java 技术栈，在后台回复：数据结构

## 33、什么是满二叉树？

如果二叉树中最后一层无任何子节点，且其他每一层上的所有节点都有两个子节点，即每个节点的度都为 2，则此二叉树可以称为：**满二叉树**。

如图所示：

![](/images/数据结构和算法/33.jpg)

## 34、什么是完全二叉树？

完全二叉树是由满二叉树而引出来的，如果二叉树中除了最后一层外，其他各层的节点都达到最大个数 2 个，且最后一层的所有节点依次从左到右分布，则此二叉树被称为完全二叉树。

如图所示：

![](/images/数据结构和算法/34.jpg)

## 35、满二叉树和完全二叉树的区别？

满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。

![](/images/数据结构和算法/35.jpg)

## 36、什么是二叉查找树？

二叉查找树（Binary Search Tree），又叫二叉搜索树，或者二叉排序树（Binary Sort Tree）。

它是一棵空树，或者是具有下列性质的二叉树：

1）若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

2）若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

3）它的左、右子树也分别为二叉搜索树。

如图所示：

![](/images/数据结构和算法/36.jpg)

## 37、二叉查找树和二叉树的区别？

凡是每个节点都最多只有两个节点的树，都叫二叉树。

二叉查找树只是二叉树中的一种，主要用于搜索和动态排序。

## 38、什么是平衡二叉树？

平衡二叉树是指二叉树中任意节点的子树的高度差都不超过 1，并且左右两个子树都是一棵平衡二叉树，平衡二叉树也可以是空树。

平衡二叉树也是二叉排序树，左节点要小于根结点。

如图所示：

![](/images/数据结构和算法/38.jpg)

右图右边子树高度为 2，大于 1，所以不是平衡二叉树。

## 39、常用的平衡二叉树有哪些？

常用的平衡二叉树有：AVL 树、红黑树、Treap、伸展树等。

## 40、什么是 AVL 树？

AVL 树就是指最早发明的平衡二叉树，也就是常说的平衡二叉树，取名于其发明者的名字 Adelson-Velski 以及 Landis，具体见平衡二叉树面试题的定义：什么是平衡二叉树？

## 41、什么是红黑树？

红黑树（R-B Tree）是每个节点都带有颜色属性的一种二叉查找树，节点的颜色为红色或黑色。

![](/images/数据结构和算法/41.jpg)

红黑树是平衡二叉树的一种变体，它的左右子树高差有可能大于 1，在进行插入、删除操作时通过特定旋转操作以保持二叉查找树的平衡，从而获得较高的查找性能。

所以红黑树不是严格意义上的平衡二叉树（AVL），但对之进行平衡的代价较低，其平均统计性能要强于 AVL。

##### 红黑树需要满足下列 5 个特性：

1、根节点是黑色的；

2、其他每个节点是红色或黑色的；

3、每个空节点是黑色的；

4、如果一个节点是红色的，则它的左右子节点都必须是黑色的，但黑色节点的子节点可以是黑色的;

5、从任意一个节点到空节点的所有路径必须包含相同数目的黑色节点；

## 42、红黑树和 AVL 树的区别？

红黑树和 AVL 树都是平衡二叉树。

AVL 树是严格的平衡二叉树，必须满足平衡条件。执行插入、删除操作时，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，所以 AVL 树适合用于插入、删除操作较少、查找较多的场景。

红黑树放弃了完全平衡，而是追求大致平衡，在与 AVL 树的时间复杂度相差不大的情况下，每次插入最多只需要旋转三次就能达到平衡，维持平衡的时间消耗较少，实现起来也更为简单，相对于 AVL 树来说，它的旋转次数少，所以红黑树适应于插入、删除操作较多的场景。

##### 总结：AVL 树查找性能更快，红黑树插入、删除性能更快。

## 43、B 树、B-树、B+、B\*树的区别？

**B 树=BTree =B-Tree**，它们是指同一种树，国内出现的不同的叫法。

**B+树（B+Tree）**，它是 B 树的变体，**B\*树**又是 B+树的变体，它们都是在前一种 B 树的基础上做的优化。

---

B 树是一种自平衡的树状数据结构，用于优化数据的存储和检索。

B+树解决的是 B 树范围查询的问题，B+树的数据只存储在叶子结点中，非叶子结点存储的只是索引。

B\*树的改进旨在减少 B+树的节点分裂和合并操作，减少了树的维护开销，提升了空间利用率。

## 44、什么是 B 树？

B 树（英语：**B-tree**），也叫**B-树**，它是一种自平衡的树，一种平衡的多路查找树，B，即：**Balanced**（平衡），它能够保持数据有序，可用于支持快速的查找、插入和删除操作。

如下图所示：

![](/images/数据结构和算法/44.jpg)

一个 m 阶的 B 树具有如下几个特征：

- 它是一种多路搜索树（但不是二叉树）；
- 根节点至少有 2 个子节点；
- 所有叶子节点位于同一层；
- 除根节点以外的非叶子节点的子节点数为 M/2 ～ M 个；
- 每个节点中的元素从小到大排列；

B 树广泛用于数据库和文件系统等领域，以支持高效的数据存储和检索，B 树的设计目标是优化磁盘 I/O 操作，使得在大规模数据集上的数据查询和修改操作更为高效。

## 45、什么是 B+树？

B+树是 B 树的一种变种树，是对 B 树的改进和优化，B+树与 B 树基本定义相同。

如下图所示：

![](/images/数据结构和算法/45.jpg)

一个 m 阶的 B+树具有如下几个特征：

- 所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字；
- 除根节点以外，每个节点有 m/2 ～ m 个子节点；
- 非叶子结点的子树指针与关键字个数相同；
- 非叶子节点不存放数据，只存放索引信息；
- 叶子节点存放了所有信息，包括索引信息及数据信息；
- 所有叶子节点增加了一个链指针；
- 所有关键字都在叶子节点出现；

B 树和 B+树都是常用的数据库索引结构，用于优化数据库查询性能，但 B+树要比 B 树应用更广泛，比如：MySQL 索引默认就是使用的 B+树，因为 B+树的数据结构要更方便范围查询，不用每个层级遍历每个节点。

## 46、什么是 B\*树？

##### B\*树是 B+树的变体：

- B*树在 B+树的非根节点再增加指向兄弟的指针；*
- *B*树非叶子节点关键字个数至少为(2/3)\*M，即最低使用率为 2/3（B+树则为 1/2）

![](/images/数据结构和算法/46.jpg)

B\*树的改进主要旨在减少 B+树的节点分裂和合并操作，从而降低了树的维护开销，提高了数据检索性能。

##### B+树的分裂：

- 当一个节点满时，分配一个新的节点，并将原节点中 1/2 的数据复制到新节点，最后在父节点中增加新节点的指针；
- B+树的分裂只会影响原节点和父节点，而不会影响兄弟节点，所以它不需要指向兄弟的指针;

##### B\*树的分裂：

- 当一个节点满时，如果它的下一个兄弟节点未满，则先将一部分数据移到兄弟节点中，再在原节点插入关键字，最后修改父节点中兄弟节点的关键字；
- 如果兄弟也满了，则在原节点与兄弟节点之间增加新节点，并各复制 1/3 的数据到新节点，最后在父节点增加新节点的指针;

B*树分配新节点的概率比 B+树要低，将节点的最低利用率从 B+树的 1/2 提高到了 2/3，所以 B*树的空间使用率要更高。

## 47、什么是 R 树？

R 树也是 B 树的扩展，它是 B 树向多维空间发展的另一种形式，是一种用于空间数据索引的树状数据结构。

R 树的设计目标是支持高效的空间数据存储和检索，通过将对象划分为**矩形区域**并进行组织，R 树能够高效地支持空间查询操作，特别适用于**范围查询和邻近查询**等操作，广泛应用于数据库、地理信息系统（GIS）和空间数据管理等领域。

如下图所示：

R 树很好地解决了高维空间搜索问题，它把 B 树的思想扩展到了多维空间：

- 将对象空间按范围划分；
- 每个节点都对应一个矩形区域；
- 每个节点可以包含一定数量的子节点或对象；
- 非叶节点的磁盘页中存储其所有子节点的区域范围；
- 非叶节点的所有子节点的区域都落在它的区域范围之内；
- 叶节点的磁盘页中存储其区域范围之内的所有空间对象的外接矩形；
- 添加删除操作会采用合并/分解结点的方法，保证树的平衡性。

比如，MySQL 空间数据类型的索引就采用了 R 树进行存储。

## 48、什么是堆？

堆是一种特殊的树形数据结构，堆是一棵完全二叉树。

![](/images/数据结构和算法/48.jpg)

堆的特点是堆中的某个节点的值总是不大于或不小于其父节点的值。

根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

## 49、栈和堆的区别？

不同于 JVM 中的栈和堆，在数据结构中：

**栈**：是一种先进后出的数据结构。

**堆**：是一种特殊的树，一般堆都是指二叉堆。

## 50、常用的堆数据结构有哪些？

常用的堆数据结构有：

![](/images/数据结构和算法/50.jpg)

## 51、什么是散列表？

散列表（Hash table，也叫哈希表），是通过 Key/value 形式进行存储和访问的一种数据结构。

散列表通过把 key/ value 值映射到表中一个位置来进行记录访问，从而加快了记录查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

在 JDK 的底层实现中，普通的散列表就是：HashMap，线程安全的散列表是：Hashtable。

## 52、什么是图？

图（Graph）是一种非线性的具有“多对多"逻辑关系的数据结构，在图结构中，数据节点一般称为顶点，图就是一些顶点的集合。

如图所示：

![](/images/数据结构和算法/52.jpg)

顶点用圆圈表示，边就是这些圆圈之间的连线，顶点之间通过边连接。

## 53、BitMap 是什么？

BitMap 是一种简单而实用的数据结构，具有占用空间小、查询速度快等优点，**它用于表示一个只有 0 和 1 两个取值的序列**：

![](/images/数据结构和算法/53.jpg)

BitMap 通常采用一个数组来表示一个二进制序列，每个元素只占用 1 个 bit，可以表示 0 或 1 两个取值。由于一个 bit 只有两种取值，因此 BitMap 在存储大量数据时，可以大大减少存储空间。

另外，由于 bit 运算是计算机中最基本的运算之一，因此 BitMap 可以非常高效地进行位运算，比如与、或、非等操作。

> BitMap 主要用于位运算和内存管理等场景，可以帮助我们快速判断某个元素是否存在或统计某个范围内的元素个数。

## 54、BitMap 的工作流程？

![](/images/数据结构和算法/54.jpg)

1）初始化一个位数组，长度为 n。

2）将待处理的元素映射为位数组中的下标，如果该元素存在，则将对应的位置设置为 1，否则设置为 0。

3）**判断某个元素是否存在的操作**：可以直接访问对应位置的值，如果为 1 则说明该元素存在，否则说明不存在。

4）**统计某个范围内的元素个数的操作**：可以对范围内的所有元素进行判断，统计值为 1 的元素个数即可。

5）**对于数组去重的操作**：可以对数组中的每个元素进行处理，如果该元素对应的位置为 0，则说明该元素未出现过，可以将其加入结果数组中，否则说明该元素已经出现过，忽略即可。

## 55、BitMap 的应用场景是？

BitMap 的应用场景包括：

##### 1）快速判断某个元素是否存在

对于一个序列中的元素，可以将每个元素的值作为下标，将对应的位置设置为 1，从而实现快速判断某个元素是否存在。

##### 2）统计某个范围内的元素个数

可以使用 BitMap 统计某个范围内的元素个数，比如统计某个 IP 段内的活跃主机数量。

##### 3）数组去重

对于一个数组中的元素，可以将每个元素的值作为下标，将对应的位置设置为 1，从而实现数组去重。

##### 4）内存管理

BitMap 可以用于内存管理中，表示哪些内存块已经被占用、哪些还未被占用。

##### 5）实现布隆过滤器

可以使用一个 BitMap 来表示一个布隆过滤器中的多个二进制位，其中每一位表示一个哈希函数的返回值：

- 当需要将一个元素插入到布隆过滤器中时，可以将其哈希到多个二进制位上，并使用 SETBIT 命令将这些二进制位设置为 1。
- 当需要查询一个元素是否存在于布隆过滤器中时，可以将其哈希到多个二进制位上，并使用 GETBIT 命令检查这些二进制位是否都为 1。

## 56、BitMap 和布隆过滤器的区别？

##### 1）应用场景

布隆过滤器主要用于快速判断元素是否可能存在于一个集合中，而 BitMap 主要用于快速判断某个元素是否存在或统计某个范围内的元素个数。

##### 2）实现方式

布隆过滤器采用多个哈希函数将一个元素映射为多个不同的位，并将这些位在位数组中设置为 1，而 BitMap 直接使用数组来表示二进制序列。

##### 3）误判率

布隆过滤器存在一定的误判率，而 BitMap 没有误判率的问题。

##### 4）复杂性

布隆过滤器需要调整参数来平衡误判率和空间占用，而 BitMap 相对简单。

## 57、布隆过滤器是什么？

布隆过滤器（**Bloom Filter**）是一种空间效率高、查询时间快的概率型数据结构，它可以判断一个元素是否属于一个集合，常用于去重、快速查询等场景。

> ##### 布隆过滤器的主要思想是：
>
> 布隆过滤器通过多个哈希函数（Hash）将一个元素映射为多个不同的位，然后将这些位在位数组中位置设置为 1，表示该元素存在于集合中。当判断一个元素是否存在于集合中时，布隆过滤器将该元素通过相同的哈希函数（Hash）映射为多个位，检查这些位是否都为 1，如果是，则认为该元素可能存在于集合中。

##### 布隆过滤器数据结构图：

![](/images/数据结构和算法/57.jpg)

## 58、布隆过滤器的工作流程？

![](/images/数据结构和算法/58.jpg)

##### 1）初始化布隆过滤器：

需要一个长度为 n 的数组，每个索引位初始值为 O，还要准备 k 个 hash 函数。

##### 2）当某个元素加入集合时：

用每个 hash 函数计算出 k 个散列值，并把数组中对应的索引位置为 1。

##### 3）当判断某个 key 是否存在集合时：

用每个 hash 函数计算出 k 个散列值，并查询数组中对应的索引位，如果所有的索引位置都是 1，则元素可能在集合中，否则该元素肯定不在集合中。

## 59、布隆过滤器的应用场景是？

布隆过滤器的常用应用场景：

##### 1）缓存穿透

布隆过滤器可用于缓存中，防止缓存穿透问题，即当缓存中不存在某个元素时，多次查询会导致对数据库的多次查询，影响系统性能。

##### 2）黑名单过滤

布隆过滤器可以用于黑名单过滤，将黑名单中的 IP 地址、URL 等存储在布隆过滤器中，快速判断一个请求是否属于黑名单。

##### 3）数据库优化

布隆过滤器可以用于数据库查询优化，将查询过程中可能不存在的数据通过布隆过滤器过滤掉，减少了数据库的查询压力。

##### 4）垃圾邮件过滤

布隆过滤器可以用于过滤垃圾邮件，将已知的垃圾邮件的特征存储在布隆过滤器中，快速判断新的邮件是否属于垃圾邮件。

## 60、布隆过滤器可以判断元素存在和不存在吗？

布隆过滤器（Bloom Filter）可以判断元素**可能存在**和元素一定不存在两种情况，**但不能判断元素一定存在**，这是由于布隆过滤器的误判率导致的，因为哈希函数可能会产生哈希冲突，导致多个元素映射到了同一个位上，从而出现误判的情况。

所以，当查询一个不存在的元素时，如果索引位置上是 1，**这个 1 可能是别的元素占用的**，所以不能判定该元素是否一定存在，但可以判定它可能存在和一定不存在。

> 布隆过滤器可以用于过滤掉一些肯定不存在的元素，**但不能保证查询结果的准确性**，需要根据具体的应用场景来选择合适的参数，以平衡误判率和空间占用。
>
> 如果需要保证查询结果的准确性，可以考虑使用其他数据结构，比如哈希表、红黑树等。

## 61、布隆过滤器支持删除元素吗？有什么方案？

布隆过滤器本身不支持删除操作，因为布隆过滤器使用多个哈希函数将一个元素映射为多个不同的位，并将这些位在位数组中设置为 1，表示该元素存在于集合中。**如果要删除一个元素，需要将其对应的位设置为 0，但这会影响其他元素的判断结果，导致误判率增加**。

如果需要支持删除操作，可以考虑使用以下代替方案：

- Counting Bloom Filter（计数布隆过滤器）
- Cuckoo Filter（布谷鸟过滤器）

这些替代方案都可以支持删除操作，但相应的实现会更加复杂，需要使用更多的空间来维护计数等信息，从而降低了空间效率。

> 在实际应用中，需要根据具体的需求来选择使用哪种方案。

## 62、布隆过滤器存在什么问题？

布隆过滤器存在以下几点问题：

##### 1）误判率

由于布隆过滤器使用多个哈希函数将一个元素映射为多个不同的位，并将这些位在位数组中设置为 1，表示该元素存在于集合中。当判断一个元素是否存在于集合中时，如果这些位都为 1，则认为该元素可能存在于集合中，但这也可能导致误判。

> 误判率是布隆过滤器的一个重要指标，它会影响判断结果的准确性。

##### 2）空间占用

布隆过滤器需要使用一个位数组来存储元素的状态信息，因此需要占用一定的空间。当需要处理大量数据时，位数组的长度可能会很大，从而导致空间占用过高。

> 为了降低空间占用，可以通过调整哈希函数的数量和位数组的长度来平衡空间占用和误判率。

##### 3）删除困难

由于布隆过滤器使用多个哈希函数将一个元素映射为多个不同的位，并将这些位在位数组中设置为 1，表示该元素存在于集合中。如果要删除一个元素，需要将其对应的位设置为 0，但这会影响其他元素的判断结果，导致误判率增加。

所以，在布隆过滤器中，一般不支持删除操作。

##### 4）哈希函数的选择

布隆过滤器中的哈希函数需要具有一定的随机性，才能保证元素映射到位数组中的位置是随机的。如果哈希函数不够随机，就会导致元素映射到位数组中的位置不均匀，进而影响布隆过滤器的判断效果。

##### 5）初始容量和扩容问题

布隆过滤器在初始化时需要设置位数组的长度，这个长度需要根据预估的元素个数和期望的误判率来选择：

- 如果预估不准确或者数据量变化较大，可能会导致位数组长度过小或者过大；
- 如果位数组长度过小，就会导致误判率升高；
- 如果位数组长度过大，就会浪费空间和降低查询效率。

## 63、计数布隆过滤器是什么？

##### 计数布隆过滤器（Counting Bloom Filter）是布隆过滤器的增强版，它在布隆过滤器的基础上增加了删除操作。

计数布隆过滤器可以支持删除操作，因为它将位数组中的每个位置都改为一个计数器，而不是简单的 0 和 1，具体逻辑如下：

- 当一个元素被插入到计数布隆过滤器中时，不仅需要将相应的位设置为 1，还需要将该位对应的计数器加 1。
- 当需要删除一个元素时，可以将相应的位设置为 0，并将该位对应的计数器减 1。
- 当判断一个元素是否存在于集合中时，需要将所有相关的计数器值都读取出来，判断它们是否都大于 0，如果都大于 0，则说明该元素存在于集合中。

计数布隆过滤器相比于布隆过滤器，增加了计数器的维护，可以支持删除操作，但也带来了一些额外的空间和时间开销。

计数布隆过滤器需要使用更多的空间来维护计数器数组，同时也需要更多的时间来进行计数器的更新和查询操作。因此，在实际应用中，需要根据具体的需求来选择使用布隆过滤器还是计数布隆过滤器。

## 64、布谷鸟过滤器是什么？

布谷鸟过滤器（**Cuckoo Filter**）是一种高效的、**基于哈希表和链表的数据结构**，用于判断元素是否存在于集合中，与布隆过滤器类似，但是，**布谷鸟过滤器支持删除操作，并且不存在误判率**。

布谷鸟过滤器的工作流程如下：

##### 1）初始化

首先需要初始化布谷鸟过滤器，包括设置哈希表的大小、每个桶的大小等参数，创建哈希表并将其中的所有桶初始化为空。

##### 2）插入元素

当需要插入一个元素时，布谷鸟过滤器会使用两个哈希函数将该元素映射为两个不同的桶，然后检查这两个桶中是否已经存在该元素或者链表是否已满。如果某个桶中已经存在该元素，或者某个链表已经满了，则需要进行“踢出”操作。

##### 3）踢出元素

当发生哈希冲突时，即两个不同的元素被映射到同一个桶或者同一个链表时，布谷鸟过滤器会将已经存在的元素或者链表中的某个元素移动到另一个桶或者链表中，并将当前元素插入到被“踢出”"的位置上。如果移动后的位置上已经存在元素，就需要继续"踢出"，直到找到一个空位置为止。

##### 4）查询元素

当需要查询一个元素是否存在于集合中时，布谷鸟过滤器会使用两个哈希函数将该元素映射为两个不同的桶，然后检查这两个桶中是否存在该元素的信息。如果某个桶中存在该元素的信息，则说明该元素存在于集合中。

##### 5）删除元素

当需要删除一个元素时，可以在两个位置上都找到该元素的信息，并将其删除即可。

## 65、布隆过滤器、计数布隆过滤器和布谷鸟过滤器的区别？

##### 计数布隆过滤器和布隆过滤器相比：

- 实现方式不同
- 支持删除操作

---

##### 布谷鸟过滤器和布隆过滤器相比：

- 实现方式不同

- 不会存在误判

- 支持删除操作

- 支持动态扩容

## 66、什么是算法？

算法（Algorithm）是计算机解决问题的一系列具体方法、步骤，算法用系统的方法描述解决问题的策略机制，算法包含清晰定义的指令用于计算函数，常用于计算、数据处理和自动推理。

解决不同的问题，需要用不同的算法。

## 67、数据结构和算法有什么关系？

数据结构是按一定的逻辑结构把数据组织起来，并以适当的存储方法把逻辑结构组织好的数据存储到计算机中。

算法的目的就是为了能更高效的处理数据，提高数据有运算效率，数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。

## 68、算法的基本特征有哪些？

##### 算法的基本特征有：

##### 1、有穷性

算法必须能在有限个步骤执行之后终止。

##### 2、确切性

算法的每一步骤必须有确切的定义。

##### 3、输入项

一个算法有 0 个或多个输入，描述运算对象的初始条件。

##### 4、输出项

一个算法有 1 个或多个输出，以反映对输入数据处理后的结果。

##### 5、可行性

算法中的任何计算步骤都能被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成。

## 69、从哪些方面来评定一个算法？

##### 一个算法的评定主要有以下几个因素：

##### 1、时间复杂度

时间复杂度是指执行算法所需要的计算工作量。

##### 2、空间复杂度

空间复杂度是指算法需要消耗的内存空间。

##### 3、正确性

算法执行是否正确，是评定一个算法优劣的最重要的标准。

##### 4、可读性

可读性是指一个算法可供阅读的容易程度。

##### 5、鲁棒性

鲁棒性是指一个算法对不合理数据输入的反应能力和处理能力，也称为：**容错性**。

## 70、你怎么理解时间复杂度？

时间复杂度，不是指执行代码所消耗的具体时间，而是表示算法的运行时间随着输入规模不断增加的变化趋势。

算法的时间复杂度越小，表示算法的运行效率越高，越大则反之。

## 71、算法复杂度用什么公式表示？

一般用「大〇」来描述算法的效率，即算法复杂度。

算法复杂度表示公式为：

> O(....)， 比如: O(1)

括号里面是一个包含「n」（即输入规模）的数学表达式。

## 72、为什么需要做算法复杂度分析？

我们都知道，使用不同的算法，对于数据规模的不断增加，运行效率天差地别，使用了效率差的算法可能还会影响整个系统的吞吐量，所以对于算法复杂度分析，找出更快更合适的算法就非常有必要。

## 73、如何分析一段代码的时间复杂度？

根据常见的 7 种时间复杂度，关注是否有循环、循环嵌套语句，去套时间复杂度公式，算出总复杂度最大的那个。

| 时间复杂度量级     | 描述                                                                                                                   |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| 最坏情况时间复杂度 | 代码在最坏情况下执行的时间复杂度                                                                                       |
| 最好情况时间复杂度 | 代码在最理想情况下执行的时间复杂度                                                                                     |
| 平均时间复杂度     | 代码在所有情况下执行的时间平均时间复杂度                                                                               |
| 均摊时间复杂度     | 极少数高级别复杂度且发生具有时序关系时，可以将这几个高级别的复杂度均摊到低级别复杂度上，一般均摊结果就等于低级别复杂度 |

## 74、常见的时间复杂度有哪些？它们的算法效率如何？

##### 常见的时间复杂度有以下几种：

1、常数阶 O(1)

2、对数阶 O(log n)

3、线性阶 O(n)

4、线性对数阶 O(n log n)

5、平方阶 O(n^2)、立方阶 O(n^3)、k 次方阶 O(n^k)...

6、指数阶 O(2^n)

7、 O(n!) 阶乘阶

---

它们的运行时间变化由小到大依次为：

> O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(n^3) < O(n^k) < O(2^n) < O(n!)

即运行时间随着输入规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低。

![](/images/数据结构和算法/74.jpg)

参考: https://www.bigocheatsheet.com/

## 75、你怎么理解时间复杂度 O(1)？ (请举例说明)

##### 0(1）是常数阶，表示算法的运行时间不会随着输入规模的增加而增加。

比如以下代码：

```java
public void test {
    int i = 1;
    int j = 2;
    int k = 3;
    int m = i + j + k;
}
```

它的时间复杂度是 O(1)。

一般来说，只要没有循环、递归等场景，无论执行多少行代码，一行，十行，或者几十万行，它的时间复杂度都是 O(1)。

## 76、你怎么理解时间复杂度 O(n)？ (请举例说明)

##### O(n)是线性阶，一般出现在循环遍历代码中。

比如以下代码：

```java
public void test {
    for (int i = 0; i < list.size; i++) {
        // ...
    }
}
```

for 循环中的代码会运行 n 遍，所以它的时间复杂度都是 O(n)。

## 77、你怎么理解时间复杂度 O(log n)？ (请举例说明)

##### O(log n)是对数阶，一般出现在循环遍历代码中，循环次数成对数逐渐减少

比如以下代码：

```java
public void test {
    int i = 0;
    int n =1000;
    while(i < n) {
        // ...
        i *= 2;
    }
}
```

如果代码运行的次数为 ×，则：

> 2×=n
>
> x= logzn

所以它的时间复杂度是 O(log2n)。

因为有`i *= 2`这行代码，for 循环中的代码不会运行 n 遍，而是会逐渐减少循环次数。

> O(log2n)、O(log5n)、O(log10n) 等时间复杂度都是用 O(log n) 表示。

## 78、你怎么理解时间复杂度 O(n log n)？ (请举例说明)

##### O(n log n)是线性对数阶，可以理解为 O(n) \* O(log n)

比如以下代码：

```java
public void test {
    int n = 1000;
    for (int i = θ; i<= n; i++) {
        // ...
        int j = 0;
        while (j < n) {
            // ...
            j *= 2;
        }
    }
}
```

O(n) 时间复杂度里面再嵌套了一个 O(log n) 时间复杂度，每个 O(log n)运行 n 遍，所以时间复杂度为 O(n log n)。

## 79、你怎么理解时间复杂度 O(n^2)、O(n^3)、O(n^k)？(请举例说明)

平方阶 O(n^2)、立方阶 O(n~3)、k 次方阶 O(n^k)....可以理解为循环嵌套了多少层。

比如以下代码：

```java
public void test {
    int n = 1000;
    for (int i = e; i<n; i++) {
        // ...
        for (int j = e; j< n; j++) {
            // ...
        }
    }
}
```

这里嵌套了两个 for 循环，说明它们的执行次数是 n\*n，即 n²，所以它的时间复杂度为：平方阶 O(n^2)，其他像立方阶 O(n^3)、k 次方阶 O(n^k)... 都是类似。

## 80、你怎么理解空间复杂度？

空间复杂度，表示算法的存储空间随着输入规模不断增加的变化趋势，是对一个算法在运行过程中临时占用存储空间大小的度量。

## 81、常见的空间复杂度有哪些？它们的占用空间如何？

##### 常见的空间复杂度有以下几种：

1、 常数空间 O(1)；

2、 线性空间 O(n)；

3、 二维空间 O(n^2 )；

它们占用的空间由小到大依次为：

> O(1) < O(n) < O(n^2)

## 82、你怎么理解空间复杂度 0(1)？ (请举例说明)

O(1)是常数空间复杂度，表示算法执行时的空间不会随着变量的变化而变化，比如以下代码：

```java
public void test {
    int i = θ;
    int j = 1;
    int k = i + j;
}
```

## 83、你怎么理解空间复杂度 O(n)？ (请举例说明)

O(n)是线性空间复杂度，表示算法执行时的空间会随着变量的变化而变化，如一维数组、链表等，来看以下代码：

```java
public void test {
    int n = 10;
    int[] arr = new int[n];
    for(int i = 0; i < n; i++) {
        // ...
    }
}
```

这个一维数组的占用空间是 n，即空间复杂度：O(n)。

## 84、你怎么理解空间复杂度 O(n^2)？（请举例说明）

O(n^2)是二维空间复杂度，表示算法执行时的空间会随着变量的变化而变化，如二维数组，来看以下代码：

```java
public void test {
    int n = 10;
    int[][] arr = new int[n][n];
    for (int i = 0; i < n; i++) {
    // ...
    }
}
```

这个二维数组的占用空间是 n\*n，即空间复杂度：O(n^2)。

## 85、说说常用的数据结构操作方法，它们的时间复杂度和空间复杂度？

可参考下图：

![](/images/数据结构和算法/85.jpg)

> 参考: https://www.bigocheatsheet.com/

## 86、常见的算法基本思想有哪几种？

不同的问题，一般可以有以下算法思想去解决问题：

![](/images/数据结构和算法/86.jpg)

## 87、什么是贪心算法？

贪心算法，贪心即意味着在对问题求解时，每一步都是想得到最好、最优的选择，这就是贪心算法。

换零钱就可以用到贪心算法，比如 wikipedia 上的例子，你有 36 元，使用贪心算法换零钱，每一步都选择面值最大的：

![](/images/数据结构和算法/87.jpg)

> 结果：20 >10>5 >1

## 88、贪心算法的适用场景？

要求解的问题可以拆分为多个子问题，各个子问题的最优解可以推导出问题全局的最优解，这时候可以考虑使用贪心算法。

## 89、贪心算法的结果一定是最优解吗？为什么？

##### 贪心算法的结果对所有问题不一定都是最优解，但一定是接近（近似）最优解的结果。

贪心，即只顾眼前，不顾全局。贪心算法的特点是一步步进行，以当前情况为基础根据某个策略作出最优选择，它并没有考虑各种可能出现的整体情况，所以它只是局部最优解，并不一定是整体最优解。

## 90、什么是回溯算法？

回溯算法也叫试探法，类似穷举，是一种系统地搜索问题的解的方法。

在对问题求解的问题中，按搜索路径向前搜索，当发现不满足条件时，则回溯返回，再换一条路继续搜索，这就称为回溯算法。

回溯算法的典型就是八皇后问题：

> 在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？

![](/images/数据结构和算法/90.jpg)

## 91、回溯算法解题的一般步骤是怎样的？

##### 回溯算法解题的一般步骤：

1）定义问题的解空间，它至少包含问题的一个最优解；

2）确定易于搜索的解空间结构，能用回溯法方便地搜索整个解空间；

3）以深度优先的方式搜索解空间，在搜索过程中用剪枝函数避免无效搜索；

## 92、什么是分治算法？

分治算法是一种分目标完成的算法，它将一个规模为 N 的问题分解为 K 个规模较小的子问题，如果子问题规模还是比较大，可以继续分解为规模更小的问题，所有子问题之间相互独立，且与原问题性质相同，求出所有子问题的解，就可以得到原问题的解。

## 93、分治算法的适用场景？

1）原问题可以分解为多个性质相同的子问题，且相互独立；

2）原问题在分解过程中，递归算出各个子问题的解；

3）在得到各个子问题的解后，能合并出原问题的解；

## 94、分治算法解题的一般步骤是怎样的？

##### 分治算法解题的一般步骤：

![](/images/数据结构和算法/94.jpg)

1）分解，将问题分解成若干个规模较小的子问题；

2）求解，解决所有的问题；

3）合并，把所有子问题的解合并得出原问题的解；

## 95、什么是动态规划？

动态规划是对问题求最优解的算法，动态规划算法与分治算法类似，其基本思想也是将问题分解成若干个子问题，组合子问题的最优解就能得到问题的最优解，不同的是，动态规划子问题之间往往不是互相独立的，即下一个子阶段的求解需建立在上一个子阶段的解的基础上，再进行进一步的求解。

## 96、动态规划解题的一般步骤是怎样的？

##### 动态规划解题的一般步骤：

1）定义出子问题；

2）写出子问题的递推关系；

3）确定好 DP 数组的计算顺序；

4）空间优化（可选）；

## 97、贪心算法与动态规划有什么区别？

贪心算法对每个子问题的解决方案都做出选择后，不能回退。

动态规划会保存以前的结果，并根据以前的结果对当前进行选择，可以回退。

## 98、LeetCode--动态规划常见的面试题（共 30 道）

斐波那契数

> https://leetcode-cn.com/problems/fibonacci-number/

爬楼梯

> https://leetcode-cn.com/problems/climbing-stairs/
>
> https://leetcode-cn.com/problems/min-cost-climbing-stairs/

整数拆分

> https://leetcode-cn.com/problems/integer-break/

分割等和子集

> https://leetcode-cn.com/problems/partition-equal-subset-sum/

完全平方数

> https://leetcode-cn.com/problems/perfect-squares/

目标和

> https://leetcode-cn.com/problems/target-sum//

一和零

> https://leetcode-cn.com/problems/ones-and-zeroes/

组合总和

> https://leetcode-cn.com/problems/combination-sum-iv/

最后一块石头的重量

> https://leetcode-cn.com/problems/last-stone-weight-i/

最长有效括号

> https://leetcode-cn.com/problems/longest-valid-parentheses

单词拆分

> https://leetcode-cn.com/problems/word-break/

打家劫舍

> https://leetcode-cn.com/problems/house-robber/
>
> https://leetcode-cn.com/problems/house-robber-i/
>
> https://leetcode-cn.com/problems/house-robber-ii/

买卖股票的最佳时机

> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
>
> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-i/
>
> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
>
> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/
>
> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
>
> https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

掷骰子的 N 种方法

> https:/leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum

不同路径

> https://leetcode-cn.com/problems/unique-paths/
>
> https://leetcode-cn.com/problems/unique-paths-ii/

最长递增子序列

> https://leetcode-cn.com/problems/longest-increasing-subsequence/

最长连续递增序列

> https:/leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

最长重复子数组

> https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

最大子数组和

> https:/leetcode-cn.com/problems/maximum-subarray/

获取生成数组中的最大值

> https:/leetcode-cn.com/problems/get-maximum-in-generated-array

最长公共子序列

> https://leetcode-cn.com/problems/longest-common-subsequence/

判断子序列

> https://leetcode-cn.com/problems/is-subsequence/

不同的子序列

> https://leetcode-cn.com/problems/distinct-subsequences/

不相交的线

> https://leetcode-cn.com/problems/uncrossed-lines/

两个字符串的删除操作

> https://leetcode-cn.com/problems/delete-operation-for-two-strings/

回文子串

> https://leetcode-cn.com/problems/palindromic-substrings/

最长回文子序列

> https://leetcode-cn.com/problems/longest-palindromic-subsequence/

编辑距离

> https://leetcode-cn.com/problems/edit-distance/

最大矩形

> https://leetcode-cn.com/problems/maximal-rectangle

不同的二叉搜索树

> https://leetcode-cn.com/problems/unique-binary-search-trees/

最小的必要团队

> https://eetcode-cn.com/problems/smallest-sufficient-team

访问所有节点的最短路径

> https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes

## 99、LeetCode--贪心算法常见的面试题（共 20 道）

分发饼干

https://leetcode-cn.com/problems/assign-cookies/

分发糖果

https://leetcode-cn.com/problems/candy/

零钱兑换

> https://leetcode-cn.com/problems/coin-change/
>
> https:/leetcode-cn.com/problems/coin-change-2/

柠檬水找零

https:/leetcode-cn.com/problems/lemonade-change/

用最少数量的箭引爆气球

https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons

按要求补齐数组

https://leetcode-cn.com/problems/patching-array/

盛最多水的容器

https://leetcode-cn.com/problems/container-with-most-water

摆动序列

https://leetcode-cn.com/problems//wiggle-subsequence/

最大子数组和

https://leetcode-cn.com/problems/maximum-subarray/

加油站

https://leetcode-cn.com/problems/gas-station//

根据身高重建队列

https://leetcode-cn.com/problems/queue-reconstruction-by-height

无重叠区间

https://leetcode-cn.com/problems/non-overlapping-intervals

划分字母区间

https://leetcode-cn.com/problems/partition-labels

合并区间

https://leetcode-cn.com/problems/merge-intervals

单调递增的数字

https://leetcode-cn.com/problems/monotone-increasing-digits

监控二叉树

https://leetcode-cn.com/problems/binary-tree-cameras

跳跃游戏

https:/leetcode-cn.com/problems/jump-game

https://leetcode-cn.com/problems/jump-game-i

最长回文串

https://leetcode-cn.com/problems/longest-palindrome

种花问题

https://leetcode-cn.com/problems/can-place-flowers

最大数

https://leetcode-cn.com/problems/largest-number

## 100、LeetCode--分治算法常见的面试题 (共 16 道)

最小的 k 个数

https:/leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof

最小的 k 个数

https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof

出现频率最高的 k 个数字

https:/letcode-cn.com/problems/g5c510

连续子数组的最大和

https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof

环形子数组的最大和

https://leetcode-cn.com/problems/maximum-sum-circular-subarray

最接近原点的 K 个点

https://leetcode-cn.com/problems/k-closest-points-to-origin

最小高度树

https://leetcode-cn.com/problems/minimum-height-tree-lcci

至少有 K 个重复字符的最长子串

https://leetcode-cn.com/problems/longest-substring,g-with-at-least-k-repeating-characters

最大二叉树

https://leetcode-cn.com/problems/maximum-binary-tree

数组中的第 k 大的数字

https://leetcode-cn.com/problems/xx4gT2

最大子数组和

https://leetcode-cn.com/problems/maximum-subarray

数组中的逆序对

https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof

找出数组中的第 K 大整数

https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array

区间和的个数

https://leetcode-cn.com/problems/count-of-range-sum

从子集的和还原数组

https://leetcode-cn.com/problems/find-array-given-subset-sums

计算右侧小于当前元素的个数

https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self

## 101、LeetCode-回溯算法常见的面试题 (共 22 道)

随机数索引

https://leetcode-cn.com/problems/random-pick-index

组合总和

https://leetcode-cn.com/problems/combination-sum

https://leetcode-cn.com/problems/combination-sum-i

全排列

https://leetcode-cn.com/problems/permutations

https://leetcode-cn.com/problems/permutations-ii

子集

https://leetcode-cn.com/problems/subsets

https://leetcode-cn.com/problems/subsets-ii

得分最高的单词集合

https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters

所有可能的路径

https://leetcode-cn.com/problems/all-paths-from-source-to-target

二叉树的所有路径

https://leetcode-cn.com/problems/binary-tree-paths

N 次操作后的最大分数和

https://leetcode-cn.com/problems/maximize-score-after-n-operations

串联字符串的最大长度

https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters

完成所有工作的最短时间

https://leetcode-cn.com/problems/find-minimum-time-to-finish-alljobs

重复 K 次的最长子序列

https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times

优美的排列

https://leetcode-cn.com/problems/beautiful-arrangement

迷路的机器人

https://leetcode-cn.com/problems/robot-in-a-grid-lcci

棋盘上有效移动组合的数目

https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard

生成匹配的括号

https://leetcode-cn.com/problems/IDBivT

删除无效的括号

https://leetcode-cn.com/problems/remove-invalid-parentheses

连续差相同的数字

https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences

正方形数组的数目

https://leetcode-cn.com/problems/number-of-squareful-arrays

划分为 k 个相等的子集

https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets

统计各位数字都不同的数字个数

https://leetcode-cn.com/problems/count-numbers-with-unique-digits/

电话号码的字母组合

https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number

最大化一张图中的路径价值

https://leetcode-cn.com/problems/maximum-path-quality-of-a-graph

## 102、常用的排序算法主要有哪些？

如图所示：

![](/images/数据结构和算法/102.jpg)

实现代码见编程题。

## 103、说说常用的排序算法，它们的时间复杂度和空间复杂度？

可参考下图：

![](/images/数据结构和算法/103.jpg)

> 参考：https://www.bigocheatsheet.com/

## 104、常用的查找算法有哪些？

常用的查找算法有：

![](/images/数据结构和算法/104.jpg)

## 105、常用的图搜索算法有哪些？

常用的图搜索算法有：

![](/images/数据结构和算法/105.jpg)

深度优先算法（DFS）：思路是从一个节点开始往下搜索，如果发现走不通了，就往回一个节点，从那个节点继续往下走。

广度优先算法（BFS）：思路也是从一个节点开始，不同的是它会先搜索完该节点的子节点，再往下一层搜索。

## 106、常用的字符串匹配算法有哪些？

常用的字符串匹配算法有 4 种：

![](/images/数据结构和算法/106.jpg)

BF（Brute Force）：是一种暴力算法，是普通的模式匹配算法。

BM（Boyer-Moore）：是一种非常高效的字符串搜索算法；

KMP：是一种改进的字符串匹配算法。

Sunday：是目前发现的最高效、容易理解的算法。

## 107、什么是对称加密算法？

所谓对称，就是采用这种加密算法的双方，即加密方和解密方，两方同时使用相同的密钥进行加密和解密，密钥是控制加密及解密过程的指令。

## 108、对称加密算法的优缺点？

##### 对称加密算法的优点是：

- 算法公开
- 计算量小
- 加密速度快
- 加密效率高

##### 对称加密算法的缺点是：

在数据传送前，发送方和接收方必须商定好密钥，然后双方都需要保存好密钥，如果一方的密钥被泄露，那么加密信息也就不安全了。

另外，每对用户每次使用对称加密算法时，都需要使用其他人不相同的唯一密钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

## 109、对称加密算法的应用场景有哪些？

##### 对称加密算法的应用场景有：

1、无需进行密钥交换的场景，如内部系统，事先就可以直接确定密钥；

2、常用于保存、传输像用户手机号、身份证、卡号...等数据敏感但能够被解密的信息。

## 110、常用的对称加密算法有哪些？

##### 常用的对称加密算法有：

##### DES

全称为：Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。

##### 3DES

即：TripleDES，是 DES 向 AES 过渡的加密算法，它使用 3 条 56 位的密钥对数据进行三次加密，是 DES 的一个更安全的变形。它以 DES 为基本模块，通过组合分组方法设计出分组加密算法。

比起最初的 DES，3DES 更安全。

##### AES

全称为：Advanced Encryption Standard，在密码学中又称 Rjndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。

## 111、什么是非对称加密算法？

与对称加密算法不同，非对称加密算法需要两个密钥：公钥（publickey）和私钥（privatekey）。

公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

## 112、非对称加密算法的优缺点？

##### 非对称加密算法的优点是：

非对称加密与对称加密相比，其安全性更好，非对称加密使用一对密钥，一个用来加密，一个用来解密，而且公钥是公开的，私钥是另外保存的（或者其他人持有），就算公钥被泄露，没有私钥也不能解密。

##### 非对称加密算法的缺点是：

非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

## 113、对称加密算法的应用场景有哪些？

##### 非对称加密算法的应用场景有：

1、适用于需要密钥交换的场景，如互联网应用，无法事先约定密钥；

2、一般用于签名和认证；

## 114、常用的非对称加密算法有哪些？

##### 常用的非对称加密算法有：

##### RSA

全称为：Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA 是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之

##### DSA

全称为：Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与 RSA 相比差不多。DSA 的一个重要特点是两个素数公开，这样，当使用别人的 p 和 q 时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚，这点 RSA 算法却做不到。

##### ECC

全称为：Elliptic Curves Cryptography，也叫椭圆加密算法，是一种公钥加密体制，其数学基础是利用椭圆曲线上的有理点构成 Abel 加法群上椭圆离散对数的计算困难性。

## 115、什么是散列算法？

在信息安全技术中，经常需要验证消息的完整性，散列（Hash）函数提供了这一服务，它可以对不同长度的输入数据，然后产生一个固定长度的输出值，该输出值就是散列值。

所以应用的时候，就可以通过散列算法对比两个数据的散列值是否一样。

## 116、散列算法的应用场景有哪些？

##### 散列算法的应用场景有：

##### 1、数据加密

用来存储用户敏感信息，如用户密码等其他不可解密的信息但能通过对比验证其正确性。

##### 2、数据校验

比较可以用来效验下载文件正确性，一般在网站上下载文件都能见到，防止下载的文件不正确。

另外还有像接口参数的签名验证，可用于验证接口参数的有效性。

##### 3、唯一标识

比如要求某 XX 信息不能重复，这时候可以利用散列算法生成做对比。

## 117、常用的散列算法有哪些？

##### 常用的散列算法有：

##### MD5

全称为：Message Digest Algorithm，即中文名为消息摘要算法第五版，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。

##### SHA

全称为：Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（DigitalSignature Algorithm DSA) 。

SHA 系列算法有 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 这 5 种单向散列算法，其中 SHA-1 已经不安全了，不推荐使用了。

##### HMAC

全称为：Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。消息鉴别码用于验证传输于两个共同享有一个密钥的单位之间的消息。

HMAC 可以与任何迭代散列函数捆绑使用，HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。

## 118、MD5 加密算法能被破解吗？

MD5 是散列加密算法，是不可逆的，理论上是不能被破解的，但各种消息称 MD5 已经能被破解了，但普通人是不可能破解的。

## 119、为什么都说 MD5 加密不安全了？

那是因为很多人的密码都很简单，比如：123456，iloveyou，等弱密码.....

这样就可以把常用的字符串（或者把各种常见的字符串进行排列组合）转换 MD5 值，再用数据库表存储起来，称为彩虹表，然后直接反查彩虹表进行对比，这样弱密码就暴露无疑了。。

另外，MD5 据说被某软件小组破解了，早在 2010 年，美国软件工程学会也认为 MD5 算法已被破解，不再适用了。

所以，MD5 已经不是安全的加密算法了，不建议使用了，一定要使用，必须加盐使用。

## 120、何加强散列算法的安全性？

MD5 和 SHA 1 都能被破解了，一般建议使用：SHA 256 及之上的散列加密算法。

除些之外，还需要加盐（salt）加密处理，比如：

String password = "123456";

String salt = "slq1893.github.io";

一般正确的做法是：SHA256（password + salt）

密码+盐一起加密形成密文，这样就算密码是弱密码，一起组成就是复杂的密码了。

## 121、Base64 是什么？

Base64 是一种基于 64 个可打印字符来表示二进制数据的方法，如下图所示：

![](/images/数据结构和算法/121.jpg)

Base64 编码是把二进制转换为可打印字符，Base64 编码具有不可读性,需要解码后才能阅读。

## 122、Base64 的优缺点？

##### Base64 编码的优点：

1、可以将二进制数据转换成可打印字符，方便数据传输；

2、可以对数据进行简单的加密，肉眼传输安全；

##### Base64 编码的缺点：

1、数据编码后的体积会变大，占用空间；

2、编码和解码过程需要额外的工作量；

## 123、Base64 是加密算法吗？

Base64 是一种编码方式，**不是加密算法**，Base64 是没有可读性，但不代表这个编码就是加密的。加密需要保证没有密钥的人无法解密信息，更无法从密文中破解任何明文信息，但 Base64 可以很轻松的反编码。

另外，Base64 编码也显然没有用到密钥，不具有加密算法的安全性，所以，这个误区大家要纠正过来。

## 124、Base64 的应用场景有哪些？

##### Base64 的应用场景有：

1、传输一些稍微敏感的信息，可不用加密，使用 Base64 简单编码，肉眼安全；

2、有些传输不支持不可见字符的时候，可用 Base64 转换成可打印字符来传递；

3、可用于存储图片，但占用空间比较大，一般不建议使用。

## 125、Base64 可以在 Url 中传输吗？

标准的 Base64 不适合直接放在 URL 里传输，因为 Base64 字符里面含有字符(+,/，=)，URL 编码器会变成 **%xx** 的形式，这样经过 Url 传递后解码可能会出错。

所以，要在 Url 中传输 Base64 的值，就必须将字符（+,/,=）替换掉。

## 126、编程输出九九乘法表

用 Java 编程打印出九九乘法表：

![](/images/数据结构和算法/126.jpg)

---

示例代码：

```java
/**
* 九九乘法表
*/
public class Haskell {
    public static void main(string[] args) {
        for (int i = 1; i <= 9; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print(j + "=" + (i * j)+"\t");
            }
            System.out.println();
        }
    }
}
```

## 127、编程输出 100 以内所有的素数

用 Java 编程输出 100 以内所有的素数个数，并输出所有的素数。

> 素数：又称为质数，它指的是只能被 1 和被自己整除的整数，其中，1 不是素数。

---

示例代码：

```java
/**
* 输出1000以内所有的素数
*/
public class PrimeNumber {
    public static void main(string[] args) {
        int count = 0;
        for (int i = 2; i < 100; i++) {
            boolean isprime = true;
            for (int j = 2 j< i; j++) {
                if (i % j == 0) {
                    isprime = false;
                    break;
                }
            }
            if (isprime) {
                count++;
                System.out.print(i);
                System.out.print("");
            }
        }
        System.out.println();
        System.out.println("1ee 以内的素数个数是：" + count);
    }
}
```

##### 输出结果：

2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 7173 79 83 89 97

100 以内的素数个数是:25

## 128、编程输出 1000 以内所有的水仙花数

用 Java 编程输出 1000 以内所有的水仙花数个数，并输出所有的水仙花数。

> 水仙花数：是指一个 n 位数（n>=3），它的每个位上的数字的 n 次幂之和等于它本身。
>
> 例如 153 是一个水仙花数，1^3+5^3+3^3=153

---

##### 示例代码：

```java
/**
* 输出1088以内所有的水仙花故
*/
public class NarcissisticNumber {
     public static void main(string[] args) {
         int ge, shi, bai;
         int count = ;
         for (int i = 100; i < 100; i++) {
             ge = i % 10;
             shi = i / 10 % 10;
             bai = i / 100;
             int result = (int) (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3));
             if (i == result) {
        System.out.print(i);
                 System.out.print(" ");
                 count++;
             }
         }
         System.out.println();
         System.out.println("1eee 以内的水仙花数个数是："+count);
     }
}
```

##### 输出结果：

153 370 371 407

1000 以内的水仙花数个数是：4

## 129、编程统计出不同类型的字符个数

给定一行字符，用 Java 编程，分别统计并输出其中英文字母、数字、空格、其它字符的个数。

---

##### 示例代码：

```java
/**
* 字符个数统计
*/
public class Charstastics {
     public static void main(string[] args) {
         String str = "19ds$^sljd 2341@06qdj8^&*Q e0sdcka2385 -1!~er,s92";
         char[] chars = str.tocharArray();

         int englishcount = 0;
         int spacecount = 0;
         int digitcount = 0;
         int othercount = 0;

         for (int i = 0; i < str.length(); i++) {
             if (character.isletter(chars[i])) {
                 englishcount++;
                 continue;
             }
             if (Character.isDigit(chars[i])) {
                 digitcount++;
                 continue;
             }
             if (character.isspacechar(chars[i])) {
                 spacecount++;
                 continue;
             }
             otherCount++;
         }

         System.out.println("英语字母个数为："+englishcount);
         System.out.println("数字个数为：" + digitcount);
         System.out.printin("空格个数为："+ spacecount);
         System.out.println("其他字符个数为："+ othercount);
     }
}
```

##### 输出结果：

英语字母个数为：19

数字个数为：17

空格个数为：3

其他字符个数为：10

## 130、编程计算出 1-100 之间的和

用 Java 编程，以及递归算法，计算出 1-100 之间的和。

---

##### 示例代码：

```java
/**
* 递归求和
*/
public class Recursionsum {
    public static void main(string[] args) {
        System.out.println("1-100 递归求和结果为: " + sum(1e8));
    }

    public static int sum(int num) {
        f (num == 1) {
            return 1;
        }
        return num + sum(num - 1);
    }
}
```

##### 输出结果：

1-100 递归求和结果为：5050

## 131、编程输出只出现过一次的数

给定一个整型数组，用 Java 编程，计算并输出其中只出现过一次的数。

---

##### 示例代码：

```java
/**
* 只出现过一次的数
*/
public class oneNumber {
    public static void main(string[] args) {
        int[] arr = new int[]{1, 39, 2, 39, 2, 1, 2, 9, 3, 33, 13, 33};
        for (int i = e; i < arr.length; i++) {
          int num = 0;
            for (int j = 0; j< arr.length; j++) {
                if (arr[i] == arr[j]l) {
                    num++;
                }
            }
            if (num == 1) {
                System.out.printin("这个数只出现了一次："+arr[i]);
            }
        }
    }
}
```

##### 输出结果：

这个数只出现了一次：9

这个数只出现了一次：3

这个数只出现了一次：13

## 132、编程实现数组排序（冒泡排序）

给定一个整形数组，用 Java 编程实现冒泡排序升序排列。

> ##### 冒泡排序：
>
> 依次比较两个相邻的数字，若发现逆序则交换，越小的数字经过不慢交换会慢慢“浮”到数组的顶端（升序），就如同水底的气泡往上冒一样，最终会上浮到顶端，故名：“冒泡排序"。

---

##### 示例代码：

```java
/**
* 冒泡排序
*/
public class Bubblesort {
    public static void main(string[] args) {
        int[] arr ={28, 21, 3,1, 6, 66, 5, 33, 2, 19 };

        //排序前输出
        System.out.println("排序前为:");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");
        bubblesort(arr);

        //排序后输出结果
        System.out.println("排序后为: ");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void bubblesort(int[] arr) {
        int temp;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j< arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temps
                }
            }

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.printin();
        }
    }
}
```

##### 输出结果：

![](/images/数据结构和算法/132.jpg)

## 133、编程实现数组排序（快速排序）

给定一个整形数组,用 Java 编程实现快速排序升序排列。

> ##### 快速排序：
>
> 快速排序是对冒泡排序的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

---

##### 示例代码：

```java
/**
* 快速排序
*/
 public class Quicksort {
     public static void main(string[] args) {
         int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

         //排序前输出
         System.out.println("排序前为:");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }

         //输出排序过程
         System.out.println();
         System.out.println("正在排序...");
         quicksort(arr, 0, arr.length - 1);

         //排序后输出结果
         System.out.println("排序后为：");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }
     }

     public static void quicksort(int arr[], int low, int high) {
         nt pivot, pos, i, t;
         if (low <high) {
             pos = low;
             pivot = arr[pos];
             for (i = low + 1; i <= high; i++) {
                 if (arr[i] < pivot) {
                     pos++;
                     t = arr[pos];
                     arr[pos] = arr[i];
                     arr[i] = t;
                 }
             }
             t = arr[low];
             arr[low] = arr[pos];
             arr[pos] = t;

             for (int k = o; k < arr.length; k++) {
                 System.out.print(arr[k] + "\t");
             }
             System.out.println();

             //分而治之
             //排序左半部分
             quicksort(arr, low, pos - 1);

             //排序右半部分
             quicksort(arr, pos + 1, high);
         }
     }
 }
```

##### 输出结果：

![](/images/数据结构和算法/133.jpg)

## 134、编程实现数组排序（选择排序）

给定一个整形数组，用 Java 编程实现选择排序升序排列。

> ##### 选择排序：
>
> 第一次从待排序的数据中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。
>
> 选择排序是不稳定的排序方法。

---

##### 示例代码：

```java
/**
*选择排序
*/
public class selectsort {
    public static void main(string[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为：");
        for (int i = ; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        selectsort(arr);

        //排序后输出结果
        System.out.println("排序后为: ");
        for (int i = e; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void selectsort(int[] arr) {
        int temp;
        for (int j= θ; j < arr.length - 1; j++) {
            int min = arr[j];
            int minIndex = j;
            for (int k = j + 1; k < arr.length; k++) {
                f (min > arr[k]) {
                    min = arr[k];
                    minindex = k;
                }
            }

            temp = arr[i];
            arr[j] = arr[minindex];
            arr[minIndex] = temp;

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.printin();
        }
    }

}
```

##### 输出结果：

![](/images/数据结构和算法/134.jpg)

## 135、编程实现数组排序（插入排序）

给定一个整形数组，用 Java 编程实现插入排序升序排列。

> ##### 插入排序：
>
> 插入排序是指在待排序的元素中，假设前面 n-1(其中 n>=2)个数已经是排好顺序的，现将第 n 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第 n 个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

---

##### 示例代码：

```java
/**
* 插入排序
*/
public class Insertionsort {
   public static void main(string[] args) {
         int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

         //排序前输出
         System.out.printin("排序前为：");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }

         //输出排序过程
         System.out.println();
         System.out.println("正在排序...");

         insertionsort(arr);

         //排序后输出结果
         System.out.println("排序后为:");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }
     }

    public static void insertionsort(int arr[]) {
        int i, j, t;
        for (i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                t = arr[i];
                for (j = i - 1; j >= e && t < arr[j]; j--) {
                    arr[j + 1] = arr[j];
                }

                //插入到适当位置
                arr[j + 1] = t;

                for (int k = 0; k < arr.length; k++) {
                    System.out.print(arr[k] + "\t");
                }
                System.out.println();
            }
        }
    }
}
```

输出结果：

![](./imags/数据结构和算法/135.jpg)

## 136、编程实现数组排序（希尔排序）

给定一个整形数组，用 Java 编程实现希尔排序升序排列。

> ##### 希尔排序：
>
> 希尔排序是插入排序的一种又称缩小增量排序，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

---

示例代码：

```java
/**
* 希尔排序
*/
public class Shellsort {
    public static void main(string[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

    //排序前输出
        System.out.println("排序前为：");
        for (int i = 0; i< arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }


        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        shellsort(arr);

        //排序后输出结果
        System.out.printin("排序后为：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    public static void shellsort(int[] arr) {
        int j, temp;
        for (int incr = arr.length / 2; incr > 0; incr /= 2) {
            for (int i = incr; i < arr.length; i++) {
                temp = arr[i];
                for (j = i; j >= incr; j -= incr) {
                    if (temp < arr[j - incr]) {
                        arr[j] = arr[j - incr];
                    }else {
                        break;
                    }
                }
                arr[j] = temp;
                for (int k = 0; k < arr.length; k++) {
                    System.out.print(arr[k] + "\t");
                }
                System.out.println();
            }
        }
    }
}
```

##### 输出结果：

![](/images/数据结构和算法/136.jpg)

## 137、编程实现数组排序（二分排序）

给定一个整形数组，用 Java 编程实现二分排序升序排列。

> ##### 二分排序：
>
> 二分排序是指利用二分法的思想对插入排序进行改进的一种插入排序算法，不同于二叉排序，可以利用数组的特点快速定位指定索引的元素。
>
> 二分法插入排序是在插入第个元素时，对前面的 0 ～ i-1 元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到 left>right，然后再把第 i 个元素前 1 位与目标位置之间的所有元素后移，再把第 i 个元素放在目标位置上。

---

##### 示例代码：

```java
package cn.javastack.test.example.sort;
/**
* 二分排序
*/
public class Binarysort {
    public static void main(string[] args) {
        int[] arr = {28, 21, 3,1, 6, 66, 5, 33, 2,19};

        //排序前输出
        System.out.println("排序前为:");
        for (int i = e; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        binarysort(arr);

        //排序后输出结果
        System.out.println("排序后为: ");
        for (int i = e; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void binarysort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int index = binaryfind(e, i - 1, arr[i], arr);
            insert(index, i, arr[i], arr);

          for (int k = e; k < arr.length; k++) {
                 System.out.print(arr[k] + "\t");
            }
            System.out.println();
        }
    }

    private static int binaryFind(int leftindex, int rightindex, int val, int[] arr) {
        int midindex = ((rightIndex + leftindex) / 2);
        int midval = arr[midindex];

        if (rightindex >= leftindex) {
            if (midval > val) {
                return binaryFind(leftindex, midindex - 1, val, arr);
            } else if (midval < val) {
                return binaryFind(midindex + 1, rightindex, val, arr);
            } else if (midval == val) {
                return midindex + 1;
            }
        }else {
            return leftindex;
        }
        return - 1;
    }

    private static void insert(int index, int last, int value, int[] arr) {
        int i = last - 1;
        while (index <= i) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = value;
    }
}
```

##### 输出结果：

![](/images/数据结构和算法/137.jpg)

## 138、编程实现数组排序（归并排序）

给定一个整形数组，用 Java 编程实现归并排序升序排列。

> ##### 归并排序：
>
> 归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用。

---

##### 示例代码：

```java
/**
* 归并排序
*/
 public class Mergesort {
     public static void main(string[] args) {
         int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

         //排序前输出
         System.out.printin("排序前为：");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }

         //输出排序过程
         System.out.println();
         System.out.println("正在排序...");

         mergesort(arr, 0, arr.length - 1);

         //排序后输出结果
         System.out.println("排序后为：");
         for (int i = 0; i < arr.length; i++) {
             System.out.print(arr[i] + "\t");
         }
     }

     private static void mergesort(int[] arr, int start, int end) {
         if (start < end) {
             int m = (start + end) / 2;

             mergesort(arr, start, m);
             mergesort(arr, m + 1, end);

             merge(arr, start, m, end);

             for (int k = 0; k < arr.length; k++) {
                 System.out.print(arr[k] + "\t");
             }
              System.out.println();
         }
     }

     public static void merge(int[] arr, int start, int m, int end) {
         int length = end - start + 1;
         int temp[] = new int[length];

         int i = start;
         int j = m + 1;
         int k = 0;

         while (i <= m && j <= end) {
             if (arr[i] < arr[j]) {
                 temp[k++] = arr[i++];
             } else {
                 temp[k++] = arr[j++];
             }
         }

         while (i <= m) {
             temp[k++] = arr[i++];
         }
         while (j <= end) {
             temp[k++] = arr[j++];
         }

         k = 0;
         for (int tstart; t <= end; t++) {
             arr[t] = temp[k++];
         }
     }
 }
```

##### 输出结果：

![](/images/数据结构和算法/138.jpg)

## 139、编程实现数组排序（堆排序）

给定一个整形数组，用 Java 编程实现堆排序升序排列。

> ##### 推排序：
>
> 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

---

##### 示例代码：

```java
/**
* 堆排序
*/
public class Heapsort {
  public static void main(string[] args) {
        int[] arr = {28, 21, 3, 1, 6, 66, 5, 33, 2, 19};

        //排序前输出
        System.out.println("排序前为:");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }

        //输出排序过程
        System.out.println();
        System.out.println("正在排序...");

        heapsort(arr);

        //排序后输出结果
        System.out.println("排序后为:");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }

    private static void heapsort(int arr[]) {
        for (int i = ; i < arr.length; i++) {
            heap(arr, arr.length - 1 - i);
            swap(arr, 0, arr.length - 1 - i);

            for (int k = 0; k < arr.length; k++) {
                System.out.print(arr[k] + "\t");
            }
            System.out.println();
        }
    }

    private static void heap(int[] data, int last) {
        for (int i = last / 2; i >= 0; i--) {
            int parent = i;
            while (2 * parent + 1 <= last) {
                int bigger = 2 * parent + 1;
                if (bigger < last) {
                    if (data[bigger] < data[bigger + 1]) {
                        bigger = bigger + 1;
                    }
                }
                if (data[parent] < data[bigger]) {
                    SWap(data, parent, bigger);
                    parent = biggery
                } else {
                    break;
                }
            }
        }
    }

    private static void swap(int[] data, int i, int j) {
        if (i == j) {
            return;
        }
        data[i] = data[i] + data[j];
        data[j] = data[i] - data[j];
        data[i] = data[i] - data[j];
    }
}
```

##### 输出结果：

![](/images/数据结构和算法/139.jpg)

## 140、什么是雪花算法？实现原理？

雪花算法（Snowflake）是一种用于生成唯一 ID 的分布式算法，它最初由 Twitter 开发，用于在分布式系统中生成全局唯一的 ID，以解决数据库自增 ID 在分布式环境中可能产生冲突的问题。

雪花算法的核心思想是，将一个 64 位的 long 型 ID 分成几个部分，每部分用于表示不同的信息，一个 Snowflake ID 由以下几个部分组成：

![](/images/数据结构和算法/140.jpg)

1、**符号位**：最高位是符号位，0 表示正数，1 表示负数。由于雪花算法只生成正数的唯一 ID，所以将最高位固定为 0。

2、**时间戳（41 位）**：表示生成 ID 的时间戳，精确到毫秒级。由于使用 41 位来表示时间戳，所以 Snowflake 算法可以支持的时间范围为 2^41-1 毫秒，大约可以支持 69 年的时间。

3、**机器 ID（10 位）**：表示机器的唯一 ID。通过这个 ID，可以将生成 ID 的机器数量限制在 2^10 台，即 1024 台。

4、**序列号（12 位）**：表示同一毫秒内生成的序列号。由于使用 12 位来表示序列号，所以每毫秒可以生成 2^12 个 D，即 4096 个 ID。

雪花算法的优点在于简单、高效，并且生成的 ID 在时间上是递增的，便于数据库索引和查询。在同一毫秒内，如果有多个请求同时生成 ID,序列号部分会自增，以保证生成的 ID 唯一性。

## 141、雪花算法会有哪些问题？怎么解决？

雪花算法是一种简单高效的分布式唯一 ID 生成算法，但在实际应用中，也会存在一些问题，以下是雪花算法经常会遇到的两个问题以及相应的解决方法。

##### 1、时钟回拨问题

雪花算法使用了时间戳来保证生成的 ID 的唯一性和有序性，但如果系统时钟发生回拨，可能导致生成的 ID 重复。这种情况下，新的时间戳可能小于之前生成的时间戳，导致生成的 ID 重复。

> ##### 解决方法：
>
> 可以使用比较稳定的时钟源，例如使用 NTP 服务来同步系统时间，以避免时钟回拨问题。另外，可以在时钟回拨时暂停 ID 生成，等待时钟同步完成后再继续生成 ID。
>
> 另外，还需要结合实际业务场景，可考虑使用时钟回拨检测、时钟回拨补偿等机制来解决时钟回拨问题。

##### 2、机器 ID 唯一性

雪花算法要求不同的机器拥有不同的机器 ID，以保证生成的 ID 的唯一性。如果出现机器 ID 冲突，可能会导致生成的 ID 重复。

> ##### 解决方法：
>
> 确保在分布式环境中，每个机器的机器 ID 是唯一的。比如，可以使用硬件信息、IP 地址、主机名等作为机器 ID，或者通过配置文件来设置唯一的机器 ID。
>
> 另外，也可以使用分布式注册中心或数据库来分配唯一的机器 ID。

## 142、编程实现一个雪花算法

完整 Java 实现如下：

```java
public class SnowFlake {
    /**
    * 起始的时间戳
    */
    private final static long START_STMP = 1480166465631L;

    /**
    * 每一部分占用的位数
    */
    private final static long SEQuENCE_BIT = 12; //序列号占用的位数
    private final static long MACHINE_BIT = 5;//机器标识占用的位数
    private final static long DATACENTER_BIT = 5;//数据中心占用的位数

    /**
    * 每一部分的最大值
    */
    private final static long MAX_DATACENTER_NUM = -1l ^ (-1l << DATACENTER_BIT);
    private final static long MAX_MACHINE_NUM = -1l ^ (-1l << MACHINE_BIT);
    private final static long MAX_SEQUENCE = -1L ^ (-1L << SEQUENCE_BIT);

    /**
    * 每一部分向左的位移
    */
    private final static long MACHINE_LEFT = SEQUENCE_BIT;
    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;
    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;

    private long datacenterid; //数据中心
    private long machineId;//机器标识
    private long sequence = OL; //序列号
    private long laststmp = -1L;//上—次时间截

    public snowFlake(long datacenterid, long machineid) {
        if (datacenterId > MAX_DATACENTER_NUM || datacenterId < 0) {
            throw new IllegalArgumentException("datacenterId can't be greater than MAX_DATACENTER_NUM or less than @");
        }
        if (machineId > MAX_MACHINE_NUM II machineId < 0) {
            throw new IllegalArgumentException("machineId can't be greater than MAX_MACHINE_NUM or less than 0");
        }
        this.datacenterid = datacenterId;
        this.machineld = machineid;
    }

    /**
    * 产生下一个ID
    */
    public synchronized long nextid() {
        long currstmp = getNewstmp();
        if (currstmp < laststmp){
            throw new RuntimeException("clock moved backwards. Refusing to generate id");
        }

        if (currstmp == laststmp) {
            //相同毫秒内，序列号自增
            sequence = (sequence + 1) & MAX_SEQUENCE;
            //同一毫秒的序列数已经达到最大
            if (sequence == 0L) {
                currstmp = getNextMill();
            }
        }else {
            //不同毫秒内，序列号置为
            sequence = 0L;
        }

        laststmp = currstmp;

        return (currStmp - START_STMP) << TIMESTMP_LEFT //时间部分
            | datacenterId << DATACENTER_LEFT  //数据中心部分
            |machineId << MACHINE_LEFT   //机器标识部分
            | sequence;    //序列号部分
    }

    private long getNextMill() {
        long mill = getNewstmp();
        while (mil1 <= laststmp) {
            mill = getNewstmp();
        }
        return mill;
    }

    private long getNewstmp() {
        return System.currentTimeMillis();
    }

    public static void main(string[] args) {
         SnowFlake snowFlake = new SnowFlake(2, 3);

        for (int i = θ; i < (1<< 12); i++) {
            System.out.println(snowFlake.nextId());
        }
    }
}
```

> 参考开源工具类：https://github.com/beyondfengyu/SnowFlake
