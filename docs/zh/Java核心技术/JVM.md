## 1、Java 为什么能一次编写，处处运行？

Java 是一种特殊的高级语言，Java 程序的运行过程必须经过**先编译、后解释** 两个步骤。

Java 源文件（java）需要先编译为字节码文件（.class），然后再由 Java 虚拟机（JVM）解释执行，JVM 就作为这个转换器，可以让同一个字节码文件在不同系统平台上运行，从而实现了“**一次编译，到处运行**”的效果。

## 2、JVM 是什么？

JVM 是 Java Virtual Machine（Java 虚拟机）的缩写。

Java 语言的一个非常重要的特点就是与平台的无关性，即跨平台，而使用虚拟机是实现这一特点的关键。

一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而有了 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言在不同平台上运行时不需要重新编译。

## 3、JVM 由哪些组件组成的？

JVM 主要由以下几个部分组成：

- **Class Loader（类加载器）**：负责将编译后的.class 类加载到 JVM 中，并在运行时解析这些类。
- **Execution Engine（执行引擎）**：执行引引擎包含解释器和即时编译器，它负责执行加载到 JVM 中的字节码指令。
- **Runtime Data Area（运行时数据区）**：运行时数据区包括方法区、堆、Java 栈、本地方法栈和程序计数器等几个部分，它们负责存储程序运行时所需的数据。
- **Native MethodInterface（本地方法接口）**：本地方法接口允许 Java 程序调用本地方法。
- **Java Native Interface（Java 本地接口）**：Java 本地接口允许本地方法调用 Java 程序。

## 4、常用的 JVM 参数有哪些？

参数格式为：-XX:+参数或者-XX:-参数，“+"表示开启，“-"表示关闭，如下图所示：

![](/images/JVM/4_1.jpg)

以下是一些常用的 JVM 参数：

![](/images/JVM/4_2.jpg)

## 5、HotSpot 是什么？

HotSpot 是目前使用最广泛的 JVM 实现之一，也是 Oracle JDK 和 OpenJDK 中默认的 JVM 实现。

HotSpot 是由 Sun 公司开发的一款 Java 虚拟机，它是一种基于即时编译(Just-In-Time,JIT) 技术的 JVM 实现，具有高性能和优化能力。

## 6、JVM 内存区域分类哪些？

我们知道的 JVM 内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。

![](/images/JVM/6_1.jpg)

##### 线程不共享区域

---

每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。

##### 程序计数器(ProgramCounterRerister)

程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。

##### 虚拟机栈(VMStack)

虚拟机栈描述的是 Java 方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

##### 本地方法栈(NativeMethodStack)

本地方法栈用于支持本地方法（native 标识的方法，即非 Java 语言实现的方法）。

虚拟机栈和本地方法栈，当线程请求分配的栈容量超过 JVM 允许的最大容量时抛出 StackOverflowError 异常。线程不共享区域如下图绿色背景所示。

![](/images/JVM/6_2.jpg)

##### 线程共享区域

---

线程共享区域包含：堆和方法区。

##### 堆(Heap)

堆是最常处理的区域，它存储在 JVM 启动时创建的数组和对象，JVM 垃圾收集也主要是在堆上面工作。

如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出 OutOfMemoryError 异常。

##### 方法区(Method Area)

方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。

当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出 OutOfMemoryError

##### 运行时常量池(Runtime ConstantPool)

运行时常量池是方法区的一部分，每一个运行时常量池都分配在 JVM 的方法区中，在类和接口被加载到 JVM 后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。

如果方法区的内存空间不能满足内存分配请求，那 Java 虚拟机将抛出一个 OutOfMemoryError 异常。

![](/images/JVM/6_3.jpg)

栈包含 Frames，当调用方法时，Frame 被推送到堆栈。一个 Frame 包含局部变量数组、操作数栈、常量池引 l 用。

## 7、什么是 Java 内存模型？

Java 内存模型，即：**Java Memory Model**，简称：**JMM**，规定了**所有的变量都存储在主内存**中，每条**线程还有自己的工作内存**，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，**线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存**。

不同的线程之间也**无法直接访问对方工作内存中的变量**，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

![](/images/JVM/7.jpg)

> 注意：图中描述的本地内存就是指工作内存。

## 8、Java 内存模型和 JVM 内存模型的区别？

##### Java 内存模型与 JVM 内存模型不是同一个概念。

JVM 内存模型是从运行时数据区的结构的角度描述的概念，而 Java 内存模型是从主内存和线程私有内存角度的描述。

##### 从以下两张图可以看出：Java 内存模型：

![](/images/JVM/8_1.jpg)

##### JVM 内存模型：

![](/images/JVM/8_1.jpg)

## 9、Java8 中的内存结构有什么变化？

> Java8（Hotspot）移除了永久代，新增了元空间（Metaspace）。

Java 7 及以前版本的 Hotspot 方法区位于永久代，同时，永久代和堆虽然是相互隔离的，但它们使用的物理内存是连续的。

![](/images/JVM/9.jpg)

而 Java 8 中的方法区存在于元空间中，同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。

## 10、Java8 中的永久代为什么被移除了？

##### Java 8（Hotspot）移除了永久代，新增了元空间（Metaspace）。

##### 有 2 点原因：

1）永久代用来存储类的元数据和常量池等信息，使用的是虚拟机内存，很容易造成内存 OutOfMemoryError 异常。而元空间直接使用本地内存，默认情况下元空间是可以无限使用本地内存的，只要本地内存足够就避免了出现 OutOfMemoryError 异常。

2）因为 JRockit 中并没有永久代，移除永久代可以促进 HotSpot JVM 与 JRockit VM 的融合。

## 11、堆和栈区别是什么？

![](/images/JVM/11_1.jpg)

栈内存用来存储基本类型的变量和对象的引 l 用，堆内存用来存储 Java 中的对象。

![](/images/JVM/11_2.jpg)

栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。

堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。

## 12、Java 中有哪几类常量池？

Java 中有 3 类常量池，它们分别是：

- cass 常量池
- 运行时常量池
- 字符串常量池

---

##### 1、class 常量池

Class 文件常量池，即静态常量池（**Constant Pool**），每一个字节码文件（.class）都会有一个 Class 文件常量池。

我们可以使用以下命令查看：

> javap -v Test.class

![](/images/JVM/12.jpg)

如图，命令列出了 Test.class 文件中的 class 常量池，常量池中有字面量和符号引用等，JVM 能根据这个常量池找到要执行的类名、方法名、参数类型、字面量等类型。

##### 2、运行时常量池

运行时常量池，即：**Runtime Constant Pool**，每一个字节码文件（.class）在加载时都会对应一个运行时常量池。JVM 在运行时，会加载 class 常量池中的常量（除字符串常量）到运行时常量池中，而字符串常量会加载到字符串常量池中，class 常量池中符号引用会被转化为直接引用，即真实的内存地址。

##### 3、字符串常量池

字符串常量池，即：**StringTable**，其实就是一个哈希表，它是 Java 中一种特殊的运行时常量池，主要存储所有的字符串字面量和字符串对象。

每个 VM 只有一个字符串常量池，字符串单独划分的目的是为了提高字符串的重用性，降低内存开销。

## 13、常量池存储在哪些内存区域？

不同的 JDK 版本，各个常量池存储的内存区域不同。

| 常量池       | JDK 6               | JDK 7  | JDK 8  |
| ------------ | ------------------- | ------ | ------ |
| class 常量池 | 永久代              | 永久代 | 元空间 |
| 运行时常量池 | 永久代              | 永久代 | 元空间 |
| 字符串常量池 | 永久代 运行时常量池 | 堆     | 堆     |

如图所示：

![](/images/JVM/13_1.jpg)

![](/images/JVM/13_2.jpg)

![](/images/JVM/13_3.jpg)

## 14、运行时常量池和字符串常量池的区别？

##### 运行时常量池和字符串常量池的区别：

1、运行时常量池只是一个统称，字符串常量池也是一种特殊的运行时常量池，VM 运行时，基础类型的常量（除了字符串常量)会加载到运行时常量池中，字符串常量会单独加载到字符串常量池中。

2、在 Java7 之前，字符串常量池属于运行时常量池的一部分，Java 7 开始，字符串常量池划到了堆中。

3、运行时常量池存储的信息更多，包括类信息、属性信息、方法信息、基础类型常量池（如：int、long）等，而字符串常量池只保存字符串常量,

4、运行时常量池每个 class 都会对应一份，而字符串常量池是全局唯一的，每个 JVM 只有一份。

## 15、JVM 哪块内存区域不会发生内存溢出？

##### 程序计数器（ProgramCounterRerister）不会内存溢出。

程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。

## 16、JVM 从 GC 角度看，堆的分区情况？

##### JVM 从 GC 角度看，堆可分为：

- 新生代：Eden 区和 Survivor 区(from 区和 to 区，或者 S0, S1)
- 老年代 (Old)
- 永久代 (Java 8+为元空间，并且和堆不连续)

![](/images/JVM/16.jpg)

## 17、为什么堆要分新生代和老年代？而不是一个老年代就行？

因为堆中的大部分对象都是朝生夕死的，GC 的成本很高，分为多个区以存储不同生命周期的对象，这样就可以使用针对性的 GC 算法和收集器，以提高 GC 性能。

## 18、为什么新生代要分成 Eden 和 Survivor 两个区？

因为新生代 Eden 区的绝大部分对象的生命周期都很短，为了避免对象过早的进入老年代，以引发老年代频繁 FullGC，所以分成 Eden 区和 Survivor 区，Survivor 区则作为 Eden 区和老年代之间的一个缓冲区。

## 19、为什么新生代 Survivor 区又分为两个区？一个不行吗？

新生代 Survivor 区又分为两个区，这样是为了解决内存碎片问题。

假如只有一个 Survivor 区的流程如下:

1）新对象创建在 Eden 区中；

2）Eden 区满了就会触发一次 Minor GC，Eden 区中的存活对象就会被移动到 Survivor 区，此时 Eden 区和 Survivor 区各有一些存活对象；

3）Eden 再次满了触发 Minor GC，Survivor 区在经过垃圾回收后，Eden 区中的存活对象如果再次移动到 Survivor 区，它们所占有的内存就是不连续的，就会导致内存碎片化。

因为有了 S1 区，复制算法可以保证 Eden 和 S0 两区中的存活对象一起复制到 S1 区中是连续的内存空间，然后清空 Eden 和 S0 区，直到 S1 被移动老年代，这样始终就会有一块 Survivor 是空置的，保证整个复制过程不会产生碎片。

## 20、新生代各分区的默认比例是怎样的？

新生代 Eden 区和 Survivor 区（S0,S1）的默认比例是：8:1:1

- Eden 区占用 80%
- S0 区占用 10%
- S1 区占用 10%

## 21、哪些情况下存活对象会进入老年代？

##### 存活对象进入老年代的情况：

- nor GC 之后，如果另外一块 Survivor 区不够空间存放存活对象，则把这些对象直接移入老年代；
- 每触发一个 Minor GC，对象的年龄+1，当到达 16 次 Minor GC 的时候就会被移到老年代，也就是成功躲过了默认的 15 次 Minor GC，可以通过-XX:MaxTenuringThreshold 参数设置；
- urvivor 区中的一批对象如果超过了当前区域空间的 50%，大于等于这批对象年龄的对象就直接进入老年代；
- 超过指定字节的大对象直接进入老年代，可以通过-XX:PretenureSizeThreshold 参数设置；

## 22、什么情况下会发生栈内存溢出？

因为栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息，如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出**StackOverflowError**栈内存溢出异常，一般在方法递归调用时会造成栈内存溢出。

可以通过 JVM 参数**-Xss** 来调整栈内存的大小。

## 23、对象都是在堆上分配的吗？

不一定，满足特定条件时，它们可以在 **虚拟机栈**上分配内存。

JVM 通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。

## 24、什么是直接内存？

直接内存（**Direct Memory**）就是指：**Java 堆外内存**，直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，与 Java 堆内存不同的是，直接内存不受 Java 堆大小的限制，因此在需要处理大量数据时，使用直接内存可以提高性能。

## 25、直接内存有什么用？

直接内存的好处就是为了能直接分配和释放内存，避免了在 Java 堆和 native 堆中来回复制数据，通常用于处理 IO 操作、网络传输和高性能计算等场景，可显著提高性能。

但需要注意的是，直接内存的分配和释放比较耗费资源，因此需要谨慎使用，如果使用不当，直接内存也会出现 OutOfMemoryError 异常。

## 26、怎样访问直接内存？

在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引 I 入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存。

直接内存的访问具体可以通过 Java NIO 库中的 **ByteBuffer** 对象来访问，先使用 **ByteBuffer.allocateDirect** 方法可以分配直接内存，然后使用**ByteBuffer.put 和 ByteBuffer.get** 等方法来读取和写入直接内存中的数据。

示例代码：

```java
public static void main(string[] args) {
    //分配直接缓冲区，大小为1024字节
    ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
    //写入数据到直接缓冲区
    directBuffer.put((byte) 123);
    //切换为读模式
    directBuffer.flip();
    //从直接缓冲区读取数据
    byte value = directBuffer.get();
    //读取的值：123
    System.out.println("读取的值：" + value);
}
```

## 27、程实现一个读写直接内存的示例

如下面的示例，从直接内存读写一个字符串：

```java
public class Test {
    public static void main(string[] args) throws Exception {
        // 分配直接内存
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

        // 获取直接内存的地址
        long address = ((DirectBuffer) buffer).address();

        // 写入数据
        buffer.put("小程序：Java面试题".getBytes(Standardcharsets.UTF_8));

        //从直接内存中读取数据
        buffer.flip();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        System.out.println(new String(bytes));

        //释放直接内存
        Cleaner cleaner = ((DirectBuffer) buffer).cleaner();
        if (cleaner |= null){
            cleaner.clean();
        }
    }
}
```

输出结果：

![](/images/JVM/27.jpg)

## 28、JVM 是怎么加载字节码文件的？

.class 字节码加载流程如下:

![](/images/JVM/28.jpg)

##### 1、加载：

JVM 读取指定的.class 文件，并将其转换为 JVM 内部格式的字节码。

##### 2、链接：

- 2.1 验证：JVM 检查字节码是否符合规范及安全要求，以确保它不会危害 JVM 的健康运行。

- 2.2 准备：JVM 为静态变量分配内存，并将其初始化为默认值，以准备类的静态变量使用。

- 2.3 解析：JVM 将符号引用转换为直接引用，即将类、接口、字段和方法的名称解析为 JVM 内部的引 I 用地址。

##### 3、初始化：

JVM 将执行类构造函数，初始化静态变量并执行静态代码块。

## 29、什么是类加载器？

类加载器（ClassLoader） 用来加载 .class 类到 Java 虚拟机中，Java 所有的类加载器都是 java.lang.ClassLoader 类的一个实例，类加载器可以从本地文件系统、网络或其他来源加载类，并且可以根据需要创建类的多个实例。

Java 中的每个类都由类加载器加载，并且在 Java 应用程序运行时，类加载器会动态加载和卸载类。

##### 一般来说，Java 虚拟机使用 Java 类的方式如下：

（1）Java 源程序（java 文件）在经过 Java 编译器编译之后，被转换成 Java 字节代码（.class 文件）。

（2）类加载器负责读取.class 类字节代码，并转换成 java.lang.Class 类的一个实例。

## 30、类加载器（ClassLoader）有哪些方法？

下面是 Java 类加载器（ClassLoader）的常用方法：

| 方法名称                                            | v                               |
| --------------------------------------------------- | ------------------------------- |
| loadClass(String name)                              | 通过指定的类名加载类。          |
| findClass(String name)                              | 查找并加载指定名称的类。        |
| defineClass(String name, byte[] b, int off int len) | 将类的字节码转换为 Class 对象。 |
| resolveClass(Class<?> c)                            | 链接指定的 Class 对象。         |
| getParent()                                         | 返回该类加载器的父加载器。      |
| getResource(String name)                            | 获取指定名称的资源。            |
| getResources(String name)                           | 获取指定名称的所有资源。        |
| getSystemClassLoader()返回系统类加载器。            | 返回系统类加载器。              |

## 31、类加载器的分类及作用？

##### 从虚拟机层面讲分为两大类型的类加载器：

- ootstrapClassloader，即启动类加载器（C++实现），它是虚拟机的一部分；
- 其他类型类加载器（Java 实现）在虚拟机外部，并全部继承 ClassLoader 类。

---

##### 从细分的角度讲会分为以下三大类加载器：

![](/images/JVM/31.jpg)

##### 1、 Bootstrap ClassLoader

启动类加载器，完全由 JVM 控制加载，外面访问不到这个类加载器，即不能被 Java 程序引用。它主要负责加载 JVM 自身的工作类，即 java/lib 目录和-X:bootclasspath 参数指定的目录的类库。从上图看虽然 Bootstrap ClassLoader 是最顶层的类加载器，也是 ExtClassLoader 的父类加载器，但是不能被程序引用。

##### 2、Extension ClassLoader

扩展类加载器，由 Java 实现，即 ExtClassLoader 实现类，它主要负责加载 java/lib/ext 目录和系统环境变量 java.ext.dirs 指定目录所有类库。

##### 3、 Application ClassLoader

应用程序类加载器，由 Java 实现，即 AppClassLoader 实现类，它的父类是 ExtClassLoader，它主要负责加载 classpath 目录上的类库。

如果没有自定义 ClassLoader，它就是程序中默认的 ClassLoader，即可以通过 ClassLoader.getSystemClassLoader()获取当前系统的类加载器。

## 32、什么时候会用到自定义类加载器？

标准 Java 类加载器只能加载本地正常的.class 类，如果有特殊需求，就需要自定义类加载器，比如以下几种情况：

- 载网络上的类；
- 载加密的类；
- 加载动态生成的类；
- 隔离多个应用程序的类；

## 33、编程输出当前类加载器及所有父类加载器

来看下面的例子：

```java
public static void main(string[] args) throws Exception {
    ClassLoader C = ClassLoader.getSystemclassLoader();
    System.out.println(c);
    while ((c = c.getparent()) != null) {
        System.out.println(c);
    }
}
```

输出结果：

![](/images/JVM/33.jpg)

程序首先输出了程序默认的类加载器 AppClassLoader，然后再输出了其父类加载器 ExtClassLoader。

## 34、编程实现一个自定义的类加载器

> 编程实现一个自定义的类加载器，加载自定义目录下 c:/test/com/testjdk/Key.class 这个类。

读取自定义目录的类：

```java
@Tostring
public class Key {
    private String key = "111111";
}
```

自定义 ClassLoader：

```java
public class CustomclassLoader extends ClassLoader {
    private String classPath;
    public CustomclassLoader(string classPath) {
        this.classPath = classPath;
    }

    @override
    protected class<?> findclass(string name) throws ClassNotFoundException {
        try {
            String fileName = name.replaceAll("\\.", "/");
            File file = new File(classPath + fileName + ".class");
            if (lfile.exists()) {
                return super.findclass(name);
            }
            byte[] bytes = Files.readAllBytes(file.toPath());
            return defineclass(name, bytes, 0, bytes.length);
        }catch (IoException e){
            throw new ClassNotFoundException(name, e);
        }
    }

    public static void main(string[] args) throws Exception {
        String classpath = "c:/test/";
        CustomclassLoader loader = new CustomclassLoader(classPath);
        Class<?> clazz = loader.loadclass("cn.javastack.test.Key");
        Key key = (Key) clazz.newInstance();
        System.out.println(key);
    }
}
```

自定义类加载器正常加载到类，程序最后输出：111111

## 35、什么是双亲委派模型？

双亲委派模型是 Java 中的一种类加载机制，保证 Java 类的安全性和稳定性。

##### 双亲委派模型的主要思想：

双亲委派模式要求所有类加载器，除了顶层的 Bootstrap 类加载器之外都要有自己的父类加载器。

![](/images/JVM/35.jpg)

当一个类加载器收到类加载请求时，它首先会将该请求委派给父类加载器进行处理，如果父类加载器无法找到相应的类，才会由子类加载器来尝试加载。这种层层向上委派的机制能够确保 Java 类不会被重复加载，也能够防止恶意类的加载，提高了 Java 应用的安全性和稳定性。

## 36、Class.forName 和 ClassLoader 的区别？

Class.forName() 和 ClassLoader 都可以用于动态加载类。

Class.forName(是一个静态方法，用于加载并返回指定名称的类，它在加载类的同时执行类的静态代码块，默认情况下，Class.forName(使用调用者的类加载器加载类。

ClassLoader 是一个抽象类，它是用于加载类的基类，可以通过继承 ClassLoader 类并实现其中的方法来创建自定义类加载器。

> ##### 最重要的一个区别是：
>
> Class.forName 除了将类的.class 文件加载到 JVM 中之外，还可以对类进行初始化。ClassLoader 只是将.class 文件加载到 JVM 中，不会进行初始化。

## 37、ClassLoader 中的 defineClass,findClass,loadClass 的区别？

defineClass 和 findClass 通常是由自定义类加载器实现，而 loadClass 则是由 Java 的默认类加载器实现的。

- defineClass 方法负责将字节码转换为一个 Class 对象。

- findClass 方法用于根据名称或位置加载.class 文件字节码。

- loadClass 方法是 Java 类加载的主要方法，默认的双亲委派机制就实现在这个方法中。

> ##### ClassLoader 这几个方法的执行顺序是：
>
> loadClass → findClass → defineClass
>
> 自定义类加载器时，除非需要打破双亲委派机制，否则不建议重写 loadClass 方法，因为如果类加载失败 loadClass 方法会调用 findClass 方法继续加载。

## 38、什么是类卸载？什么情况下会卸载？

类卸载**（Class Unloading）**是指在 Java 虚拟机中卸载不再需要的类，可以有效释放类占用的内存空间。类的卸载过程通常发生在垃圾回收过程中，Java 虚拟机会自动监测并卸载一些不再需要的类，当一个类不再被任何对象引用时，该类就会被卸载。

因为，当一个 Java 应用程序长时间运行时，可能会加载大量的类，如果不及时卸载不再需要的类，就会占用大量的内存空间，导致应用程序运行缓慢或崩溃。

> 类卸载是自动执行的，如果需要手动触发类卸载，可以通过 Java 虚拟机的诊断和调试接口（JVMTI）来实现。但要特别小心，如果误操作可能会导致应用程序崩溃。

## 39、解释执行和编译执行的区别？

解释执行和编译执行是两种不同的程序执行方式：

**解释执行**：即每次逐行解释字节码为本地机器码并执行。

**编译执行**：即 IT 即时编译，将热点代码动态编译成本地机器码并缓存起来，从而提高程序的执行效率。

## 40、解释执行和编译执行哪个更快？

通常情况下，**编译执行要比解释执行更快**，因为以下几点：

（1）编译执行后的程序不需要再次解释，可以直接就可以被计算机执行，而解释执行需要在每次执行之前解释代码。

（2）编译执行可以在编译时进行优化和调整，使编译后的程序能够更好地利用计算机硬件的性能，从而提高程序的执行效率。

## 41、Java 是解释执行还是编译执行？

##### Java 既可以解释执行，也可以编译执行，具体取决于程序的执行环境和编译器。

（1）当 Java 程序运行在 JVM 中时，程序会被先编译成字节码，然后由 JVM 在运行时解释执行字节码。这种方式被称为解释执行。

（2）VM 也可以使用 JIT(Just-In-Time)技术将字节码动态编译成本地机器码，从而提高程序的执行效率，这种方式被称为 JIT 编译执行。

此外，对于需要更高执行效率的应用场景，也可以使用 AOT(Ahead-Of-Time)技术将 Java 程序编译成本地机器码，从而避免了解释执行和 JIT 编译执行过程中的性能损耗。

## 42、什么是热点探测技术？

热点探测技术是一种用于检测应用程序中热点代码的技术，热点代码是指应用程序中被频繁执行的代码块，优化热点代码可以提高程序的性能。

## 43、热点探测技术都有哪些？HotSpot 用的是哪种？

热点探测技术主要包括以下几种：

- **基于采样的热点探测技术**：通过周期性地采样应用程序的执行堆栈，统计每个函数被调用的次数和执行时间，并识别出热点代码。

- **基于计数器的热点探测技术**：通过对代码块执行的次数和执行时间进行计数，并将其与预定义的阈值进行比较，从而判断哪些代码块是热点代码。

- **基于静态分析的热点探测技术**：在编译阶段对源代码进行分析，找出热点代码，并将其标记为即时编译的优化目标。

Hotspot JVM 使用的是信"**基于计数器**”的热点探测技术，Hotspot 使用了**方法调用计数器**（Method InvocationCounter）和**回边计数器**（Back EdgeCounter）来统计方法调用和循环执行的次数，以判断哪些代码块是热点代码，并将其进行即时编译和优化。

## 44、什么是 JIT？

JIT 全称为 **Just-In-Time**，即：**即时编译**。

JIT 是一种在运行时将代码编译成机器码的技术，与传统的预先编译器（AOT）不同，即时编译（JIT）代码是在程序运行时编译成机器码的，而不是预先编译为机器码。

## 45、JIT 为什么能够提升程序性能？

Java 程序编译执行过程 :

> Java 源代码（java）->编译成字节码（.class）->逐条编译为机器码->执行

Java 虚拟机最开始是通过解释器进行解释执行的，JVM 需要逐条将字节码编译成机器码，当虚拟机发现某个方法或者代码块的运行特别频繁时，反复多次编译就会影响性能。

所以，JVM 引 I 入了 JIT 即时编译技术，JIT 会把频繁执行的代码认定为“**热点代码**”，然后对热点代码进行优化，即将这些代码编译成与本地平台相关的机器码并保存起来，避免重复编译。所以，川 T 即时编译可以用来提高程序的执行速度，以实现程序更高效的执行。

## 46、为什么 JIT 只对热点代码进行即时编译？

主要有以下两个原因：

##### (1）热点代码占用了程序的大部分运行时间

在大多数情况下，一个程序的大部分运行时间可能都花费在热点代码上，而其他代码往往只会被执行一次或几次。所以，优化热点代码的执行效率可以极大地提高整个程序的性能。

##### (2）消耗大量的 CPU 和内存资源

即时编译需要在运行时对代码进行分析、优化和编译，这需要消耗大量的 CPU 和内存资源。所以，如果对所有代码进行即时编译，必然会导致程序运行性能下降。

所以，JIT 编译器只对热点代码进行即时编译，以在保证性能的同时，尽量减少对其他代码的影响。

## 47、HotSpot 都支持哪些 JIT 编译器？

HotSpot JVM 支持以下两种 JIT 编译器:

##### 1、C1 编译器

它是一种基于方法的编译器，使用轻量级的编译策略来快速编译和优化字节码，以加速程序的启动时间。该编译器通常用于客户端应用程序，因为客户端应用程序需要快速启动和响应。

##### 2、C2 编译器

它是一种基于模块的编译器，使用全面的编译策略来对热点代码进行优化，以提高程序的运行速度。该编译器通常用于服务器应用程序，因为服务器应用程序需要高性能和可伸缩性。

> HotSpotVM 中的 JIT 编译器可以根据应用程序的实际运行情况进行动态切换，以达到最佳的性能优化效果。默认情况下，HotSpotJVM 会使用 C2 编译器来编译热点代码，但是可以通过启动参数来指定使用不同的编译器。

## 48、什么是 AOT？

AOT 全称为**Ahead-Of-Time**，即：**预先编译**。

AOT 将源代码的编译过程提前到程序运行之前，在程序运行之前，将源代码编译为机器码，从而减少了程序启动时间，并且能够生成更快、更节省资源的可执行文件。

## 49、AIT 和 AOT 的区别？

JIT 和 AOT 是两种不同的代码编译技术:

- JIT 全称为：Just-in-time，即时编译（动态编译），即边运行边编译。
- AOT 全称为：Ahead OfTime，预先编译，即运行前编译。

##### 主要区别在于编译发生的时间和优化方式：

JIT 是在程序运行时将代码编译成机器码的技术。当程序被执行时，IT 编译器会将程序的字节码编译成本地机器码，从而提高程序的执行速度。川 T 编译器通常只编译程序中的热点代码，这样可以提高程序的性能，同时减少编译时间和内存占用。

AOT 是在程序部署时将代码编译成机器码的技术。在 AOT 中，程序的源代码会被编译成本地机器码，然后打包成可执行文件，部署到目标计算机上。与 IT 不同，AOT 编译器可以对整个程序进行编译，因此程序启动时不需要进行额外的编译步骤，从而提高了程序的启动速度。

## 50、JIT 和 AOT 怎么选择？

选择 JIT (Just-In-Time) 还是 AOT (Ahead-Of-Time) 取决于具体的应用场景和需求:

##### 1）执行时间 vs 启动时间

JIT 技术适合长时间运行的应用程序，因为 JIT 编译器可以根据程序的实际运行情况进行动态优化，从而提高程序的执行效率。

而 AOT 技术适合需要快速启动并运行的应用程序，因为 AOT 编译器可以将程序的源代码编译成本地机器码，从而减少启动时间。

##### 2）程序的大小

AOT 编译的程序通常比川 IT 编译的程序更大，因为它们包含了编译后的本地机器码和其他必要的信息。如果程序的大小对应用的性能有影响，可以考虑使用川 IT 编译技术。

##### 3）程序的复杂度

如果程序非常复杂，其中包含大量的代码和依赖关系，使用 AOT 技术可能会更容易，因为 AOT 编译器可以在编译时进行全局优化，从而避免了川 IT 编译器在运行时进行的多次优化。

##### 4）开发效率&运行效率

AOT 技术可以提高程序的运行效率，但在编译时需要较长的时间。如果开发者更注重开发效率，可以使用 JIT 技术，因为它可以快速编译并运行代码。

---

总之，川 IT 编译技术适用于需要动态加载代码的情况，而 AOT 编译技术适用于需要快速启动并运行的情况。

在实际应用中，选择使用 JIT 还是 AOT 取决于具体的应用场景和需求，比如要考虑到程序的性能、大小、复杂度以及开发效率等方面，从而选择适合自己应用的编译技术。

## 51、Java 内存模型定义了哪几种原子操作？

Java 内存模型中定义了 8 种原子操作。

| 原子操作 | 描述                                                                                   |
| -------- | -------------------------------------------------------------------------------------- |
| lock     | 作用于主内存，把一个变量标记为一条线程独占状态。                                       |
| unlock   | 作用于主内存，解除对某个主内存地址的锁定。                                             |
| read     | 作用于主内存，从主内存中读取一个变量的值到线程的工作内存中，以便随后的 load 操作使用。 |
| load     | 作用于工作内存，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。         |
| use      | 作用于工作内存，它把工作内存中的一个变量值传递给执行引擎。                             |
| assign   | 作用于工作内存，它把一个从执行引擎接收到的值赋给工作内存的变量。                       |
| store    | 作用于工作内存，它把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。  |
| write    | 作用于主内存，它把 store 操作从工作内存中的一个变量的值传送到主内存的变量中。          |

Java 内存模型中的原子操作是建立在底层硬件支持的基础上，可以确保在多线程环境下，对于被多个线程访问的共享变量的操作具有原子性和可见性，从而保证了多线程程序的正确性和可靠性。

## 52、什么是指令重排序？

Java 为了优化程序性能，代码在实际运行时，代码指令可能并不是严格按照代码语句的顺序执行的，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做**指令重排序**。

大多数现代处理器都会采用将指令乱序执行的方法，在条件允许的情况下，直接执行后面的指令，通过乱序执行的技术处理器可以大大优化程序性能，提高执行效率。

## 53、指令重排序分为哪几种？过程是怎样的？

##### 指令重排序主要分为以下三种：

1）编译器重排序：JVM 中进行完成的。

2）指令级并行重排序。

3）处理器重排序：CPU 中进行完成的。

##### 源代码到最终执行的指令序列过程图：

![](/images/JVM/53.jpg)

> 重排序需要遵守 happens-before 规则。

## 54、怎么避免指令重排序？

##### 避免指令重排序常用方法：

（1）可以使用 volatile 关键字来保证指令执行的有序性，使用 volatile 关键字可以将变量的写入操作和读取操作插入内存屏障，这样可以防止指令重排序。

（2）Java 中还有一些并发工具，比如 Atomic 原子类、ConcurrentHashMap 并发类等，它们也可以确保关键指令不被重排序，以保证多线程并发执行的正确性。

## 55、synchronized 可以防止指令重排序吗？怎么实现的？

synchronized 可以保证一定程度上的有序性，也可以防止一定程度上的指令重排序，**但并不能完全阻止所有的指令重排序**。比如，同步块内/外的代码肯定是不会相互乱排的，但同步块里面的代码是避免不了指令重排序的。

虽然`synchronized`不能完全阻止指令重排序，但它不会影响线程执行的结果（根据 **as-if-serial** 语义），也不会影响锁的获取与释放，在获取锁之前和释放锁之后会进行内存屏障操作，从而保证了多线程执行的有序性。

## 56、volatile 可以防止指令重排序吗？怎么实现的？

volatile 可以保证有序性，这里指的是**禁止指令重排序**，其原理主要是通过编译器在生成字节码时，在指令序列中添加“**内存屏障**”来禁止指令重排序的。

内存屏障类型说明:

| 内存屏障   | 作用位置            | 描述                                                                     |
| ---------- | ------------------- | ------------------------------------------------------------------------ |
| StoreStore | volatile 写操作之前 | 禁止写和写的重排序，确保之前的写入操作对这次 volatile 写操作可见         |
| StoreLoad  | volatile 写操作之后 | 禁止写和读的重排序，确保这次 volatile 写操作对后续的读操作可见           |
| LoadLoad   | volatile 读操作之后 | 禁止读和读的重排序，确保不会把后续的读操作重新排序到这次 volatile 读之前 |
| LoadStore  | volatile 读操作之后 | 禁止读和写的重排序，确保不会把后续的写操作重新排序到这次 volatile 读之前 |

如下图示例所示：

![](/images/JVM/56.jpg)

volatile 重排序规则如下表所示：

| 是否能重排序 | 第二个操作 | 第二个操作  | 第二个操作  |
| ------------ | ---------- | ----------- | ----------- |
| 第一个操作   | 普通读和写 | volatile 读 | volatile 写 |
| 普通读/写    | YES        | YES         | NO          |
| volatile 读  | NO         | NO          | NO          |
| volatile 写  | YES        | NO          | NO          |

## 57、什么是 as-if-serial 语义？

**as-if-serial** 语义是 Java 内存模型（Java Memory Model，JMM）中的一个重要原则，它规定了在多线程环境下，虚拟机如何处理指令重排序和优化，以保证程序的执行结果与串行执行的结果一致。

换句话说，**as-if-serial** 语义是指，不管编译器和处理器等如何优化指令重排序，但必须确保程序的执行结果和单线程程序的执行结果一致，避免了多线程环境中的不确定性。

所以，编译器和处理器等都必须遵守`as-if-serial`语义，不能对存在数据依赖关系的操作做重排序。

## 58、内存屏障是什么？有哪些类型？

**内存屏障** 也叫内存栅栏，是一种 CPU 指令，它的作用是确保多线程程序中的数据一致性和可见性，避免了多线程访问共享变量时可能发生的数据竞争和死锁等问题，是实现多线程程序中同步和协作的重要手段。内存屏障可以分为以下两种类型：

- **读屏障（Load Barrier）**：用于确保一个线程读取的变量值是最新的，即在该屏障之前发生的所有写操作已经对其他线程可见。
- **屏障（Store Barrier）**：用于确保一个线程对共享变量的修改对其他线程可见，即在该屏障之后的所有读操作都可以看到最新的变量值。

## 59、GC 是什么？为什么需要 GC？

GC 是垃圾回收（**Garbage Collection**）的缩写，它是一种内存自动管理技术，用于在程序运行时自动识别和回收不再使用的内存资源，防止内存泄漏和程序崩溃等问题。

**为什么需要 GC？**

传统的手动内存管理方式，程序员需要显式地分配和释放内存资源，容易出现内存泄漏、越界访问等问题，同时也增加了程序员的负担和出错概率。

而使用 GC 技术，可以使内存管理自动化，减轻程序员的负担，提高程序的稳定性和安全性。

## 60、什么是 Young GC?

##### Young GC，即年轻代的 GC，等同于 Minor GC。

## 61、什么是 MinorGC?

**Minor GC**（也称为 **Young GC**）是指对新生代（包括 Eden 和 Survivor 区）进行垃圾回收的过程。在 Minor GC 过程中，垃圾回收器会清除不再使用的对象，将存活的对象移动到 Survivor 区或者年老代中。

在这个区的对象生存期短，往往发生 GC 的频率较高，回收速度比较快，一般采用复制回收算法。

## 62、什么是 FullGC?

Full GC（**Full Garbage Collection**）指的是对整个 Java 堆（包括新生代和年老代）、方法区（永久代、元空间）进行垃圾回收的过程。在 Full GC 过程中，垃圾回收器会清除不再使用的对象，并将堆中的内存空间进行整理和压缩，以便更好地利用内存空间。

相比 Minor GC 和 Major GC，Full GC 的代价通常更高，因为它需要对整个 Java 堆进行垃圾回收，可能需要暂停应用程序的运行，导致较长的停顿时间。因此，在实际应用中，我们应该尽量避免 Full GC 的触发，并通过合理的内存管理和优化来减少 Full GC 的频率和代价。

## 63、什么时候会触发 MinorGC？

新创建的对象在新生代 Eden 区中进行分配，如果 Eden 区内存空间满了，就会触发一次 Minor GC/ Young GC：

- **如果 Survivor 区充足**：将 Eden 区中不再使用的对象会被清除掉，而存活的对象会被复制到 Survivor 区中；
- **如果 Survivor 区不足**：将 Survivor 区中不再使用的对象会被清除掉，而存活的对象会被复制到另一个 Survivor 区或者老年代中。

因为新生代中的对象生命周期较短，因此会更频繁地进行回收。在实际应用中，可以通过调整新生代的大小和 Survivor 区的比例，以及合理分配内存空间等方式来优化 Minor GC 的性能和效率。

## 64、什么时候会触发 FullGC？

##### 触发 FullGC 的几种情形：

- 手动调用了 System.gc( 方法时（慎用)
- inor GC 之后，如果大量对象仍然存活而导致两块 Survivor 空间不够用了，就会转移到老年代，此时如果老年代也不够用了就会触发 FullGC；
- 老年代最大可用连续空间〈历代老年代对象的平均大小时，会触发 Full GC；
- 达到了收集器设置的阈值，比如 CMS 老年代触发 FuIIGC 的使用比例默认是 92（%)
- 当元空间不足时 (JDK 1.7-为永久代不足)

## 65、一次完整的 GC 流程是怎样的？

内存区域不够用了，就会引发 GC。

对象的正常 GC 流程：

1. 新对象 -> Eden 区;
2. Eden 区满了之后，触发 Minor GC，Eden, SO 中的存活对象-> Survivor S1 区;
3. 清空 Eden 区和 S0 区;
4. 4.Eden 区再次满了之后，触发 Minor GC，Eden, S1 存活对象->S0 区，SO 和 S1 区这样角色反复互换;
5. Minor GC 之后，如果 Survivor 区不够空间存放存活对象，则把这些对象直接移入老年代；

## 66、什么是 GC 停顿？为什么要停顿？

GC 停顿，全称：**Stop The World**，是由于需要暂停应用程序线程来进行垃圾回收操作，导致应用程序线程无法继续运行，从而出现一段时间的停顿现象。

##### GC 停顿通常分为以下两种：

- Minor GC 停顿：发生在新生代垃圾回收时，此时 VM 会暂停应用程序的执行，对新生代进行垃圾回收；
- ull GC 停顿：发生在老年代垃圾回收时，此时 JVM 会暂停应用程序的执行，对整个堆进行垃圾回收；

停顿是必须的，因为只有暂停所有用户线程，这样才能保证系统不会产生新的垃圾，在 GC 标记回收对象时，可以保证对象的的有效性，否则会产生错标和漏洞问题。

## 67、如何减少长时间的 GC 停顿？

长时间的 GC 停顿可能会对应用程序的性能和用户体验造成很大的影响，因此需要通过以下几种方式来尽量减少长时间的 GC 停顿。

##### 1）选择合适的垃圾收集器

针对不同的应用场景，选择合适的垃圾收集器可以提高垃圾回收的效率，减少长时间的 GC 停顿。

> 例如，G1 垃圾收集器适用于大内存、高并发的应用场景，可以在多个小区域上分步执行 GC 过程，减少了垃圾回收暂停时间，从而避免了应用线程等待垃圾回收的时间。

##### 2）增加内存

当堆内存过小时，垃圾回收的频率会增加，导致长时间的 GC 停顿。因此，适当地增加堆内存大小可以有效减少 GC 的频率，降低长时间的 GC 停顿。

##### 3）避免过多的对象创建

避免过多的对象创建，可以减少 GC 的频率，从而降低长时间的 GC 停顿。

> 例如，可以通过对象池、字符串缓存等技术来复用对象，减少对象的创建。

##### 4）分批处理

将任务拆分成多个小任务进行处理，每个小任务的处理时间尽量不要超过一个 Minor GC 的时间。这样可以将 GC 停顿的时间分散到多个小任务中，从而降低长时间的 GC 停顿。

##### 5）使用并发 GC

如 CMS 和 G1，可以在垃圾回收过程中和应用程序同时运行，减少了垃圾回收对应用程序的影响，从而可以减少长时间的 GC 停顿。

## 68、JVM 如何判断一个对象可被回收?

##### 判断对象是否存活一般有两种方式：

##### 1）引用计数

参考面试题：《你怎么理解 GC 引用计数算法？》

##### 2）可达性分析算法

参考面试题:《你怎么理解 GC 可达性分析算法？》

但引用计数方法无法解决对象之间相互循环引用的问题，所以 Java 中使用了“可达性分析”的方式。

## 69、什么是 GCRoots？

GC Roots 是垃圾回收的根节点，是进行垃圾回收时，被视为存活对象的特殊对象。当一个对象不再被引用时，垃圾回收器可以将其回收，但是为了确定哪些对象可以被回收，垃圾回收器必须确定哪些对象是存活的，而 GC Roots 对象就是起始点，从这些根对象开始遍历可以到达的所有存活对象。

![](/images/JVM/69.jpg)

在上面的示例中，有一个 Thread 1 的线程和三个对象（A、B、C），线程 1 和对象 A 都是 GC Roots，都是垃圾回收算法的起点。对象 B 和 对象 C 都可以通过对象 A 访问，因此它们可以被视为存活对象。

## 70、GC Roots 包括哪些类型的对象？

GC Roots 包括以下几种类型的对象：

- 前正在执行的线程；
- 态对象，包括静态变量和静态代码块中的对象；
- NI（Java Native Interface）引 l 用，即在本地代码中创建的对象；
- 当前调用方法的局部变量和输入参数；
- 被引用的对象，即垃圾回收器已知道的其他存活对象；
- 拟机内部的一些特殊对象，如基本类的类对象和一些常驻的异常对象，如 OutOfMemoryError。

确定 GC Roots 可以帮助垃圾回收器识别哪些对象可以被回收，从而释放内存并提高应用程序的性能。

## 71、Java 对象头包含哪些信息？

Java 对象头是一个对象在堆内存中的元数据，它包含了一些关于对象的重要信息，包括以下内容：

| 信息      | 描述                                                                                            |
| --------- | ----------------------------------------------------------------------------------------------- |
| Mark Word | 包括对象状态、锁状态、GC 状态等信息                                                             |
| 类型指针  | 指向对象的类元数据的指针                                                                        |
| 数组长度  | 如果对象是一个数组，它会包含一个数组长度，表示数组的大小                                        |
| 对齐填充  | JVM 要求对象在内存中的起始地址必须是 8 字节的整数倍，因此需要填充一些无用的字节来满足这个要求。 |

不同的 JVM 实现可能会略有不同，但是以上信息都是 Java 对象头的常见组成部分。

## 72、Java 设计对象头的目的是什么？

Java 对象头的设计是为了支持 JVM 的高效内存管理和便于垃圾回收，它提供了重要的元数据信息，以支持 Java 程序在运行时对对象的动态分配、释放和垃圾回收等操作。

## 73、常用的垃圾收集器有哪些？

常用的垃圾收集器如下表所示：

| 收集器       | 启用                    | 分类       | 使用区域       | 算法          |
| ------------ | ----------------------- | ---------- | -------------- | ------------- |
| Serial       | -XX:+UseSerialGC        | 串行       | 新生代         | 复制算法      |
| Serial Old   | -XX:+UseSerialOldGC     | 串行       | 老年代         | 标记-整理算法 |
| ParNew       | -XX:+UseParNewGC        | 并行       | 新生代         | 复制算法      |
| Parallel     | -XX:+UseParallelGC      | 并行       | 新生代         | 复制算法      |
| Paraller Old | -XX:+UseParallelOldGC   | 并行       | 老年代         | 标记-整理算法 |
| CMS          | -XX:+UseConcMarkSweepGC | 并发       | 老年代         | 标记-清除算法 |
| G1           | -XX:+UseG1GC            | 并发、并行 | 新生代、老年代 | 标记-整理算法 |
| ZGC          | -XX:+UseZGC             | 并发、并行 | 新生代、老年代 | 标记-整理算法 |

> 需要注意的是：
>
> 1、CMS 在 JDK 11 中已经标识废弃，在 JDK 14 中正式删除了。
>
> 2、G1 在 JDK 7 引进，在 JDK 9 转正并设置为默认的垃圾收集器。
>
> 3、ZGC 在 JDK 11 引|进，在 JDK 15 中转正。

## 74、JVM 中的默认垃圾收集器是？

JVM 默认的垃圾收集器：

- JDK 7: Parallel Scavenge + Serial Old
- JDK 8 及 JDK 7u40 之后的版本：Parallel Scavenge + Parallel Old
- JDK9+：G1 收集器

可以使用下面命令查看：

> java -XX:+PrintCommandLineFlags -version

![](/images/JVM/74.jpg)

比如，这里可以看到 JDK 8 中的-XX:+UseParallelGC。

## 75、什么是 CMS 垃圾收集器？

CMS 全称：Concurrent Mark Sweep，是一款优秀的老年代“**并发**"垃圾收集器，它使用的是标记清除（Mark-Sweep）算法，并可以多线程并发标记和清除。

CMS 收集器回收时，用户线程并不会完全停止，而可以与用户线程并发执行，以减少 GC 停顿时间。所以，CMS 可有效地降低垃圾回收时的暂停时间，适用于对垃圾回收暂停时间有较高要求的应用场景。

## 76、CMS 垃圾收集器的适用场景？

CMS 垃圾收集器适用于以下场景。

##### 1）应用程序需要快速响应用户请求，并且具有大量的内存

由于 CMS 垃圾收集器采用并发标记和清除的方式，可以避免在垃圾回收过程中对应用程序造成较长时间的暂停，从而提高应用程序的响应速度。

##### 2）应用程序具有大量的中老年代对象

CMS 适用于大对象的回收，可以避免进行 Full GC，从而减少了对应用程序的影响。

##### 3）应用程序的垃圾产生速度较慢

CMS 垃圾收集器在垃圾产生速度较慢的情况下，可以在短时间内完成垃圾回收，从而减少了对应用程序的影响。

##### 4）应用程序的垃圾回收暂停时间要求较高

CMS 可以在垃圾回收过程中和应用程序同时运行，从而大大减少了垃圾回收对应用程序的影响，满足了对垃圾回收暂停时间要求较高的应用场景。

> 总之，CMS 垃圾收集器适用于需要快速响应用户请求、具有大量的中老年代对象、垃圾产生速度较慢、对垃圾回收暂停时间要求较高的应用程序。

## 77、CMS 垃圾收集器有什么优缺点？

##### CMS 优点：

1.支持并发收集，充分利用了硬件资源，提高了系统的垃圾回收效率；

2.低停顿，特别是对垃圾回收暂停时间要求较高的应用场景；

##### CMS 缺点：

1. 并发收集会抢占 CPU 资源，影响吞吐量；
2. 只能回收老年代，无法回收新生代垃圾；
3. 无法处理浮动垃圾；
4. 产生大量内存碎片；

## 78、CMS 收集器触发 GC 的条件？

CMS 垃圾收集器有前台收集器（**foreground collector**）和后台收集器（**background collector**）两种收集器，它们分别用于处理不同类型的垃圾回收任务。

**foreground collector**

- 新生代没有足够的空间分配对象；
- 老年代没有足够的连续、剩余空间分配对象；

##### background collector

CMS 后台有一个后台线程，每隔 CMSWaitDuration（默认 2s）时间去判断是否应该回收，参考`-XX:UseCMSInitiatingOccupancyonly` 和`-XX:CMSInitiatingOccupancyFraction` 参数。

## 79、CMS 垃圾回收的过程是怎样的？

CMS 垃圾收集器主要分为以下几个阶段。

##### 1）初始标记阶

段暂停应用程序（STW），标记出所有根对象直接引用的对象。

##### 2）并发标记阶段

启动多个线程对堆内存中的对象进行标记，标记结束后会生成一个标记记录表，记录所有需要回收的对象。

##### 3）重新标记阶

段暂停应用程序（STW），重新标记所有被修改过的对象和在并发标记阶段遗漏的对象。

##### 4）并发清除阶

段启动多个线程清理垃圾，同时清理并发标记阶段产生的黑色对象中不再被引用的对象。

## 80、CMS 垃圾收集器能处理浮动垃圾吗？为什么？

##### CMS 垃圾收集器不能处理浮动垃圾。

1）因为 CMS 垃圾收集器使用的是并发标记和清理算法，无法在并发清理阶段识别浮动垃圾，所以它无法直接处理浮动垃圾。

2）因为 CMS 收集器就是为了追求低停顿时间为目标而设计的，所以不能在一次回收工作中浪费太多时间，只能在下一次的回收时处理。

## 81、CMS 回收停顿了几次，为什么？

CMS 垃圾回收一共停顿了两次，分别是初始标记和重新标记阶段。

- 第一次是为了标记 GC 开始时的 root 对象；
- 第二次是为了标记并发标记时又变更的部分；

具体参考面试题：《CMS 垃圾回收的过程是怎样的?》

## 82、CMS 垃圾收集器为什么会被废弃?

因为 CMS 存在内存碎片、无法处理浮动垃圾、影响程序稳定性等问题，JDK 9 已经宣布将 CMS 垃圾收集器废弃了，JDK 11 中已彻底删除，推荐使用 G1 垃圾收集器。

> G1 垃圾收集器采用基于 Region 的内存布局方式，具有更好的内存碎片整理能力，同时支持增量更新，可以更好地处理浮动垃圾问题，而且 G1 垃圾收集器可以动态调整垃圾回收的时间，避免长时间的 GC 停顿，从而提高了垃圾回收的效率和稳定性。因此，CMS 垃圾收集器已经被官方废弃，不再被推荐使用。

另外，CMS 是一种高度可配置的复杂算法，代码过于复杂，不好维护，如下表所示：

| GC 算法       | JVM 参数 (约数) |
| ------------- | --------------- |
| Common to all | 50              |
| Parallel      | 6               |
| CMS           | 72              |
| G1            | 26              |
| ZGC           | 8               |

从 JVM 参数就能看得出来，废弃是可能是为了加速新功能的开发。

## 83、MS 垃圾收集器废弃后有什么替代方案？

有以下三种替代方案：

1）切换到 G1GC 算法（JDK7+）

2）切换到 Z GC 算法 (JDK 11+)

3）JDK 11 之前的版本可以继续使用 CMS GC (JDK 11+ 已经彻底彻底)

## 84、怎么启用 CMS 收集器？有哪些设置参数？

CMS 设置参数如下表所示。

| 参数                               | 说明                                                                                                                  |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| -XX:+UseConcMarkSweepGC            | 启用 CMS                                                                                                              |
| -XX:ConcGCThreads                  | 设置并发的 GC 线程数                                                                                                  |
| -XX:+UseCMSCompactAtFullCollection | FulIGC 做压缩整理，以减少碎片                                                                                         |
| -XX:CMSFullGCsBeforeCompaction     | FulIGC 压缩频次，默认是 O，每次 FulIGC 后都会压缩一次                                                                 |
| -XX:CMSInitiatingOccupancyFraction | 老年代触发 FulIGC 的使用比例，默认是 92（%)                                                                           |
| -XX:+UseCMSInitiatingOccupancyOnly | 仅用设定的回收阈值（-XX:CMSInitiatingOccupancyFraction 设定的值），如果不指定，则仅在第一次使用设定值，后续会自动调整 |
| -XX:+CMSScavengeBeforeRemark       | 在 GC 前执行一次 Minor GC，用于减少老年代对年轻代的引用，降低标记阶段时的开销                                         |
| -XX:+CMSParallellnitialMarkEnabled | 初始标记时以多线程执行，缩短停顿时间                                                                                  |
| -XX:+CMSParallelRemarkEnable       | 重新标记时以多线程执行，缩短停顿时间                                                                                  |

## 85、什么是 G1 垃圾收集器？

G1：**Garbage-First**，即垃圾优先，它是一种高效、可预测和可扩展的垃圾收集器，既能高概率满足 GC 低停顿时间，又兼具高吞吐量。它将 Java 堆划分为多个区域，根据垃圾占用情况进行优先回收，从而实现更高效的垃圾回收。

G1 收集器的历史：

- 2012-JDK 7u4 官方加入支持；
- 2019 - JDK 9 默认(宣布废弃 CMS 垃圾回收器)

## 86、有了 CMS 收集器，为什么又搞出了 G1？

CMS 收集器是以牺牲吞吐量换低停顿时间的，虽然低停顿，但是牺牲了系统性能，还存在很多问题。

G1 收集器的出现，目标就是在延迟可控的情况下，解决 CMS 中的问题，再尽可能获得高吞吐量，打造成一款全功能收集器。

## 87、G1 垃圾收集器的适用场景？

G1 垃圾收集器的适用场景：

1）大内存（>= 6G）、多处理器（>=4 核）的服务端应用；

2）应用程序对 GC 停顿时间比较敏感，希望更低的停顿时间；

3）可用来替换 CMS 垃圾收集器；

## 88、G1 垃圾收集器有什么优缺点？

##### G1 优点：

- G1 在回收期间可以有多个 GC 线程同时工作，充分利用 CPU 多核能力缩短停顿时间。
- G1 回收的部分动作可以和用户线程并发运行，不需要停顿；
- G1 可预测垃圾回收的停顿时间，用户可以指定最大停顿时间；
- G1 使用的是“**标记+整理+复制**”算法，空间整合，不会产生内存碎片；
- G1 可以同时兼顾年轻代和老年代；

##### G1 缺点：

- G1 内存占用和系统执行负载较高（需要维护卡表记录新生代和老年代的引用关系）;
- G1 对于小内存表现不佳；

## 89、G1 收集器对于堆是怎么划分的？

Java 堆区域的传统的划分参考：《JVM 从 GC 角度看，堆的分区情况？》

G1 收集器则不按传统这样分，而是将整个堆划分成约 2048 个大小相同的独立 Region 区域：

![](/images/JVM/89.jpg)

- 每个 Region 的大小相同；
- 每个 Region 大小在 1~32 MB 之间，且为 2 的次幂，即 1MB,2MB,4MB,8MB,16MB,32MB，可以通过-XX :G1HeapRegionSize 设定；
- 内存的回收是以 Region 为单位的；
- 每个 Region 都可以作为一个 Eden、Survivor、老年代，虽然保留了新生代和老年代，但都是不连续的 Region 的集合，新生代和老年代也不是物理隔离的了；

G1 还新增了一个 Humongous 内存区域（H），用来存放大对象（超过 1.5 个 Region）。

## 90、G1 收集器为什么重新划分了堆?

G1 收集器之所以重新划分了 Java 堆，是因为它要解决传统的垃圾收集器存在的一些问题。

##### 1）容易产生内存碎片

在传统的垃圾收集器中，堆中的对象分配和释放是不连续的，容易产生内存碎片，影响垃圾回收的效率。

> 重新划分堆，可以更有效的避免内存碎片。

##### 2）垃圾回收时暂停时间较长

在进行垃圾回收时，为了保证一致性，需要暂停所有的应用程序线程，这个过程需要的时间比较长，可能会导致应用程序出现停顿，影响用户体验。

> 重新划分堆，可以增加更多的垃圾收集线程，让垃圾收集彻底并行化。

## 91、G1 收集器是怎么处理大对象的？

具体参考面试题:《 G1 收集器为什么新增 Humongous 区域？有什么用？》

## 92、G1 收集器为什么新增 Humongous 区域？有什么用？

我们知道，如果一个**生命周期短的大对象**进入老年代，就会导致年老代的碎片化问题，从而影响垃圾回收效率。

所以 G1 特别为这种对象划分了一个 **Humongous** 区域（H），如果一个 H 区域装不下，则用连续的 H 区域存储,从而更好地控制垃圾回收的范围和粒度，避免年老代碎片化的问题。

Humongous 区域是一种特殊的区域，它可以容纳比较大的对象。在 G1 垃圾收集器中，如果有一个比较大的对象需要分配内存，G1 垃圾收集器会首先查找 Humongous 区域，如果能够满足，则将对象分配在 Humongous 区域中，否则再尝试在 Java 堆中的其他区域中分配内存。

## 93、G1 垃圾回收的过程是怎样的？

G1 回收过程可分为 4 个步骤。

##### 1）初始标记（Initial Marking)

暂停所有的其他线程（STW），一般不会超过 1 秒钟，标记 GC Roots 能直接引用的对象。

##### 2）并发标记（Concurrent Marking)

并发扫描 Java 堆中的存活对象，将它们进行标记。

此阶段，应用程序可以并发地执行，不会被垃圾回收过程所影响。

##### 3）最终标记（Final Marking）

暂停所有的其他线程（STW），一般不会超过 1 秒钟，重新修正并发标记阶段用户线程运行导致变化的对象记录，对所有的存活对象进行最终的标记。

##### 4）筛选回收(Live Data Counting and Evacuation)

找出所有的垃圾对象，并将它们从 Java 堆中删除。同时，G1 垃圾收集器会将存活对象进行压缩和整理，从而使 Java 堆中的碎片最小化。

因为涉及存活对象的移动，所以这里也会暂停所有的其他线程（STW）。这个过程可能会发生多次停顿，每次停顿的时间都会根据堆中的垃圾量而不同。

## 94、G1 回收停顿了几次，为什么？

G1 垃圾回收时至少停顿了 3 次，分别是以下三个阶段：

- **初始标记**：为了标记 GC 开始时的 root 对象（1 次）；
- **最终标记**：为了标记并发标记时又变更的部分（1 次）;
- **筛选回收**：为了在回收旧空间时移动存活的对象（多次）;

前两次一般不会超过 1 秒钟，最后的回收停顿的时间根据堆中的垃圾量而不同。

具体可参考面试题：《G1 垃圾回收的过程是怎样的?》

## 95、怎么启用 G1 收集器？有哪些设置参数？

##### 使用 G1 收集器的方式：

- ava 7/8：使用-XX:+UseG1GC 参数设置；
- ava 9+：默认 G1，无需设置；

##### 设置参数：

| 参数                               | 说明                                                                                                              |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| -XX:G1HeapRegionSize               | 设置每个 Region 的大小，值为 2 的次幂，1 ～ 32M 之间，根据最小的堆大小划分出约 2048 个区域，默认是堆内存的 1/2000 |
| -XX:MaxGCPauseMillis               | 设置期望达到的最大 GC 停顿时间指标，默认值是 200ms                                                                |
| -XX:ParallelGCThread               | 设置停顿时的 GC 线程数，最多可设置为 8 个                                                                         |
| -XX:ConcGCThreads                  | 设置并发标记的线程数                                                                                              |
| -XX:InitiatingHeapOccupancyPercent | 设置触发并发 GC 周期的堆占用比率阈值，默认值是 45（%）                                                            |

## 96、CMS 和 G1 收集器的区别?

##### 1）使用范围

CMS 是老年代收集器，可以配合 Serial 和 ParNew 新生代收集器一起使用。

G1 是新生代和老年代收集器，不需要结合其他收集器使用。

##### 2）停顿时间

CMS 是以最小停顿时间为目标的收集器。

G1 可预测垃圾回收的停顿时间，用户可以指定最大停顿时间;

##### 3）垃圾碎片

CMS 使用的是“**标记-清除**”回收算法，很容易产生内存碎片。

G1 使用的是“**标记-整理+复制**”算法，空间整合，不会产生内存碎片。

##### 4）回收过程

CMS：初始标记>并发标记>重新标记>**并发清除**

G1：初始标记>并发标记>最终标记>**筛选回收**

##### 5）浮动垃圾

CMS 会产生浮动垃圾，本轮回收无法清除。

G1 不会产生浮动垃圾。

## 97、CMS 和 G1 收集器怎么选？

##### Java 7-版本:

G1 不太完善，建议使用 CMS。

##### Java8、9、10 版本:

内存够大（>=8G），建议优先使用 G1;

CPU 够足，内存有限，考虑使用 CMS;

##### Java11+版本:

CMS 已标识移除，不建议使用了，建议 G1。

## 98、什么是 ZGC 垃圾收集器？

Z Garbage Collector （**ZGC**）是一款由 Oracle 开发的高性能、低停顿时间的垃圾收集器，它诞生的目的是将垃圾回收暂停时间最小化，适用于需要实时性和高响应性能的应用场景。

ZGC 垃圾收集器的历史:

- JDK 11 中首次实验性引入；
- JDK 15 中正式转正生产可用；

## 99、ZGC 垃圾收集器的适用场景？

##### ZGC 垃圾收集器的适用场景：

1）对延迟敏感的应用，要求极低的延迟时间，比如实时性要求高的应用，如金融交易系统、在线游戏、实时数据处理等，需要保证尽可能低的停顿时间。

2）需要支持上 100GB+以及 TB 级别的超大内存，ZGC 可以高效地管理 TB 级别的堆内存。

## 100、ZGC 垃圾收集器有什么优缺点？

ZGC 垃圾收集器是一种专注于实现极低停顿时间的垃圾回收器，它在一些方面具有优势，但也存在一些限制和缺点。

##### 优点：

- **低延迟**：ZGC 的主要优势是其极低的停顿时间，它可以在几毫秒的时间范围内完成垃圾回收；
- **大内存堆**：ZGC 非常适用于大堆内存，它可以有效地管理多 GB 甚至 TB 级别的堆内存。

##### 缺点：

- **吞吐量**：相对于一些吞吐量优化的垃圾回收器（如 G1），ZGC 的吞吐量可能会稍低一些；
- **分代回收**：ZGC 没有分代了，每次回收都需要全堆扫描，可能导致一些对象没有及时回收；
- **浮动垃圾**：执行时间大于停顿时间，会产生大量无法回收的浮动垃圾。

## 101、ZGC 收集器对于堆是怎么划分的？

ZGC 和 G1 一样，使用了一种分区的内存布局，它将整个堆划分为多个区域（Regions），分别是:

- **小型 Region（Small Region）**：容量固定为 2MB，用于存储小于 256KB 的小对象。
- **中型 Region（Medium Region）**：容量固定为 32MB，用于存储大于等于 256KB 且小于 4MB 的对象。
- **大型 Region （Large Region）**：容量不固定，对象大小为 2 的整数倍，可以动态创建和销毁，用于放置 4MB 及以上的大对象。

和 G1 不同的是，ZGC 没有按固定的新生代和老年代划分，每个区域都可以用于存储不同代的对象，每个区域既可以存储新生代对象，也可以存储老年代对象，这样的设计使得 ZGC 能够更灵活地适应不同应用程序的内存需求，同时支持高效的并发垃圾回收。

所以，在 ZGC 垃圾收集器中，已经没有新生代、老年代的分代概念了。

ZGC 的堆划分图如下:

![](/images/JVM/101.jpg)

堆划分解读：

- 当对象<256KB 时，对象分配在小区域；
- 当对象>= 256KB 并且<4MB 时，对象分配在中区域；
- 当对象>= 4MB 时，对象分配在大区域；

> ZGC 对于不同区域的回收策略也是不同的，小区域会优先回收，中大区域则尽量不回收。

## 102、ZGC 垃圾回收的过程是怎样的？

ZGC 的垃圾回收主要分为以下五个阶段：

##### 1）初始标记

从 GC Roots 出发，找出并标记 GC Roots 直接引 l 用的对象存放到活跃对象集合中。

这个过程暂会停所有其他线程（STW），暂停时间和 GC Roots 的数量成正比，停顿时间不会随着堆的大小或者活跃对象的大小而增加。

##### 2）并发标记

并发扫描 Java 堆中的存活对象，将它们进行标记。

此阶段，应用程序可以并发地执行，不会被垃圾回收过程所影响。

##### 3）再标记

这个阶段主要是处理并发标记中漏标的对象，还会对非强引用（软引|用，弱引用、虚引用）进行并行标记。

这个阶段需要 STW，但是需要标记的对象少，耗时很短。

##### 4）初始转移

初始转移阶段，先扫描 GC Roots 直接引用的活跃对象，然后再将它们复制到新的内存，之前的内存空间可以回收了。

这个过程需要 STW，暂时时间跟 GC Roots 数量成正比。

##### 5）重映射

在对象转移过程中，对象的地址就会发生变化，这个阶段就是修正旧对象的所有引用。

## 103、ZGC 回收停顿了几次，为什么？

ZGC 垃圾回收时停顿了 3 次，分别是以下三个阶段：

- 初始标记：为了标记 GC 开始时的 Root 对象（1 次）；
- 再标记：为了处理并发标记中漏标的对象（1 次）；
- 初始转移：为了转移存活对象到新的内存（1 次）;

前两次一般耗时很短，最后的转移时间根据堆中的垃圾量而不同。

具体可参考面试题：《ZGC 垃圾回收的过程是怎样的？》

## 104、怎么启用 ZGC 收集器？有哪些设置参数？

##### 使用 ZGC 收集器的方式：

- 需要 JDK 11+；
- 使用-XX:+UseZGC 参数设置；

##### 常用的 JVM 设置参数：

| 参数                     | 说明                                                            |
| ------------------------ | --------------------------------------------------------------- |
| -XX:ZProactive           | 设置是否启用主动回收，默认开启。                                |
| -XX:ZUncommit            | 设置是否在垃圾回收过程中释放未使用的内存，默认开启。            |
| -XX:ZUncommitDelay       | 设置内存在指定的时间内未使用的时间再释放，单位秒，默认 300 秒。 |
| -XX:ZCollectionlnterval  | 设置垃圾回收的的最小时间间隔，单位秒。                          |
| -XX:ZMarkStackSpaceLimit | 设置指定为标记堆栈分配的最大字节数，默认 8G。                   |

## 105、ZGC 和 G1 收集器的区别？

G1 和 ZGC 的主要区别：

| 对比项       | G1                                  | ZGC                                   |
| ------------ | ----------------------------------- | ------------------------------------- |
| 吞吐量与延迟 | 吞吐量和低延迟平衡                  | 极低的停顿时间，吞吐量有影响          |
| 内存布局     | 大小相同的 Regions 分新生代和老年代 | 大小不同的 Regions 不分新生代和老年代 |
| 垃圾收集方式 | 分代回收                            | 分区回收                              |
| 停顿时间     | 可预测的停顿时间                    | 极低的停顿时间                        |
| 内存管理     | GB 级别                             | TB 级别(16 TB)                        |
| 内存利用率   | 中                                  | 较高                                  |

## 106、ZGC 和 G1 收集器怎么选？

1、JDK15 之前，ZGC 尚未转正，所以，**JDK15 之前的版本推荐使用 G1**，不建议使用 ZGC。

2、JDK 15+版本：

- 如果应用程序对**低延迟、超大内存** 有非常高的要求，特别是要求在**几毫秒** 甚至更短的时间内完成垃圾回收，以及上 TB 的内存，**ZGC**是更好的选择，它专注于最小化停顿时间，但会牺牲一点吞吐量。
- 如果应用程序需要在**高吞吐量和较低延迟之间取得平衡**，**G1**是更好的选择，它可以在一定程度上提供低延迟的垃圾回收，同时仍具有相对较高的吞吐量。

一般推荐使用 G1，这也是 JDK 默认的，除非对低延迟特别敏感才考虑使用 ZGC。

没有最好的垃圾收集器，只有最合适的，选择用哪个垃圾收集器，应该结合自己的系统，在真实环境中进行测试和调优，以获得最佳的性能和响应性，再作出选择。

## 107、常用的垃圾回收算法有哪些？

##### 常用的垃圾回收算法有：

- 引用计数法
- 标记-清除算法
- 标记整理（压缩）算法
- 复制算法
- 分代算法

目前主流的 JVM （HotSpot）采用的是分代收集算法。

## 108、你怎么理解 GC 引用计数算法？

每个对象都有一个引用计数属性，每当新增一个引用时计数+1，每当释放一个引用时计数-1，当引引用计数为 0 时表示该对象可以回收。

最大的缺点就是无法解决循环引用的问题，另外就是浪费 CPU 资源，影响性能，因为每次引用都需要计算引用数，即使内存够用的情况。

## 109、你怎么理解 GC 可达性分析算法？

可达性分析算法通过分析对象之间的引用关系来判断对象是否可达，从 GC Roots 开始向下搜索，如果在“GC Roots"和一个对象之间没有可达路径，则称该对象是不可达的。

不过要注意的是，被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

## 110、你怎么理解 GC 复制算法？

复制算法，即把内存空间拆分成两块（比如：新生代的划分规则），每次垃圾回收时，将存活的对象从一块空间移动到另一块空间，然后再清理第一块的空间：

![](/images/JVM/110.jpg)

两块空间可以彼此交换角色，并且保证同时有一块空间是空闲的，这样复制算法就避免了产生内存碎片。

缺点就是浪费空间，没有得到充分利用。

## 111、你怎么理解 GC 标记清除算法？

标记清除算法，即分为两个阶段：

- **标记阶段**：从根节点开始标记所有已经引用的对象；
- **清除阶段**：直接清理未被标记的对象；

![](/images/JVM/111.jpg)

可以看到标记清除算法的缺点：

1.标记和清除都需要遍历所有的对象，并且标记阶段还需要暂停用户线程，所以效率不是很高；

2.清理后内存碎片化严重，内存不连续。

## 112、你怎么理解 GC 标记整理算法？

标记整理（压缩）算法，是对标记清理算法的改进，也分为两个阶段：

- **标记阶段**：从根节点开始标记所有已经引用的对象；
- **整理阶段**：先将标记的存活的对象先压缩到内存的一端，然后再到清理边界外所有内存；

![](/images/JVM/112.jpg)

标记整理算法解决了标记清除算法内存碎片化的问题，但移动对象也会存在一点性能损耗。

## 113、你怎么理解 GC 分代算法？

所谓的分代算法，就是将 Java 堆按对象存活周期的长短按不同区域存储，再根据各个年代的特点选择合适自己的回收算法，所以垃圾回收没有最好的算法，只有最合适的算法。

**新生代**：对象存活相对较少，所以使用复制算法是最快的。

**老年代**：存在大量存活对象，内存空间又较大，所以不适合直接使用复制算法，适合使用标记清除算法、标记整理算法，再结合复制算法混合使用。

## 114、System.gc 有什么用？

System.gc()是 Java 中的一个方法，调用时，JVM 会尝试触发垃圾回收器运行，并尽可能回收未被使用的内存，具体是否回收内存取决于垃圾回收器的实现和当前 VM 的内存使用情况。

## 115、为什么不建议手动调用 System.gc？

不建议手动调用 System.gc0 方法的原因如下：

- 可能会降低程序的性能，因为它可能会导致不必要的垃圾回收和资源浪费；
- 可能会导致一些不可预知的问题，比如死锁、资源争用等问题。

总之，建议使用 JVM 自动垃圾回收机制，合理优化 JVM 垃圾回收，让 JVM 在需要时自动回收内存，而不是过度依赖手动调用 System.gc() 方法，否则会适得其反。

## 116、什么时候需要手动调用 System.gc？

JVM 垃圾回收是自动进行的，不建议使用 System.gc()方法手动触发。

但是，在某些特殊情况下是可以使用 System.gc() 方法的，例如在执行长时间运行的任务后，或在大量使用内存后，这时可以调用 System.gc() 方法建议垃圾回收器运行，用来帮助释放不再使用的内存，提高程序的性能。

## 117、System.gcO 和 Runtime.gcO 的作用？有什么区别？

它们的作用是运行垃圾回收器，让 JVM 尽可能的回收未使用的对象，以便能快速地重用这些对象当前占用的内存。

System.gc() :

![](/images/JVM/117_1.jpg)

Runtime.gc0 :

![](/images/JVM/117_2.jpg)

##### System.gcO 会调用 Runtime.gcO，前者是静态方法，后者是 native 方法。

## 118、什么是三色标记法？回收流程呢？

三色标记法是一种垃圾回收算法，它是一种非常高效的标记-清除（Mark-Sweep）垃圾回收算法，也是垃圾回收器的核心算法之一。三色标记法的核心思想是将所有可达对象分为三类：**白色、灰色和黑色**。

（1）初始时，所有对象都是**白色**的，表示它们尚未被扫描。

（2）然后，从根对象出发，遍历所有可达对象，将它们标记为**灰色**，表示它们已经被扫描过，但它们引用的对象还未扫描。

（3）接着，遍历灰色对象集合，将自身对象标记为**黑色**，将其直接引用的对象标记为**灰色**

（4）重复步骤 3，直到灰色的对象集合变为空，所有可达对象都被标记为 **黑色**，表示它们已经被扫描过并且不再引用其他未扫描的对象。

（5）最后，清理掉所有未被标记的**白色**对象，以释放它们所占用的内存。

## 119、什么是浮动垃圾？

在垃圾回收并发清理阶段，用户线程也还在交替运行并产生新的垃圾，而新的垃圾在本次 GC 又无法进行清除，只能等到下次 GC 时才能清除，这就是浮动垃圾。

## 120、什么是内存泄漏？

Java 的垃圾回收机制可以自动回收不再使用的内存，但是，由于某些原因，某些对象没有被及时释放，如不再使用的对象无法被回收，这就会使系统内存越来越少，从而导致内存泄漏。

为了理解这个定义，我们需要了解对象在内存中的状态，下图说明了什么是未引用的，什么是引用的对象。

![](/images/JVM/120.jpg)

从图中可以看出，有被引用的对象和未被引用的对象。

未引用的对象将被垃圾收集器回收，而被引用的对象将不会被垃圾收集回收。

未引用的对象肯定是未使用的，因为没有其他对象引用它。但是，未使用的对象并不是全部未被引用，其中一些被引用，这是内存泄漏的来源。

因此，编写 Java 程序时，需要注意避免内存泄漏的情况，以保证程序的正常运行。

## 121、Java 中会存在内存泄漏吗？

会的，Java 中也会存在内存泄漏问题，这也是 Java 编程语言的一个弊端。

## 122、为什么会发生内存泄漏？

内存泄漏的原因可能有多种，以下是一些常见的内存泄漏原因。

##### （1）对象没有被及时的释放

当一个对象在程序中不再被使用时，如果没有得到及时的释放，就会导致该对象所占用的内存没有被释放，从而发生内存泄漏。

##### （2）循环引用

当两个或多个对象相互引用时，如果它们之间没有断开引用关系，就会导致这些对象所占用的内存没有被释放。

##### （3）没有正确的关闭资源

在使用一些需要手动关闭的资源时，比如数据库连接、文件等，如果没有在使用完毕后正确的关闭这些资源，就会导致这些资源所占用的内存没有被释放。

等等。。。

---

来来看一个对象没有被及时释放的示例，如下图所示，对象 A 引用了对象 B，看看为什么会发生内存泄漏。

![](/images/JVM/122.jpg)

A 的生命周期（t1－t4）比 B 的（t2－t3）长得多，当应用中不再使用 B 时，A 仍然有一个 B 的引用，这样垃圾收集器就不能从内存中删除 B。这就可能会导致内存不足的问题，因为如果 A 同时为更多的对象做同样的事情，那么会有很多像 B 这样的对象没有收集并占用内存空间。B 也可能拥有一堆其他对象的引用，

B 引用的对象也不会被收集，所有这些未使用的对象将消耗宝贵的内存空间。

## 123、如何防止内存泄漏？

以下是防止内存泄漏的一些快速实用技巧！

##### （1）及时释放对象引用

当一个对象不再需要时，可以将其引用设置为 null，以便让垃圾回收器回收这个对象。

##### （2）使用 try-finally 块释放资源

当使用需要手动释放的资源（如文件、数据库连接等）时，应该使用 try-finally 块，确保在使用完资源后将其释放，以避免资源泄漏。

##### （3）避免匿名内部类持有外部类引用

当使用匿名内部类时，应该避免让它持有外部类的引用，以免导致外部类无法被回收。

##### （4）避免长时间持有对象锁

当使用同步锁时，应该避免长时间持有对象锁，以避免导致其他线程无法访问该对象。

##### （5）使用弱引用或软引用

当需要缓存对象时，应该使用弱引用或软引用来引用这些对象，以避免这些对象被缓存而无法被回收。

##### （6）使用内存分析工具

使用内存分析工具，可以快速定位内存泄漏问题，并且可以帮助优化内存使用。

## 124、一个线程 00M 后，其他线程还能运行吗？

答案是：**还能继续运行**。

当 JVM 中一个线程发生 OOM（内存溢出）异常后，它占据的内存资源会被全部释放掉，所以不会影响 JVM 其他线程的运行，但是会受 GC 回收的影响。

## 125、JVM 调优的目标是什么？如何选择？

JVM 调优比较重要的几个指标：

- **存占用**：应用程序正常运行所占用的内存大小
- **延迟时间**：由于垃圾回收而造成的应用程序的停顿时间
- **吞吐量**：应用程序运行时间占 JVM 运行总时间的比值

和著名的分布式系统 CAP 定理一样，JVM 调优的指标也不可能同时满足，也只能满足其二，如果选择了其中的任意两个，必然会会以牺牲另一个为代价。

所以引 I 出了 JVM 调优的目标，**即使用较小的内存占用来获得较低的延迟时间或者较高的吞吐量。**

如何选择 JVM 调优目标，需要根据我们系统的实际情况来进行判断:

##### 1、获得较低的延迟时间

对于注重用户体验的应用程序，其关注的重点是延迟时间，因为 JVM 在垃圾回收时时会进行 STW（Stop The World），这时 JVM 将暂停所有用户线程，应用程序可能就会有卡顿，那么获得较低的延迟时间则是 JVM 的重点调优目标。

##### 2、获得较高的吞吐量

对于一些后台系统来说，其关注的重点可能并不是延迟，而是在单位时间内能尽可能多的处理任务，那么获得较高的吞吐量则是 JVM 的重点调优目标。

## 126、常用的 JVM 调优命令有哪些？

常用的 JVM 调优命令如下面所示：

- **jps**：用于显示所有 JVM 虚拟机进程；
- **jstack**：用于查看 JVM 虚拟机当前时刻的线程快照；
- **jinfo**：用于实时查看和调整虚拟机运行参数；
- **jmap**：用于生成 heap dump 文件；
- **jhat**：用于与 jmap 命令搭配使用，分析 jmap 生成的 dump 文件；
- **jstat**：用于监视 JVM 虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据；

## 127、常用的 JVM 问题定位工具有哪些？

常用的 JVM 问题定位工具有以下几种。

##### 1、jstack (JVM 自带)

jstack 可以打印出 Java 进程中所有线程的堆栈信息，从而帮助开发人员快速定位线程死锁和线程阻塞等问题。

##### 2、jmap (JVM 自带)

jmap 可以打印出 Java 进程中的内存使用情况，包括堆内存、非堆内存、永久代等区域的使用情况，帮助开发人员快速定位内存泄漏和内存溢出等问题。

##### 3、jstat (JVM 自带)

jstat 可以实时监控 Java 进程中的堆内存、非堆内存、GC 情况等信息，帮助开发人员了解 Java 进程的运行状态。

##### 4、VisualVM

VisualVM 是一款开源的 JVM 监控和调优工具，可以监控 Java 进程的内存使用情况、线程状态、GC 情况等信息，并提供一些工具帮助开发人员进行调优和问题定位。

##### 5、JProfiler

JProfiler 是一款商业化的 JVM 监控和调优工具，提供了强大的性能分析和调优功能，可以帮助开发人员快速发现 Java 应用程序中的性能瓶颈和内存泄漏问题等。

##### 6、Eclipse Memory Analyzer

Eclipse Memory Analyzer 是一款开源的内存分析工具，可以帮助开发人员分析 Java 应用程序中的内存泄漏问题，提供了一些强大的分析工具，如重复对象分析、泄漏报告等。

## 128、常用的主流 JVM 虚拟机都有哪些？

以下是常用的主流 JVM 虚拟机及其特点：

| JVM                | 特点                                                                                                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Oracle HotSpot JVM | JDK 内置虚拟机，提供了强大的性能和可靠性，支持即时编译和垃圾回收等高级特性。                                                                                        |
| OpenJDK JVM        | 开源免费，与 Oracle HotSpot JVM 基本一致，同时支持 C++和 Java 编写的混合代码。                                                                                      |
| IBM J9 JVM         | IBM 开发的一个高度模块化的 JVM，支持大规模应用程序和多语言集成，采用优化的即时编译和垃圾回收算法，提供了高性能和稳定性。                                            |
| Azul Zing JVM      | 支持大规模应用程序和多语言集成，采用垃圾回收和即时编译的优化算法，提供了极高的性能和稳定性。                                                                        |
| JRockit JVM        | 支持大规模应用程序和多语言集成，采用优化的垃圾回收和即时编译算法，提供了高性能和可靠性。目前已经和 HotSpot JVM 合并，将 JRockit JVM 的优秀特性整合到 HotSpot 中了。 |

## 129、JVM 对频繁调用的方法做了哪些优化？

JVM 对频繁调用的方法做了以下两种优化。

##### （1）内联优化

内联优化是指在运行时将方法的调用处直接替换成方法体，从而避免了方法调用的开销。

当一个方法被频繁调用时，JVM 会将该方法标记为“**热点方法**"，并对其进行内联优化。JVM 通过静态分析、代码透视和逃逸分析等技术，确定哪些方法适合进行内联优化，从而提高程序的性能。

##### （2）缓存优化

缓存优化是指将方法的计算结果缓存起来，避免重复计算。

当一个方法的计算结果对于相同的参数值是不变的时，JVM 会对该方法进行缓存优化。JVM 通过将计算结果缓存在方法调用点附近的缓存区中，避免了重复计算的开销，提高了程序的性能。

## 130、什么是热点代码？

Java 中的热点代码（HotSpot Code）是指在应用程序的执行期间被频繁调用的代码段，这些代码段主要有以下两种：

- 被频繁调用的方法
- 频繁执行的循环体

主要是因为它们在应用程序的执行期间，会被反复调用，所以需要优化。

JVM 中有一个热点编译器，它会对这些频繁调用的代码段进行即时编译（Just-In-Time Compilation，JIT），将其编译成本地机器代码，以提高程序的性能。这种编译方式相比传统的静态编译，在程序运行时才对代码进行编译，因此可以根据实际的运行情况来优化程序的性能。

> 热点代码的识别和编译是一个动态的过程，Java 虚拟机会根据应用程序的实际执行情况来动态地调整编译策略和优化方式，从而实现最优的性能。

## 131、GraalVM 是什么技术？

GraalVM 是一个由 Oracle 开发的全栈通用虚拟机，拥有高性能、跨语言交互等逆天特性，不仅支持了 Java、Scala、Groovy、Kotlin 等基于 JVM 的语言，以及 C、C++ 等基于 LLVM 的语言，还支持其他像 JavaScript、Ruby、Python 和 R 语言等，可提高多种语言的运行速度和吞吐量。

![](/images/JVM/131.jpg)

##### GraalVM 有以下几个特性。

- 加高效快速的运行代码

- 与大多数编程语言直接交互

- 使用 Graal SDK 嵌入多语言

- ##### 创建预编译的原生镜像

- 供一系列工具来监视、调试和配置所有代码

##### 重点来看下原生镜像功能：

> $ javac Helloworld.java
>
> $ time java Helloworld
>
> user 0.070s
>
> $ native-image Helloworld
>
> $ time ./helloworld
>
> user 0.005s

GraalVM 可以预编译成原生镜像，从而极大提速了启动时间，并能减少 JVM 应用的内存占用。
