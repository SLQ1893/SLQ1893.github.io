## 1、0.1 + 0.2 == 0.3 正确吗？为什么？

不正确，结果为：false。

示例代码：

![](/images/进阶/1.jpg)

输出结果：

> 0.1 + 0.2 = 0.30000000000000004
>
> 0.1 + 0.2 == 0.3 ? false

因为在计算机浮点数表示中，由于精度限制，涉及小数的计算可能出现精度误差。这这种情况下，0.1 和 0.2 的二进制表示的精度损失导致它们相加的结果与理论上的 0.3 略有偏差。

所以，Java 中浮点数运算会存在精度丢失，不能直接运算，建议使用：**BigDecimal**。

## 2、为什么 byte 取值范围为-128~127？

Java 设计 byte 类型为 1 个字节，1 个字节占 8 位，即 8bit，这是常识。

另外，计算机系统中是用补码来存储的，首位为 0 表示正数，首位为 1 表示负数，所以有以下结论：

- 最大的补码用二进制表示为：01111111 = 127
- 最小的补码用二进制表示为：10000000 = -128

这种设计使得`byte`类型能够在-128 到 127 的范围内表示 256 个不同的值，正好是 2 的 8 次方，符合 1 字节（8 位）的存储容量。

关于补码、原码、反码的计算原理可以自行补下基础。

##### Byte 类的源码：

![](/images/进阶/2_1.jpg)

7 是最高位，总共 8bit，可以看出 byte 占 1 个字节，即 8 / 8 = 1。

##### Integer 源码：

![](/images/进阶/2_2.jpg)

31 是最高位，总共 32bit，可以看出 int 占 4 个字节，即 32 / 8 = 4。

> 其他 Short、Long 的设计原理也一样。

## 3、2 \* 8 最有效率的计算方法是什么？

答案：2<<3

左移 3 位相当于乘以 2 的 3 次方，右移相当于除以 2 的 3 次方，因为位运算 CPU 是直接支持的，效率是最高的。

示例代码如下：

![](/images/进阶/3.jpg)

## 4、一个“.java”源文件的类有什么限制？

我说几个常见的限制：

1、一个`.java`文件中可以有多个类，但最多只能有一个公共类（`public`类）。

2、如果`.java`文件包含一个公共类，文件名必须与公共类的名称相匹配，并且文件名的大小写也必须一致。比如，如果一个公共类命名为`UserService`，那么源文件必须命名为`UserService.java`。

3、一个文件中只能有一个包声明，如果类是某个包的一部分，包声明应该是源文件中的第一条语句，注释除外。

示例代码：

![](/images/进阶/4.jpg)

## 5、String 是可变的吗？为什么？

Java 中的 String 类是不可变的，来看下 String 类的源码。

![](/images/进阶/5.jpg)

可以看出 String 类是 final 类型的，String 不能被继承。

其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变，任何对 String 的修改操作都会导致创建一个新的 String 对象，而不是更改原有的对象。

JDK 9 有所变化，参考面试题：Java 9 之后，String 底层为什么使用 byte[]，而不是 char[]？

示例代码：

```java
public static void main(String[] args) {
    String s1 ="hello";
    String s2 = s1.toUpperCase();

    System.out.println(s1);   // 输出“hello”
    System.out.println(s2);   // 输出“HELLO”
}
```

在这个示例中，`s1.roUpperCase()`并没有改变`s1`指向的字符串内容。相反，它创建了一个新的`String`对象`s2`，其中包含了转换为大写字母后的内容，原始字符串`"hello"`保持不变。

String 在 Java 中设计是不可变的，主要是基于**安全性、线程安全、性能优化**等考虑，频繁的字符串修改操作可能会导致较大的性能开销。

## 6、String 类可以被继承吗？

String 类是 final 修饰的，所以它不能被继承。

![](/images/进阶/6.jpg)

如果继承`String`类将导致编译错误：

```java
// 编译错误：无法从最终String进行继承
public class MyString extends String {
    // 实现细节
}
```

String 类的实例一旦创建，气质就不能被改变，如果需要对字符串进行修改，实际上是创建了一个新的字符串对象。

## 7、String 真的是不可变的吗？

##### String 真的“不可变”吗？

来看下面这个例子：

```java
public static void main(String[] args) {
    String str = "Python";
    System.out.println(str);  // Python

    str = "Java";
    System.out.println(str);   // Java

    str = str.substring(1);
    System.out.println(str);   // ava
}
```

##### 你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 Java 了吗？

这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了“Python”，后面变成了“Java”，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。

![](/images/进阶/7.jpg)

所以说，这里的字符串并不是可变，只是变更了字符串引用。

##### String 真的真的真的“不可变”吗？

上面的例子肯定是不可变的，下面这个就尴尬了。

```java
public static void mian(String[] args) throws Exception {
    String str = "Hello Python";
    System.out.println(str);  // Hello Python

    Field field = String.class.getDeclaredField("value");
    field.setAccessible(true);

    char[] value = (char[]) field.get(str);
    value[6] = "J";
    value[7] = "a";
    value[8] = "v";
    value[9] = "a";
    value[10] = "!";
    value[11] = "!";
    System.out.println(str);  // Hello Java!!
}
```

通过反射，我们改变了底层的字符数组的值，实现了字符串的“不可变”性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。

> 注意，以上反射私有成员在 Java 9+中默认不开放。

## 8、String 有没有长度限制？是多少？

String 是**有长度限制**的。

##### 编译期间

---

根据虚拟机规范：

![](/images/进阶/8_1.jpg)

编译期间，字符串额最大长度不能超越 65535 个字节，即编译期间的 string 字符串的最大长度为 65534 个字节， 不然就会编译报错。

##### 运行期间

---

![](/images/进阶/8_2.jpg)

运行期间，String 最大长度就要看 Integer.MAX_VALUE 的值了， 即：2^31 - 1 个字节。

> 不管怎样，String 的最大长度都不能超过虚拟机当前最大内存设置。

## 9、String 的底层实现是怎样的？

##### JDK 6

String 背后是由 char 数组构成的，在 JDK 6 中，String 包含三个字段：char value[]，int offset，int count，意思很简单。

substring 被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。

![](/images/进阶/9_1.jpg)

JDK6 中的部分源码可以说明这个问题。

```java
String(int offset, int count, char value[]) {
    this.value = value;
    this.offset = offset;
    this.count = count;
}

public String substring(int beginIndex, int endIndex) {
    // check boundary
    return new String(offset + beginIndex, endIndex - deginIndex, value);
}
```

##### 会有什么问题？

如果一个很长的字符串，但是每次使用 substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。

对于 JDK 6，解决方案是使用以下内容：

```java
x = x.substring(x, y) + "";
```

##### JDK 7+

JDK 6 这种问题在 JDK 7+中已经改善了，JDK 7+中实际是重新创建了一个字符数组，如图：

![](/images/进阶/9_2.jpg)

JDK7 中的部分源码：

```java
// JDK 7
public String(char value[], int offset, int count) {
    // check boundary
    this.value = Array.copyOfRange(value, offset, offset + count);
}

public String substring(int beginIndex, int endIndex) {
    // check boundary
    int subLen = endIndex - beginIndex;
    return new String(value, beginIndex, subLen);
}
```

对于 JDK 的这种差异，我们知道就好，现在应该都是 JDK 7 及 8 了吧，其实对于小字符串的操作性能也是可以忽略不计的。

##### JDK 9+

Java 9 之后，String 底层采用的是 byte[]数组和编码标识来识别，这里以目前最新的 Java 17 为示例：

```java
public final class String implements java.io.Seriaizable, comparable<String>, CharSequence, Constable, ConstantDesc {
    @Stable
    private final byte[] value;
    ...
}
```

## 10、为什么不能用+拼接字符串？

通过多个表达式完成一个字符串拼接操作。

```java
private void test1() {
    String www = "www";
    String str = www;
    str += "javastack";
    str += "com";
}
```

字节码如下：

![](/images/进阶/10_1.jpg)

观察下，`NEW java/lang/StringBuilder`出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次`StringBuilder`。

如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个`StringBuilder`？

频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用`+`拼接，而要用那两个`sb`拼接了。

##### 什么时候可以用`+`

直接将三个字面量的字符串拼接成一个字符串。

```java
private static void test2() {
    String str = "slq1893." + "github." + "io";
}
```

字节码如下：

![](/images/进阶/10_2.jpg)

从字节码看出，没有任何创建`StringBuilder`的指令，直接从常量池进行取出一个完整的字符串：sql1893.github.io。很明显，这是 Java 编译器对代码进行了优化。

所以，通过这个示例告诉你，在这种情况下是可以用号`+`进行字符串拼接的。

这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：

```java
String sql = "select name, sex, age, address" + " from t_user" + "where age > 18";
```

别说这样不行，这样是行的。

但你要是换成这样就不行了。

```java
String sql = "select name, sex, age, address";
sql += "from t_user";
sql += "where age > 18";
```

这样又回到创建多个`StringBuilder`的时候了。

也就是说，在一个表达式中完成字符串拼接是可以用`+`号完成的，因为编译器已经做了优化。

##### 小结以下

你只需要记住这两点：

1、在循环和多个表达式中不能`+`，频繁创建`sb`性能影响；

2、在单个表达式中可以用`+`，编译器直接做了优化；

## 11、字符串拼接+和 concat 的区别？

+和 concat 都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。

![](/images/进阶/11_1.jpg)

concat 源码：

![](/images/进阶/11_2.jpg)

##### 可以得出以下结论：

1、+可以是字符串或者数字及其他基本类型数据，而 concat 只能接收字符串。

2、+左右可以为 null，concat 为会空指针。

3、如果拼接空字符串，concat 会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用 StringBuilder。

4、从字节码来看+号编译后就是使用了 StringBuilder 来拼接，所以一行+++的语句就会创建一个 StringBuilder，多条+++语句就会创建多个，所以为什么建议用 StringBuilder 的原因。

## 12、字符串在 JDK 内部是用的什么编码存储？

在 JDK 9 之前，字符串在 JDK 内部存储的编码是：UTF-16，每个字符固定占用 2 个字节。

但这样存储英文肯定是一种浪费，所以在 JDK9 中对这块进行了优化。

JDK 9 中的 String 类内部使用`byte[]`加上一个编码标记`coder`存储字符串，字符串在包含仅**Latin-1**字符时使用一个字节字符的**LATIN1**编码存储，从而减少内存占用，而包含**Unicode**字符时则使用两个字节/字符的**UTF-16**编码。

## 13、Java 9 之后，String 底层为什么使用 byte[]，而不是 char[]？

Java 8 及之前使用的是 char[]，char[]会占用两个字节，如果只存储`ISO-88591`之类的字符就会造成空间浪费。

Java 9+使用了压缩字符串，底层使用的是 byte[]，默认值占用一个字节，如果是`ISO-8859-1`编码外的字符，则会有一个字段进行标识。

```java
@Native static final byte LATIN1 = 0;
@Native static final byte UTF16 = 1;
```

##### coder 的作用：

- 变量为 latin1（ISO-8859-1）时（值为：0）时，会为其分配一个字节大小的空间；
- 变量为 UTF-16（值为：1）时，会为其分配两个字节大小的空间；

也就是说，它是通过 coder 来识别一个字符在 byte[]数组中占用一个字节还是两个字节的。

> 压缩字符串默认情况下是开启的，可以设置 JVM 参数：-XX:-CompactStrings 进行关闭。

## 14、设计自定义异常，是继承`Exception`还是`RuntimeException`？为什么？

> 在设计自定义异常时，不要使用继承 Throwable 的方式，它是所有错误和异常的基类，包括了 Error 和 Exception。
>
> 应该使用 Exception 或者 RuntimeException 来继承，以便更好地表达异常地含义。
>
> 具体继承哪个，这个没有绝对的答案，完全看业务功能需要。

##### 一般自定义异常会这样设计：

##### 1、如果自定义异常是由程序逻辑错误或者参数非法等导致的

此时应该继承 RuntimeException。

因为 RuntimeException 是不受检查异常，不用显式使用 throws 语句或者捕获异常处理，这样做可以全局拦截处理异常，不用再每一层方法调用中捕获或 throws 处理。

##### 2、如果自定义异常是由于外部因素或者系统错误等导致的

此时应该继承 Exception。

继承 Exception 的自定义异常必须显式使用 throws 语句捕获异常处理，这样做可以让调用者知道该方法可能抛出的异常，并且在必要的时候做出相应的处理。

## 15、为什么不建议捕获异常用来做业务流程控制？

先来看阿里的 Java 开发手册：

![](/images/进阶/15.jpg)

阿里巴巴禁止使用异常捕获用来做流程控制，条件控制。

因为异常设计的初衷是解决运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。

##### 除此之外还需要考虑以下几点：

1、如果将异常用于正常的业务流程控制，系统的代码可读性会变差。

2、创建和处理异常的过程会消耗更多的系统资源，如果频繁地在业务流程中引发和捕获异常，可能会对性能产生负面影响。

3、如果使用异常作为正常的控制流程，可能会覆盖或忽略真正的异常，使得真正的问题更难被发现和调试。

## 16、main 方法可以被继承吗？

Java 中的**main 方法是可以被子类继承的**，因为它本质上是类的一个静态方法，静态方法可以被继承。

假设有一个父类`Parent`，它有一个`main`方法：

```java
public clsss Parent {
    public static void main(String[] args) {
        System.out.println("java面试题");
    }
}
```

现在有一个子类`Child`继承自`Parent`：

```java
public class Child extends Parent {

}
```

如果你运行`Child`类，也会正常运行和输出结果，它实际上运行的是继承自`Parent`类的`main`方法。

## 17、main 方法可以被重写和重载吗？

**main 方法可以重载**，但是 JVM 将始终调用原始的方法，而永远不会调用重载的 main 方法。

示例代码：

```java
public class Test {
    //
    public static void main(String[] args) {
        System.out.println("主 main 方法");
        main("重载的 main 方法");
    }

    // 重载的main方法
    public static void main(String arg) {
        System.out.println(arg);
    }
}
```

##### main 方法不能重写！！！

因为 main 方法是静态方法，静态方法是属于类的，而不是属于类的实例的，所以静态方法在 Java 中不能被重写，只能被隐藏。

## 18、main 方法能同步吗？

是的，`main`方法可以被同步。

在 Java 中，`main`方法本质上是一个静态方法，而静态方法可以被同步，同步一个静态方法标识对该类的 Class 对象加锁，可以防止多个线程同时执行类中的任何静态同步方法。

示例代码：

```java
public static synchronized void main(String[] args) {
    System.out.println("同步的main方法开始执行");
    // 模拟一些长时间运行的操作
    try {
        Thread.sleep(1000);  // 让当前线程暂停1秒钟
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // 重新设置中断状态
    }

    System.out.println("同步的main方法执行结束");
}
```

> ##### 需要注意的是：
>
> 以上代码只是为了说明`main`方法可以被同步，在实际开发中并不推荐这样做，因为`main`方法是程序的入口，用于启动应用程序，它不会被线程并发访问。

如果`main`方法执行了很长时间的操作，需要同步来防止并发执行，那么更好的做法是在`main`方法内同步特定的代码块，或者在其他更合适的地方进行同步，而不是直接同步整个`main`方法。

## 19、main 方法能不能改为非静态？

不能改为非静态，main 方法必须声明为静态的，这样 JVM 才可以调用 main 方法而无需实例化他的类。

如果从 main 方法去掉**static**这个声明，示例代码：

```java
public clsaa Test {
    public void main(String[] args) {
        System.out.println("java面试题");
    }
}
```

虽然编译依然可以成功，但在运行时会导致程序出错：

> 错误：main 方法不是类 cn.slq.test.Test 中的 static，请将 main 方法定义为：
>
> public static void main(String[] args)

## 20、main 方法为什么是静态的？

main 方法一定是静态的，主要的好处是**它允许 JVM 在不创建类实例的情况下直接调用该方法**，如果 main 方法是非静态的，那么在调用 main 方法时 JVM 就得实例化它的类。

这种设计简化了程序的启动过程，还有助于避免与对象状态和生命周期相关的复杂性，确保应用程序有一个清晰、一致的入口点。

## 21、main 方法必须是 public static void？

Java 的`main`方法必须是`public static void`，原因如下。

---

##### 为什么是 public？

`main`方法必须是公开的，因为它将由 JVM 调用，JVM 通过调用类的`main`方法启动一个 Java 程序，如果`main`方法不是公开的，JVM 将无法访问和执行它。

---

##### 为什么是 static？

`main`方法是静态的，因为当调用`main`方法时，没有创建任何类的实例。

如果`main`方法不是静态的，那么 JVM 就必须首先创建类的实例，然后再调用`main`方法，这是不可能的，因为`main`方法是程序的入口点，必须在创建任何其他对象之前执行。

---

##### 为什么是 void？

程序的结束通常是由系统或者用户决定的，而不是`main`方法决定的，所以，`main`方法不需要返回任何值。

所以，当我们编写一个 Java 程序时，必须包含`public static void main(String[] args)`方法，这样 JVM 才能找到程序的入口点，并开始执行程序。

## 22、Java 语法糖是什么意思？

##### 什么是语法糖？

语法糖（）是一种编程术语，指的是在编程语言中添加的某些语法，这些语法对语言的功能行没有影响，目的是为了让开发者能够写出更加清晰和简洁的代码。

Java 作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。

##### 语法糖的好处：

1、语法糖让代码更简洁，更易于理解，提升了代码可读性。

2、简化的语法减少了代码编写的复杂度，从而降低了出错的机会。

3、语法糖在编译时会被转换，不影响运行时环境，保证了向后兼容性。

##### 语法糖案例

##### 1、增强型 for 循环

Java 5 引入的增强型 for 循环，这是一种简化数组和集合遍历的语法糖。

```java
for (String element : array) {
    System.out.println(element);
}
```

这比传统的 for 循环语法更简洁，但实际上在编译时会被转换成使用迭代器或索引的形式。

##### 2、自动装箱与拆箱

Java 5 同样引入了自动装箱与拆箱机制，允许基本数据类型和它们的包装类之间自动转换。

```java
// 自动装箱，编译器会转换为Integer x = Integer.valueOf(10);
Integer x = 10;

// 自动拆箱，编译器会转换为int y = x.intValue();
int y = x;
```

在处理基本数据类型和它们的包装类时更加便捷。

##### 3、泛型

泛型是 Java 5 添加的另一个功能，它允许在编译时提供更加严格的类型检查，并消除代码中的类型转换。

```java
List<String> list = new ArrayList<>();
```

泛型的引入减少了大量的类型转换代码，但在编译时，泛型信息会被擦除，转换成原始类型。

##### 4、Lambda 表达式

Java 8 引入的 Lambda 表达式，提供了一种简洁的方式来编写代码。

```java
Runnable r = () -> System.out.println("java面试题");
```

使用 Lambda 表达式可以使代码更简洁，更易读，它们在编译后会被转换成匿名类。

##### 5、try-with-resources

这是 Java 7 引入的一个语法糖，用于简化资源管理，特别是在处理`java.lang.AutoCloseable`类型的资源时。

```java
try (BufferedReader br = new BufferedReader(new FileReader(path))) {
  return br.readLine();
}
```

资源`BufferedReader`会在 try 语句块结束时自动关闭，避免了显式关闭资源的需要。

等等，还有许多语法糖。。。

## 23、try 里面 return，finally 还会执行吗？

1、不管 try 有没有 return，finally 都会执行。

2、在 try 中 return，在 finally 执行前后把结果保存起来，即使在 finally 中有修改也以 try 中保存的值为准，但如果是引用类型，修改的属性会以 finally 修改后的为准。

3、如果 try/finally 都有 return，直接返回 finally 中的 return。

示例代码：

```java
public int testTryFinally () {
    try {
        // 这里的return语句会先执行，但返回的值会在finally执行后再返回
        return 10;
    } finally {
        // 这里的代码在return之后执行
        System.out.println("finally块被执行");
    }
    // 这里不会执行到
}
```

## 24、try-catch 写在循环里面好还是外面好？

面试官：

> try-catch 到底写在循环里面好，还是外面好？

这个问题，我相信大部分人都会答错。

##### 到底写在哪里好？

---

很多人会说当然写在循环外面好，也有一部分人说些在循环里面好， 其实这两种回答都不完全对，我们来分析两者的弊端。

##### try-catch 写在循环外面的弊端：

```java
try {
    for (...) {
        // 处理逻辑
    } catch (Exception e) {
        ...
    }
}
```

如果 try-catch 写在循环外面，一条数据处理异常，循环结束，会导致真个任务的结束，严重影响系统效率。

##### try-catch 写在循环里面的弊端：

```java
for () {
    try {
        // 处理逻辑
    } catch (Exception e) {
        ...
    }
}
```

因为异常处理会影响效率，如果 try-catch 写在循环里面，会造成过多的、没有必要的循环异常处理，会严重影响系统效率。

这一点阿里巴巴的《Java 开发手册》异常处理中也有相关提及：

![](/images/进阶/24.jpg)

这里提到了异常的处理效率，确实相对较低，如果循环中写 try-catch，异常不发生或者少发生就还好，如果异常发生较多，系统效率肯定会降低。

所以，不管写在哪里，这个要看实际情况，要结合具体业务在做出具体的选择的，并不是绝对的写在哪里就一定好或者不好。

##### 应用场景

---

下面我总结一下两者的应用场景

##### try-catch 适合写在循环外面的场景：

（1）一条数据处理异常，需要停止后面的数据处理；

（2）不能接受任意数据处理异常， 如在事务方法中，需要整体成功或者失败，这时一条数据处理异常，就需要停止循环后面的数据处理，同时需要回滚循环中所有已处理过的数据；

##### try-catch 适合写在循环里面的场景：

（1）一条数据处理异常，不能影响其他数据的处理；

（2）能接受少部分的数据处理异常，而不影响整体数据处理；

如果是连接超时异常类，如果要写在循环里面，可以设置在超过 N 条连接超时后强制退出循环，一方面排除了网络波动，服务可能真的出现故障，这时可以避免过多没有必要的请求超时，待服务恢复后再重试；

##### 总结

---

目前没有规范说一定要写在哪里比较好，try-catch 写在循环里面或者外面都可以，上面分析了两者的弊端和应用场景，我们也可以根据实际业务场景作出选择。

## 25、`void`和`Void`有什么区别？

##### void

void 用于无返回值的方法定义，当你定义一个方法时，如果这个方法不需要返回任何值，就可以使用`void`作为方法的返回类型。

示例代码：

```java
public void println() {
    System.out.println("这是一个void方法，不返回任何值。");
}
```

##### Void

Void 是`java.lang`包中的一个类，它是一个泛型占位符，在泛型代码中，特别是在使用泛型方法或泛型类时，如果需要标识没有任何类型，可以使用`Void`类型，一般用于指示某些操作没有返回值，特别是在使用泛型回调、Future 或者反射时较为常见。

Void 是一个无用类，不能创建`Void`类的实例。

以下是`Void`类的源码：

```java
public final class Void {
    @SuppressWarnings("unchecked")
    public static final Class<void> TYPE = (Class<void>) Class.getPrimitiveClass("void");

    private void() {}
}
```

示例代码：

```java
public Future<Void> testAsyncOperation() {
    CompletableFuture<Void> future = new CompletableFuture<>();

    // 异步操作完成后完成future
    return future;
}
```

## 26、Java 常用的元注解有哪些？

JDK 5 开始提供了 4 个元注解，用来定义自定义注解的注解，它们分别是：

##### @Target

指定注解使用的目标范围（类、方法、字段等），其参考值类的定义：java.lang.annotation.ElementType

##### @Documented

指定被标注的注解会包含在`javadoc`中。

##### @Retention

指定注解的生命周期（源码、class 文件、运行时），其参考值见类的定义：java.lang.annatation.RetentionPolicy

##### @Inherited

指定子类可以继承父类的注解，只能是类上的注解，方法和字段的注解不能继承。即如果父类上的注解是`@Inherited`修饰的就能被子类继承。

---

##### JDK 8 又提供了以下两个元注解：

##### @Native

指定字段是一个常量，其值引用 native code。

##### @Repeatable

注解上可以使用重复注解，即可以在一个地方可以重复使用同一个注解，像 Spring 中的包扫描注解就是用了这个。

了解了 JDK 对注解的定义，所以想要自定义一个注解就以`@interface`开始吧。

## 27、Java 金额计算怎么避免精度丢失？

##### 经典的精度丢失问题

Java 中的类型 float、double 用来做计算会有精度丢失问题，下面来看下面的示例。

```java
public static void main(String[] args) {
    test1();
    test2();
}

private static void test1() {
    double totalAmount = 0.09;
    double feeAmount = 0.02;
    double tradAmout = totalAmout - feeAmount;
    System.out.rintln(tradeAmount);
}
```

上面的程序输出结果是多少？

0.07？非也！

正确的结果是：

> 0.0699999999999999

为什么是这样？

浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是 CPU 所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。

浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用 float、double 作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。

##### 怎么解决

> float 和 double 只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。

BigDecimal 适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。

不过，使用 BigDecimal 不当也有精度丢失的情况，如 double 的构造方法：

```java
BigDecimal(double val)
```

再来看这个示例：

```java
private static void test2() {
    double totalAmout = 0.09;
    double feeAmount = 0.02;
    BigDecimal tradeAmount = new BigDecimal(totalAmount).subtract(new BigDevimal(feeAmount));
    System.out.println(tradeAmount);
}
```

输出：

> 0.0699999999999999962529972918900966760702431201934814453125

这个精度更恐怖了。。。

所以，一定要使用 String 的构造方法：

```java
BigDecimal(String val)
```

```java
private static void test3() {
    double totalAmout = 0.09;
    double feeAmount = 0.02;
    BigDecimal tradeAmount = new BigDecimal(String.valueOf(totalAmount))
        .subtract(new BigDecimal(String.valueOf(feeAmount)));
    System.out.println(tradeAmount);
}
```

##### 总结

1、金额运算尽量使用 BigDecimal(String val)进行运算。

2、数据库存储金额，一般有整型和浮点型两种存储方式。如果有汇率转换的，建议使用浮点数 decimal 进行存储，可以灵活的控制精度，decimal 直接对应 Java 类型 BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。

## 28、Java 中的>>和>>>是什么语法？有什么区别？

在 Java 中有三种移位操作：

- 有符号左移（`<<`）
- 有符号右移（`>>`）
- 无符号右移（`>>>`）

这些移位操作，用于将操作数的二进制表示向左或右移动指定位数。

##### 1、有符号左移（`<<`）

对于左移操作，Java 只提供了一个运算符：`<<`。

当你对一个数值进行左移操作时，右侧空出的位总是用 0 填充，这与该数值是正数还是负数无关。所以，左移操作本质上是无符号的，所以不需要另一个专门的无符号左移（`<<<`）运算符。

示例代码：

```java
public static void main() {
    int positive = 4;  // 二进制表示：0000 0100
    int negative = -4;  // 二进制表示：1111 1100（补码形式）

    // 输出 8（0000 1000）
    System.out.println(positive << 1);

    // 输出 -8（1111 1000）
    System.out.println(negative << 1);
}
```

##### 2、有符号右移（`>>`）

`>>`是有符号右移运算符，对于正数和负数，右侧移出的位将被丢弃，而左侧空出的位将根据原始数字的符号位填充，即正数用 0 填充，负数用 1 填充。

```java
public static void main(String[] args) {
    // 二进制表示：0000 0100
    int positive = 4;

    // 二进制表示：1111 1100（补码形式）
    int negative = -4;

    // 输出2（0000 0010）
    System.out.println(positive >> 1);

    // 输出-2（1111 1110）
    System.out.println(negative >> 1);
}
```

##### 3、无符号右移（`>>>`）

`>>>`是无符号右移运算符，和有符号右移（`>>`）不同的是，即无论正数还是负数，右侧移出的位将被丢弃，左侧空出的位总是用 0 填充。

示例代码：

```java
public static void main(String[] args) {
    // 二进制表示：0000 0100
    int positive = 4;

    // 二进制表示：1111 1100（补码形式）
    int negative = -4;

    // 输出2（0000 0010）
    System.out.println(positive >>> 1);

    // 输出214783646（0111 1111 1111 1111 1111 1111 1111 1110）
    System.out.println(negative >>> 1);
}
```

##### 为什么是 2147483646？

在 32 位二进制中，-4 的补码表示是`0111 1111 1111 1111 1111 1111 1111 1110`，无符号右移一位（>>> 1）意味着所有位向右移动一位，最左边空出的位用 0 填充，所以是`0111 1111 1111 1111 1111 1111 1111 1110`，即 2147483646。

---

无符号右移运算符在处理二进制数据时非常有用，尤其是在需要忽略符号位，仅对位进行操作时。它常用于位操作任务中，如编写低级网络协议、加密算法进行位级数据操作等场景。

## 29、Java 类初始化顺序是怎样的？

##### 示例 1：测试单类的初始化顺序

```java
public class ClassInitOrderTest {
    public static String staticField = "static field";

    static {
        System.out.println(staticField);
        System.out.println("static block");
    }

    private String field = "member field";

    {
        System.out.println(field);
        System.out.println("non-static block");
    }

    public ClassInitOrderTest() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        new ClassInitOrderTest();
    }
}
```

程序输出：

> static field
>
> static block
>
> member field
>
> non-static block
>
> constructor

可以得出以下结论，单类的初始化顺序为：

> 静态变量 > 静态初始块 > 成员变量 > 非静态初始块 > 构造器

##### 示例 2：测试类继承的初始化顺序

```java
class Parent {
    private static String parentStaticField = "parent static field";

    static {
        System.out.println(parentStaticField);
        System.out.println("parent static block");
    }

    private String parentField = "parent member field";

    {
        System.out.println(parentField);
        System.out.println("parent non-static block");
    }

    public Parent() {
        System.out.println("parent constructor");
    }
}


public class Child extends Parent {
    private static String childStaticField = "child static field";

    static {
        System.out.println(childStaticField);
        System.out.println("child static block");
    }

    private String childField = "child member field";

    {
        System.out.println(childField);
        System.out.println("child non-static block");
    }

    public Child() {
        System.out.println("child constructor");
    }

    public static void main(String[] args) {
        new Child();
    }
}
```

程序输出：

> parent static field
>
> parent static block
>
> child static field
>
> child static block
>
> parent member field
>
> parent non-static block
>
> parent constructor
>
> child member field
>
> child non-static block
>
> child constructor

可以得出以下结论，单类的初始化顺序为：

> 父类静态变量 > 父类静态初始块 > 子类静态变量 > 子类静态初始块 > 父类成员变量 > 父类非静态初始块 > 父类构造器 > 子类成员变量 > 子类非静态初始块 > 子类构造器

##### 示例 3：测试成员变量、初始块的初始化顺序

从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续！

```java
public class TestOrder {
    private static A a = new A();

    static {
        System.out.println("static block");
    }

    private static B b = new B();

    public static void main(String[] args) {
        new TestOrder();
    }
}

class A {
    public A() {
        System.out.println("static field A");
    }
}

class B {
    public B() {
        System.out.println("static field B");
    }
}
```

程序输出：

> static field A
>
> static block
>
> static field B

可以得出以下结论，单类的初始化顺序为：

> 静态变量 A > 静态初始块 > 静态变量 B

所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。

## 30、为什么成员变量命名不建议用 isXXX？

首先我们来看阿里巴巴的《Java 开发手册》关于`isXXX`是怎么定义的吧：

> 【强制】POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。
>
> 反例：定义为基本数据类型 Boolean isDeleted 的属性，他的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。

上面的规范很容易理解吧，就是如果使用`isXXX`这种命名形式会引起潜在的异常。

##### 我们再来看一段 IDE 生成的 getter/setter 代码：

```java
public class Staff {
    private String name;

    private boolean graduated;

    private boolean isMarried;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isGraduated() {
        return graduated;
    }

    public void setGraduated(boolean graduated) {
        this.graduated = graduated;
    }

    public boolean isMarried() {
        return isMarried;
    }

    public void setMarried(boolean married) {
        isMarried = married;
    }

}
```

变量`isMarried`生成的 getter/setter 方法是：isMarried/setMarried，有些框架就会去找对应的`married`变量，然后就找不到了。。。

再看变量`graduated`，因为都是 boolean 变量，所有生成的逻辑和`isMarried`一样，根据上述规范，它不会产生找不着值得情况，这也是为什么不建议使用`isXXX`的命名形式。

## 31、hashCode 有什么用？

hashCode 是根据对象的地址算出来的一个 int 数字，即对象的哈希值，代表了该对象在内存中的物理存储位置。

Object 顶级类提供了一个 hashCode()方法，

```java
public native int hashCode();
```

根据协定，所有类在重写 equals 方法时必须重写 hashCode()方法，不然会导致潜在的程序危害。

hashCode 主要用于优化基于哈希表的数据结构的性能，如`HashMap`、`HashSet`和`HashTable`，具有相同内容的对象应该返回相同的 hashCode 值，通过 hashCode，哈希表能够快速定位键或对象的存储位置，这使得查找、插入和删除操作非常高效。

## 32、hashCode 和 identityHashCode 的区别？

identityHashCode 是 System 类里面提供的本地方法：

```java
@IntrinsicCandidate
public static native int identityHashCode(Object x);
```

hashCode 方法可以被重写，hashCode()方法返回的是重写后的值。

##### identityHashCode 和 hashCode 的区别是：

identityHashCode 会返回对象的原始 hashCode，而不管对象是否重写了 hashCode 方法。

---

测试代码：

```java
public class Test {
    public static void main(String[] args) {
        String str1 = new String("abc");
        String str2 = new String("abc");

        System.out.println("str1 hashCode:" + str1.hashCode());
        System.out.println("str2 hashCode:" + str2.hashCode());
        System.out.println("str1 identityHashCode:" + System.identityHashCode(str1));
        System.out.println("str2 identityHashCode:" + System.identityHashCOde(str2));

        User user = new User("test", 1);
        System.out.println("user hashCode:" + user.hashCode());
        System.out.println("user identityHashCode:" + System.identityHashCode(user));
    }

    static class User {
        private String name;
        private int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }
    }
}
```

输出结果：

> str1 hashCode:96354
>
> str2 hashCode:96354
>
> str1 identityHashCode:83954662
>
> str2 identityHashCode:1751075886
>
> user hashCode:777874839
>
> user identityHashCode:777874839

结果分析：

1、str1 和 str2 的 hashCode 是相同的，是因为 String 类重写了 hashCode 方法，它根据 String 的值来确定 hashCode 的值，所以只要值一样，hashCode 就会一样。

2、str1 和 str2 的 identityHashCode 不一样，虽然 String 重写了 hashCode 方法，identityHashCode 永远返回根据对象物理内存地址产生的 hash 值，所以每个 String 对象的物理地址不一样，identityHashCode 也会不一样。

3、User 对象没重写 hashCode 方法，所以 hashCode 和 identityHashCode 返回的值一样。

## 33、什么是 hash 冲突？

这个要先了解下 Java 通用约定。

> ##### 根据 Java 通用约定：
>
> 两个对象 equals 相等， 则它们的 hashCode 必须相等，反过来则不需要相同。

所以，如果两个对象同时对应一个 hashCode，equals 却并不相等，但在 Hash 相关的集合中，使用是 hashCode 来决定数组索引位置的，如果 hash 值相同，equals 不同，多个 hash 值相同的不同对象就会对应同一个索引位置，此时就会出现传说中的 hash 冲突。

## 34、编程实现一个 hash 冲突的例子

下面使用**HaahMap**来编程实现一个 hash 冲突的例子：

```java
public class Test {
    public static class InnerClass {
        public int id;

        public int getId() {
          return id;
        }

        public InnerClass(int id) {
            this.id = id;
        }

        @Override
        public boolean equals(Object obj) {
            return ((InnerClass) obj).getId() == this.getId();
        }

        @Override
        public int hashCode() {
            return 1;
        }
    }


    public static void main(String[] args) throws Exception {
        Map<InnerClass, Integer> map = new HashMap<>();
        for (int i = 0; i < 20; ++i) {
            InnerClass innerClass = new InnerClass(i);
            map.put(innerClass, i);
        }
    }
}
```

InnerClass 类重写了 equals 和 hashCode 方法，但是使用的是同一个 hash 值 1，以模拟 hash 冲突的场景，然后循环创建作为 key 放入到 HashMap 中，调试结果如下：

![](/images/进阶/34_1.jpg)

当 for 循环 8 次 put 后，数组实际元素长度为 8，但 hash 始终为 1，即 hash 冲突了。

此时链表长度达到 8，数组默认容量 < 64 时只会扩容，所以此时还不会转红黑树，链表一旦达到 8 就会继续扩容直到数组容量>= 64：

> 链表长度 - 数组容量的变化：8 - 16， 9 - 32， 10 -64

然后继续调试，当链表达到了 10，此时数组长度 >= 64 位长度，此时链表会转换为红黑树：

![](/images/进阶/34_2.jpg)

## 35、Java 中的断言（assert）是什么？

在 Java 中，断言（assert）关键字是从 JDK4 引入的，断言是为了方便调试程序。

为了避免和老版本的 Java 代码中使用了`assert`关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关`-anbaleassertions`或`-ea`来开启。

断言的语法很简单，有两种写法：

##### 1、assert<boolean 表达式>

- 如果为<boolean 表达式>true，则程序继续执行。
- 如果为 false，则程序抛出 AssertionError，并终止执行。

##### 2、assert<boolean 表达式>：<错误信息表达式>

- 如果<boolean 表达式>为 true，则程序继续执行。
- 如果为 false，则程序抛出 java.lang.AssertionError，并输入<错误信息表达式>。

## 36、IntegerCache 类有什么用？

IntegerCache 是 JDK1.5 版本中添加的一项新特性，把-128~127 的数字缓存起来了，用于提升性能和节省内存。

所以-128~127 这个范围内的自动装箱的数字都会从缓存中获取，返回同一个数字，同时这也会给我们开发带来预想不到的陷阱，需要注意！

如 IntegerCache 的源码，先把-128~high 放在缓存中：

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer[] cache;
    static Integer[] archivedCache;

    static {
        int h = 127;
        String integerCacheHighPropValue = VM.getSaveProperty("java.lang.IntegerCache.high");
        if (integerCacheGighPropValue != null) {
            try {
             h = Math.max(parseInt(integerCacheHighPropValue), 127);
             h = Math.min(h, Integer.MAX_VALUE - (-low) -1);
            } catch (NumberFormatException nfe) {

            }
        }
        high = h;

        CDS.initializeFromArchive(IntegerCache.class);
        int size =(high - low) + 1;
        if (archivedCache == null ll size > archivedcache.length) {
            Integer[] c = new Integer[size];
            int j = low;
            for(int i = θ; i < c.length; i++) {
                c[i] = new Integer(j++);
            }
            archivedcache = c;
        }
        cache = archivedcache;
        assert IntegerCache.high >= 127;
    }
    private IntegerCache() {}
}
```

从源码里面我们可以看到最小边界是：-128，最大边界可以通过-XX:AutoBoxCacheMax 进行配置，但也不能大于 Integer.MAX_VALUE 最大值。

再来看 Integer.valueOf 的源码，先从缓存中获取，获取不到再 new 个返回:

```java
@IntrinsicCandidate
public static Integer valueof(int i) {
    if （i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

再看下面的构造器源码，new Integer 并没有使用缓存，所以我们通过 **new Integer(1）**这样写就不会从缓存中获取,也没有陷阱。

```java
@Deprecated(since="9", forRemoval = true)
public Integer(int value){
    this.value = value;
}
 @Deprecated(since="9", forRemoval = true)
public Integer(String s) throws NumberFormatException {
    this.value = parseInt(s, 10);
}
```

> 这种缓存行为不仅用于 Integer 类，而且还用于 Long,Short,Byte,Character，大家可以去这些类里面查看 XxxCache 的类和 valueOf 方法源码，原理大致相同，但它们的边界略有一二，也不能进行最大边界的配置。

**关于 Integer，-128 ～ 127 会有缓存，对比这个范围的数值的对象是个玩，这个在阿里巴巴规范中也有提及。**

## 37、char 类型可以存储中文汉字吗？

char 类型可以存储中文汉字。

因为 Java 中使用的编码是 Unicode，一个 char 类型占 2 个字节（16 Bit），而一个中文也是占 2 个字节，所以存放一个中文是没问题的。

示例代码：

```java
public static void main(String[] args) throws Exception {
    //使用单引/号将中文字符赋值给char类型的变量
    char ch ='中';
    //输出：中
    System.out.println(ch);
}
```

## 38、Java 中的一个汉字占几个字节？

在 Java 中，一个汉字所占的字节数**取决于所使用的字符编码**，不同的编码方式会有不同的字节表示。

下面是一些常见编码下汉字所占的字节数：

##### GBK:

在 GBK 编码中，一个汉字通常占用 **2 个字节**。

##### UTF-8:

在 UTF-8 编码中，一个汉字占用 **3 个字节**。UTF-8 是一种可变长度的字符编码方式，对于 ASCII 字符占用 1 个字节，对于大多数汉字占用 3 个字节，对于 Unicode 扩展区的字符可能占用 4 个字节。

##### UTF-16:

在 UTF-16 编码中，一个汉字占用 **2 个字节**。

## 39、Java 中的一个字符占几个字节？

Java 中的 char 字符类型，占用 2 个字节。

更多基本数据类型的字节大小见这张表格：

| 数据类型 | 字节大小        | 默认值   | 包装类    |
| -------- | --------------- | -------- | --------- |
| byte     | 1               | 0        | Byte      |
| short    | 2               | 0        | Short     |
| int      | 4               | 0        | Integer   |
| long     | 8               | 0L       | Long      |
| float    | 4               | 0.0f     | Float     |
| double   | 8               | 0.0d     | Double    |
| char     | 2               | '\u0000' | Character |
| boolean  | 1/8（一个 bit） | false    | Boolean   |

## 40、为什么 Java 不支持类多继承？

Java 是一种简单面向对象解释型的语言，多继承会使设计复杂化，并且会带来各种问题。Java 不支持类的多继承是一个设计选择，**目的是为了减少复杂性和歧义性，提高代码的清晰度和可维护性。**

##### 比如多重继承带来的钻石问题：

![](/images/进阶/40.jpg)

在这个例子中，类 B 和 C 都继承了抽象类 A，并且进行了方法实现，如果 D 通过多继承继承了 B 和 C，那么 D 应该继承 B 的还是 C 的方法？

这就陷入了矛盾，这就是钻石形继承问题产生的歧义，所以 Java 类不支持多继承。

##### Java 中的解决方案：

为了解决这个问题，Java 在设计时选择了禁止类的多继承，转而支持接口的多继承。

接口可以被任意数量的类实现，这提供了多继承的某些好处，但避免了钻石问题，因为接口只能声明方法不能提供方法的实现。这样，即使一个类实现了多个接口，那些接口中相同的方法也必须由该类来提供具体的实现，从而避免了歧义。

此外，从 Java 8 开始，接口可以包含默认方法（带有实现的方法）。为了避免与类多继承相同的问题，Java 对于默认方法也有明确的规则：**如果一个类继承的多个接口中存在签名相同的默认方法，那么该类必须覆盖这个方法以解决冲突。**

## 41、ava 支持运算符重载吗？为什么？

与 C++不同，Java 不支持运算符重载。

> 运算符重载是指允许开发人员重新定义运算符（例如+、-、\*、／等）的行为，使其能够适用于自定义的数据类型。

Java 之父在设计 Java 语言时考虑了许多因素，其中之一就是尽量保持语言的**简洁性，一致性和易于理解。**

##### 运算符重载的缺点：

1、运算符重载可能会导致代码变得晦涩难懂，因为同一个运算符在不同的上下文中可能会有不同的行为，从而增加理解代码的难度。

2、运算符重载还可能导致混淆和错误，因为它会使代码的行为变得不确定。

所以，Java 不支持运算符重载，Java 鼓励开发者使用明确的方法来执行操作，以提高代码的可读性和可维护性。

## 42、动态代理都用到了哪些技术？

##### 1、Java 内置动态代理

利用`java.lang.reflect.Proxy`类和`java.lang·reflect.InvocationHandler` 接口，主要用于接口的动态代理,通过`Proxy.newProxyInstance`方法，可以在运行时动态创建实现指定接口的代理实例，` InvocationHandler`是实际处理代理方法调用的地方。

##### 2、CGLIB

CGLIB 能够在运行时动态增强类的方法，广泛用于 Spring 框架中进行 AOP 编程，它通过继承方式动态生成被代理对象的子类，适用于代理类，而非接口。

##### 3、反射

需要通过反射动态调用被代理对象的方法。

## 43、ava 反射机制有什么用？

##### 反射介绍

---

Java 的反射机制（reflection）是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法，而不需要在编译时知道具体的类。

这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制，反射被视为动态语言的关键。

##### 反射示例

---

##### 1、运行时类信息获取

通过反射，可以在运行时获取任意一个对象所属的类的信息，包括类名、方法信息、字段信息、构造函数信息等。

示例代码：

```java
public static void main(String[] args) throws Exception {
    Class<?> clazz = Class.forName("java.util.ArrayList");
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
        System.out.println(method.getName());
    }
}
```

##### 2、运行时实例化对象

反射允许在运行时动态创建对象实例，即使在编译时不知道类名，这在处理动态加载或插件化架构时特别有用，比如：SPI 机制。

示例代码：

```java
public static void main(string[] args) throws Exception {
    Class<?> clazz = Class.forName("java.util.ArrayList");
    List<String> list = (ArrayList<string>) clazz.newInstance();
    list.add("java");
    list.add（"面试题");
    System.out.println(list);
}
```

##### 3、运行时方法调用

可以通过反射调用对象的方法，即使这些方法在编译时未知或不可访问。

示例代码：

```java
public static void main(string[] args) throws Exception {
    //运行时实例化对象
    Class<?> clazz = Class.forName("java.util.ArrayList");
    List<string> list = (Arraylist<string>) clazz.newInstance();
    //运行时方法调用
    Method method = clazz.getMethod("add", object.class);
    method.invoke(list,"公众号");
    method.invoke(list,"Java技术栈");
    System.out.println(list);
}
```

##### 4、运行时访问和修改字段

反射允许访问和修改对象的私有字段，这在某些特殊情况下非常有用，但应谨慎使用以避免破坏封装性。

示例代码：

```java
public static void main(String[] args) throws Exception {
    //运行时实例化对象
    Class<?> clazz = Class.forName("java.util.ArrayList");
    List<string> list = (ArrayList<string>) clazz.newInstance();
    //运行时访问和修改字段
    Field field = clazz.getDeclaredField("size");
    field.setAccessible（true);
    //让私有字段可访问
    int size = field.getint(list);
    System.out.println(size);
}
```

## 44、Java 反射机制的优缺点？

尽管 Java 反射提供了极大的灵活性和动态性，但它的使用也伴随着一些缺点和潜在风险，以下是 Java 反射机制的主要优缺点。

##### 反射的优点

##### 1、灵活性

反射提供了极大的灵活性，允许在运行时动态创建对象、调用方法、访问字段，这在编写通用框架或需要大量动态性的应用程序时非常有用。

##### 2、解耦

反射有助于解耦代码组件，使得程序的各个部分可以独立开发和使用，降低了模块间的依赖。

##### 3、调试和测试

反射可以用于调试和测试目的，比如在测试代码中访问和修改私有成员，无需修改原始代码的可见性。

---

##### 反射的缺点

##### 1、性能开销

反射操作的性能比直接代码调用慢，因为它需要进行额外的处理，如类型检查和方法调用解析，所以反射操作可能导致性能下降，特别是在密集调用的情况下。

##### 2、安全风险

- 由于反射涉及的类型是在运行时确定的，编译器无法对反射代码进行类型检查，这可能导致运行时错误而这些错误在编译时是不可见的。

- 反射可以用于访问和修改类的私有成员，这可能会破坏封装性原则，增加安全风险，不当使用可能导致代码难以理解和维护。

##### 3、代码的可读性和可维护性

过度使用反射可能会使代码难以理解和维护，因为反射代码通常比直接代码调用更抽象和复杂。

---

Java 反射机制是一个双刃剑，它提供了强大的灵活性和动态性，但也带来了性能和安全性的挑战。

在使用反射时，应该权衡它的优缺点，并在确实需要动态性的情况下谨慎使用，以保持代码的清晰、高效和安全。

## 45、Java 反射机制 Class 类有哪些常用方法？

Class 类的常用方法如下：

| 方法名称                | 描述                                                                                    |
| ----------------------- | --------------------------------------------------------------------------------------- |
| getName                 | 返回类的完全限定名。                                                                    |
| getSuperclass           | 返回该类的父类的 class 对象。                                                           |
| getlnterfaces           | 返回该类实现的接口的 class 对象数组。                                                   |
| getModifiers            | 返回类或成员的修饰符。                                                                  |
| getFields               | 返回类或接口的所有公共字段的勺 Field 对象数组。                                         |
| getDeclaredFields       | 返回类或接口声明的所有字段的 Field 对象数组，包括私有和受保护的，但不包括继承的字段。   |
| getMethods              | 返回类或接口的所有公共方法的勺 Method 对象数组，包括继承的方法。                        |
| getDeclaredMethods      | 返回类或接口声明的所有方法的』Method 对象数组，包括私有和受保护的，但不包括继承的方法。 |
| getConstructors         | 返回类的所有公共构造函数的 constructor 对象数组。                                       |
| getDeclaredConstructors | 返回类声明的所有构造函数的 Constructor 对象数组，包括私有和受保护的。                   |
| getField                | 返回指定公共成员字段的 Field 对象。                                                     |
| getDeclaredField        | 返回指定声明字段的勺 Field 对象，包括私有和受保护的。                                   |
| getMethod               | 返回指定公共成员方法的 Method 对象。                                                    |
| getDeclaredMethod       | 返回指定声明方法的 Method 对象，包括私有和受保护的。                                    |
| getConstructor          | 返回指定公共构造函数的 Constructor 对象。                                               |
| getDeclaredConstructor  | 返回指定声明构造函数的对象，包括私有和受保护的。                                        |
| newlnstance             | 创建此 Class 对象所表示的类的新实例。                                                   |
| islnterface             | 判断此 Class 对象是否表示一个接口类型。                                                 |
| isArray                 | 判断此 Class 对象是否表示一个数组类型。                                                 |
| isPrimitive             | 判断此 Class 对象是否表示一个基本类型。                                                 |

## 46、Java 反射可以访问私有方法吗？

是的，Java 反射可以访问私有方法。

通过反射可以绕过 Java 的访问控制检查，访问一个类的私有成员，包括私有方法，这在某些特殊情况下非常有用，比如需要动态访问对象内部属性和方法时。

##### 访问私有方法：

- Class.getDeclaredMethod(String name, Class[] parameterTypes)

- Class.getDeclaredMethods()

  然后调用 Method 的 setAccessible(true)方法。

  示例代码：

```java
public static void main(String[] args) throws Exception {
    // 获取 User 的CLass 对象
    Class<?> clazz = Class.forName("User");
    // 创建User的实例
    User user = (User) clazz.newInstance();
    // 获取私有方法对象
    Method buildNameMethod = clazz.getDeclaredMethod("buildName");
    //设置私有方法为可访问
    buildNameMethod.setAccessible(true);
    //调用私有方法
    buildNameMethod.invoke(user);
}
```

## 47、Java 反射可以访问私有变量吗？

可以的。

访问私有变量：

- Class.getDeclaredField(String name)
- Class.getDeclaredFields0

然后调用 Field 的 setAccessible(true) 方法。

示例代码：

```java
public static void main(String[] args) throws Exception {
    //运行时实例化对象
    Class<?> clazz = Class.forName("java.util.Arraylist");
    List<String> list = (ArrayList<String>) clazz.newInstance();
    //运行时访问和修改字段
    Field field = clazz.getDeclaredField("size");
    field.setAccessible(true)；
    // 让私有字段可访问
    int size = field.getInt(list);
    System.out.println(size);
}
```

> 需要注意的是，使用这种方式访问私有成员需要非常谨慎，因为它破坏了封装性，增加了代码的复杂性和维护难度。

## 48、ava 反射可以访问父类的成员吗？

可以的，先获取到父类：getClass).getSuperclass()，再根据相关方法去获取父类的成员。

示例代码：

```java
public static void main(String[] args) throws Exception {
    Childclass child = new Childclass();
    //获取父类的 CLass 对象
    Class<?> parentclass = child.getclass().getSuperclass();
    //访问父类的私有字段
    Field field = parentclass.getDeclaredField("privateField");
    field.setAccessible(true);
    String fieldvalue = (String) field.get(child);
    System.out.println("父类的私有字段值："+fieldvalue);
    //访问父类的私有方法
    Method method = parentClass.getDeclaredMethod("privateMethod");
    method.setAccessible(true);
    method.invoke(child);
}
```

## 49、Java 反射可以访问父类的私有方法吗？

可以的。

先获取到父类：getClass(.getSuperclass()

##### 访问私有方法：

- Class.getDeclaredMethod(String name, Class[] parameterTypes)
- Class.getDeclaredMethods()

然后调用 Method 的 setAccessible(true)方法。

示例代码：

```java
public static void main(String[] args) throws Exception {
    //创建子类的实例
    Childclass child = new Childclass();
    //获取父类ParentcLass的CLass对象
    Class<?> parentclass = child.getClass().getSuperclass();
    //获取父类的私有方法
    privateMethodMethod method = parentClass.getDeclaredMethod("privateMethod");
    //设置私有方法为可访问
    method.setAccessible(true);
    //调用私有方法
    method.invoke(child);
}
```

## 50、Java 反射可以访问父类的私有变量吗？

可以的。

先获取到父类：getClassO.getSuperclass()

##### 访问私有变量：

- Class.getDeclaredField(String name)
- Class.getDeclaredFields0

然后调用 Field 的 setAccessible(true) 方法。

示例代码：

```java
public static void main(String[] args) throws Exception {
    //创建子类的实例
    Childclass child = new Childclass();
    //获取父类 ParentcLass 的 CLass 对象
    Class<?> parentclass = child.getclass().getsuperclass();
    //获取父类的私有字段
    privateFieLdField field = parentclass.getDeclaredField("privateField");
    //设置私有字段为可访问
    field.setAccessible(true);
    //获取私有字段的值
    String value = (String) field.get(child);
    System.out.println("获取到的父类私有变量的值为：: " + value);
}
```

## 51、Java 反射有没有性能影响？

使用反射是会有一点性能和效率上的影响。

但比起它所带来的好处和便利性，以及应用程序本身所带来的性能问题，**反射影响的损耗只是微乎其微，基本可以忽略不计**，而且现在主流的 Java 框架都在大量使用反射。

## 52、Java 反射到底慢在哪？

Java 反射的性能开销主要体现在以下几个方面：

##### 1、运行时类型检查

反射调用涉及到运行时类型检查，反射需要在运行时动态解析类和成员的信息，这包括查找类、方法、字段等。与编译时直接绑定相比，这种动态查找增加了额外的时间开销。

##### 2、访问控制检查

反射调用涉及到更多的安全和访问控制检查，如检查是否允许访问私有或受保护的成员。这些检查在直接调用时通常不需要或在编译时就完成了。

##### 3、使用反射 API 的开销

使用反射涉及创建 Method 吴子 Field、Constructor 等反射对象，这些对象的创建和使用本身就比直接调用方法或访问字段更耗时。

##### 4、内存消耗

反射操作通常会产生更多的临时对象（如 Method、Field 对象等），这些对象占用内存并最终需要由垃圾回收器处理，从而增加了内存管理的负担。

## 53、怎么在运行时动态生成一个类？

##### 一、Java 官方方法

1、Java Compiler APl，通过 Java Compiler APl，可以在应用程序运行期间动态编译 Java 源代码，生成类，并立即加载和使用这些类。

2、另外，使用 Java 的动态代理机制也可以在运行时动态创建接口的实现类，一般用于代理设计模式或者 AOP 实现中。

##### 二、第三方类库

第三方比较常见且强大的是使用字节码操作库，如 **ASM、CGLIB、Javassist**，这些库可以在运行时动态生成和修改类或者增强类的功能。

## 54、String str="S";创建了几个对象？

> String str = "S";

这行代码一共创建了几个对象？

---

##### 这个题要分为两种情况：

1、如果字符串常量池中，已经创建："S"，此时创建了 0 个对象。

2、如果字符串常量池中，没有创建：“S"，此时在常量池中创建了 1 个对象。

## 55、new String（"S"）创建了几个对象？

> String s = new String("S");

这行代码一共创建了几个对象？

---

##### 这个题要分为两种情况：

1、如果字符串常量池中，已经创建："S"，此时只会在堆内存创建 1 个字符串对象。

2、如果字符串常量池中，没有创建：“S"，则会创建 2 个对象，一个在堆内存，一个在常量池。

## 56、判断两个字符串是否相等（1）

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 ="Java面试题";
    String str2 = "Java面试题";
    System.out.println(str1 == str2);
    System.out.println(strl.equals(str2));
}
```

##### 输出结果：

> true
>
> true

因为两者都指向常量池的同一个对象，不管怎么比较都会相等。

## 57、判断两个字符串是否相等（2）

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 = "Java面试题";
    String str2 = new String("Java面试题");
    System.out.println(str1 == str2);
    System.out.println(strl.equals(str2));
}
```

##### 输出结果：

> false
>
> true

因为两者为不同的两个对象，第一个对象在常量池，第二个对象在堆中创建的是常量池的副本。

## 58、判断两个字符串是否相等（3）

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 = "Java面试题";
    String str2 = "Java" +"面试" + "题";
    System.out.println(str1 == str2);
    System.out.println(strl.equals(str2));
}
```

##### 输出结果：

> true
>
> true

str1 指向常量池；

str2 由于常量优化机制，三个字符串常量相加本身就是常量；

因为 str1 常量已创建，所以 str2 无需创建，两者都指向常量池的同一个对象，不管怎么比较都会相等。

## 59、判断两个字符串是否相等（4）

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 ="Java面试题";
    String str2 = "Java";
    String str3 = str2 +"面试题";
    System.out.println(str1 == str3);
    System.out.println(strl.equals(str3));
}
```

##### 输出结果：

> false
>
> true

因为两者为不同的两个对象，第一个对象在常量池，第三个对象在堆中创建。

str1 指向常量池；

str3 在堆中创建了一个新对象，因为是变量和字符串相加，并没有常量优化机制，底层会调用 StringBuilder 拼接并形成一个新的字符串。

## 60、String.intern0 方法有什么用？

**String.intern()方法设计的初衷就是**：重用字符串对象，以便节省内存。

##### JDK 1.6：

先判断字符串常量池中当前字符串是否存在：

- **如果不存在**：将当前字符串复制到字符串常量池，并返回字符串常量池中字符串的引用；
- **如果存在**：不会改变字符串常量池已存在的引|用，并返回字符串常量池中的字符串引用；

##### JDK 1.7+：

先判断字符串常量池中当前字符串是否存在：

- **如果不存在：不会再将当前字符串复制到字符串常量池，而是将当前字符串的引 I 用复制到字符串常量池**，并返回字符串常量池中字符串的引用；
- **如果存在**：不会改变字符串常量池已存在的引用，并返回字符串常量池中的字符串引用；

## 61、判断字符串 intern 是否相等（1)

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 ="Java面试题";
    String str2 = new String("Java") + new String("面试题");
    System.out.println(str1 == str2.intern());
}
```

**输出结果**：true

因为”Java 面试题“已经创建并存在 str1，所以 str2.intern 返回的是字符串常量池中已存在的字符串 str1 的引用，两者指向的是同一个字符串对象。

## 62、判断字符串 intern 是否相等（2）

以下代码的输出结果是？

```java
public static void main(String[] args) {
    String str1 = new String("Java") + new String("面试题");
    System.out.println(str1 -- str1.intern());
}
```

##### 输出结果：

##### JDK 1.6: false。

因为字符串常量池中不存在时，先将当前字符串复制到字符串常量池，并返回字符串常量池中字符串的引用，所以两者是两个引用。

##### JDK 1.7+: true。

因为字符串常量池中不存在该字符串时，不会再将当前字符串复制到字符串常量池，而是将当前堆中的字符串的引用复制到字符串常量池，并返回字符串常量池中字符串的引用，所以两者是同一个引用。

## 63、对象比较是用 equals 还是==？为什么？

两个都可以，看情况使用。

> ==比较的是两个对象的 内存地址 是否相同，而 equals 方法比较的是两个对象的内容（如：成员变量）是否相同。

所以，如果比要基于两个对象的内容判断对象是否相同，应该使用并重写 equals 方法，而如果要比较两个对象（内存地址)是否完全相同，即同一个对象，需要使用 == 运算符。

> 如果要比较对象的内容是否相等，建议使用 JDK 自带的 ○bjects.equals 方法，它会先用 == 比较是否同一个对象，再比较对象的内容是否相等。

Objects.equals 源码如下 :

```java
public static boolean equals(object a, Object b) {
    return (a == b) ll (a != null && a.equals(b));
}
```

## 64、为什么不建议用 equals 判断对象相等？

Java 行业中 **并没有不建议** 使用 equals 方法判断对象相等的规范，相反，在比较对象内容是否相等时，equals 还是比较对象是否相等的标准实现方法。

> **为什么会有这样的问题？**
>
> 这是因为 equals 方法是要由开发人员自己实现的，由于每个人的技术水平差异，如果没有正确实现 equals 方法，可能会导致对象相等比较时的结果不正确。
>
> 所以，为了保证对象比较的正确性，需要确保要比较对象的类正确实现了 equals 方法。

## 65、程比较两个对象的内容是否相等？

> 比如有两个 User 对象，如何比较它们的内容是否相等？

比较两个对象内容是否相等，需要重写 User 类的 equals 方法和 hashCode 方法，下面是示例代码。

```java
public class User {
    private String name;
    private int age;
    public User(string name, int age) {
        this.name = name;
        this.age = age;
    }
    @override
    public boolean equals(object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof User)) {
            return false;
        }
        User user = (user) obj;
        return objects.equals(this.name, user.name)
            && objects.equals(this.age, user.age);
    }
    @override
    public int hashcode() {
        return objects.hash(this.name, this.age);
    }
}
```

两个对象在比较时，可以使用 equals 方法，或者是 Objects.equals 方法。

## 66、Java 有哪几种级别的引用？

为了使程序能更加灵活地控制对象的生命周期，从 JDK1.2 版本开始，JDK 把对象的引用级别分为了以下四种。

##### 这 4 种级别由高到低依次为：

- 强引|用(StrongReference)
- 软引|用(SoftReference)
- 弱引 l 用(WeakReference)
- 虚引|用(PhantomReference)

##### 下面通过一张表格来说明它们的回收时间、用途：

| 引用类型 | 回收时间           | 用途         |
| -------- | ------------------ | ------------ |
| 强引用   | 不在作用域可能回收 | 普通对象引用 |
| 软引用   | 内存不足时回收     | 缓存对象     |
| 弱引用   | 垃圾回收时回收     | 缓存对象     |
| 虚引用   | 不确定             | 跟踪垃圾回收 |

不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。

## 67、你怎么理解强引用？

强引用（Strong Reference）是 Java 中最基本的引 l 用类型，也是我们在日常开发中最常见的引 l 用形式，如以下代码：

```java
object obj = new object();
```

当我们像这样创建一个对象时，它就是强引 l 用，这里的`obj`就是对`Object`实例的强引用。

只要强引用还存在，垃圾回收器就不会回收被引用的对象，即使程序可能已经不再需要这个对象，也不会回收，这可能导致内存泄露。

## 68、你怎么理解软引用？

软引 l 用（Sof Reference）是 Java 中的一种引 l 用类型，它提供了一种灵活的内存敏感的缓存机制。

软引用的主要特点是，**它允许对象在 JVM 内存不足时被垃圾回收器回收**，从而避免了`outofMemoryError`异常的发生。

如果一个对象只有软引用：

- 内存空间足够情况下，垃圾回收器就不会回收它。
- 果内存空间不够了，就会对这些只有软引用的对象进行回收。

所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。

## 69、你怎么理解弱引用？

弱引 l 用（Weak Reference）是 Java 中的一种引 l 用类型，它比软引 l 用还要弱，在垃圾回收机制的角度看，它允许一个对象拥有更灵活的回收策略。

弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会进行回收。

> 由于垃圾回收器线程优先级很低，弱引用的对象也不一定会被很快回收。

弱引用可以用来实现一些规范化映射，如：WeakHashMap，当 key 不再被引引用时可以自动被回收。

## 70、你怎么理解虚引用？

虚引 l 用（Phantom Reference）是 Java 中四种引 l 用类型之一，它是最弱的一种引 l 用关系。

虚引用，顾名思义就是形同虚设，虚引用不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

**虚引引用主要用来跟踪对象被垃圾回收器回收的活动**，虚引用必须和引 l 用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

## 71、怎么实现一个强引用？

如代码所示：

```java
// 创建一个成员变量（强引用）
private object obj = new object();
public static void main(string[] args) {
    //创建一个局部变量（强引用)
    Object object = new object();
    // object 变量现在持有一个对 object实例的强引l用
    //只要object引l用存在，垃圾回收器就不会回收object实例
    //使用对象...
}
//当方法执行结束，局部变量object失去作用域，其强引用也随之消失
```

这就是强引用，object 持有了这个对象的存储地址的引用。

对于成员变量，当一个对象实例被垃圾回收器回收时，其内部的所有成员变量也会随之失去引用，如果这些成员变量没有在其他地方被引用，它们会被垃圾回收。

如果是局部变量，只要这个局部变量还在作用域内，垃圾回收器就不会回收这个对象。但是，一旦局部变量失去作用域，比如方法执行结束，局部变量就会从栈中移除，相应的强引用也随之消失。

## 72、怎么实现一个软引用？

软引用的实现类：

> java.lang.ref.SoftReference

创建软引用的示例如下：

```java
public static void main(string[] args) throws InterruptedException {
    //创建一个强引用对象
    object object = new object();
    //创建一个软引用。指向上面创建的对象
    SoftReference<object> softReference = new SoftReference<>(object);
    //清除强引用，确保这个对象只被虚引用所引用
    object = null;
    //强制进行垃圾回收
    System.gc();
    //休眠几秒，等待垃圾回收器回收
    Thread.sleep(3ea0);
    //在需要的时候通过软引用获取对象
    object data = softReference.get();
    if （data l= null) {
        System.out.println("对象还在："+ data);
    } else {
        System.out.println("对象已被垃圾回收器回收");
    }
}
```

输出结果：

> 对象还在： java.lang.Object@37f8bb67

因为内存足够，所以软引用没有被回收，该软引|用对象就可以继续被程序使用。

## 73、怎么实现一个弱引用？

弱引用的实现类：

> java.lang.ref.WeakReference

示例代码：

```java
public static void main(string[] args) {
    // 创建一个对象
    String original = new string("Java面试题");

    // 创建一个指向对象的弱引用
    WeakReference<String> WeakRef = new WeakReference<>(original);

    // 去除强引用
    original = null;

    // 在下一次垃圾回收时，只被弱引用指向的对象就会被回收
    System·gc();// 提示JvM进行垃圾回收，但不保证立即发生

    // 尝试通过弱引用获取对象
    if (weakRef.get() != null) {
        System.out.println("对象还未被回收："+weakRef.get());
    } else {
        System.out.printin("对象已被垃圾回收");
    }
}
```

输出结果：

> 对象已被垃圾回收

因为弱引用是不管内存够不够，垃圾收集器工作时就会立即回收，所以示例中的对象立即被回收了。

## 74、怎么实现一个虚引用？

虚引用的实现类：

> java.lang.ref.ReferenceQueue

示例代码：

```java
public static void main(string[] args) throws Interruptedexception {
    //创建一个引用队列
    ReferenceQueue<object> referenceQueue = new ReferenceQueue<>();
    //创建一个对象
    object object = new object();
    //创建一个虚引用，来引用这个对象，并与引用队列关联
    PhantomReference<object> phantomReference = new PhantomReference<>(object, referenceQueue);
    //清除强引用，确保这个对象只被虚引用所引用
    object = null;
    //强制进行垃圾回收
    System.gc();
    //休眠几秒，等待垃圾回收器回收
    Thread.sleep(3000);
    //检查引用队列，看是否可以取出虚引用
    System.out.println("虚引l用是否存在："+ (referencequeue.poll() != null));
}
```

输出结果：

> 虚引用是否存在：true

这里的引用队列是必须的，当对象回收时会放入其中，它最大的作用是跟踪对象的回收。

## 75、一个类的静态块是否可能被加载多次？

不可能，只加载一次，**JVM 保证静态块只会执行一次**，静态块是在类加载过程的初始化阶段执行的，它用于初始化类变量和执行类级别的初始化代码。

一旦类被初始化，它的静态块就不会再次执行，**除非类被卸载并重新加载**，但在 Java 应用程序运行期间，类的卸载和重新加载很少会用到。

示例代码：

```java
public class Test {
    static {
        System.out.println("静态块执行");
    }
    public static void main(string[] args) {
        //静态块在此之前已经执行了，且仅执行一次
    }
}
```

在上面的示例中，无论你创建多少次`Test`的实例，或者调用多少次`Test`的静态方法，静态块中的代码只在类`Test`第一次被加载到 JVM 时执行一次。

## 76、可以自定义一个 java.lang.String 吗？

可以自定义一个，不会报错，但它也不会被编译和加载。

因为 Java.lang.String 它在 java/lib 目录下，所以当应用类加载器去 classpath 加载时会去委托父类加载器,这时最顶层类加载器会发现自己之前已经加载过，所以这次不再加载，所以自定义的这个 java.lang.String 不能被类加载器加载并使用。

原理可以看面试题：JVM 双亲委派模型。

## 77、什么是伪共享？有什么解决方案？

##### 什么是伪共享

伪共享是多线程程序中的一种性能问题，发生在多个线程访问并更新相互独立的变量时，而这些变量恰好位于同一个 CPU 缓存行中。

现代 CPU 为了提高内存访问速度，不是直接从主内存中逐字节读取数据，而是以块（缓存行，一般为 64 字节）的形式加载数据到 CPU 缓存中。当多个线程修改同一个缓存行中的不同变量时，即使这些变量彼此独立，每个线程的修改也会使得整个缓存行在多个 CPU 核心间无效，导致频繁的缓存同步，从而降低了程序的执行效率。

> **伪共享的典型场景：**
>
> 假设有两个线程，线程 A 和线程 B，它们分别更新两个独立的变量，这两个变量恰好位于同一个缓存行中。
>
> 线程 A 更新变量时，会将包含该变量的缓存行加载到它所在 CPU 核心的缓存中。
>
> 当线程 B 更新另一个变量时，由于这两个变量位于同一个缓存行，线程 B 的操作会导致线程 A 的缓存行失效，即使它们操作的是不同的变量。
>
> **这种无谓的缓存失效和同步被称为伪共享。**

##### 解决方案

Java 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：`@sun.misc.Contended`。

加上这个注解的类会自动补齐缓存行：

```java
@sun.misc.Contended
public final static class Volatilelong {
    public volatile long value = 0L;
    //public Long p1, p2, p3, p4, p5, p6;
}
```

需要注意的是，此注解默认是无效的，需要在 VM 启动时设置-XX:-RestrictContended 才会生效。

## 78、Objectobj=newObject）占用几个字节？

在 Java 中，**无论是 32 位还是 64 位 JVM，对象头都需要按 8 宇节对齐**。

此外，**Java 虚拟机还会将整个对象的大小调整为 8 字节的倍数**，这可能包括在对象末尾添加填充字节（Padding），这种填充确保了对象数组中的每个元素都保持适当的对齐，从而使得 JVM 能够有效地访问这些对象。

以 64 位操作系统为例。

##### 开启指针压缩：

> markword 8 字节 + classpointer 4 字节 + Padding 4 字节 = 16 字节

##### 未开启指针压缩：

> markword 8 字节 + classpointer 8 字节 +Padding 0 字节 = 16 字节

## 79、为什么一个对象的字节大小为 8 的整数倍？

一个对象在 Java 中占用的内存大小为 8 的整数倍，这样做的目的是因为**内存对齐**的要求，为了使字节数据对齐，**以空间为代价进行更快地内存访问，从而提升运行效率**。

内存对齐是计算机系统为了提高内存访问速度而采用的一种优化策略，这种策略不仅适用于 Java，还适用于许多其他编程语言和系统。如果字节数据未对齐，处理器还需要在内存加载后进行一些调整才能访问。比如在 64 位 JVM 上, 一个空的`object`实例的对象头占用 12 字节（开启了指针压缩），为了满足 8 字节对齐的要求，VM 会在对象末尾添加 4 字节的填充，使得整个对象的大小成为 16 字节。

## 80、对象不再使用时，需要赋值为 null 吗？

##### 一般情况下是没必要手动赋值为 null，垃圾回收器会自动处理：

##### 1、局部变量

在方法执行完毕后，这个局部变量的作用域就结束了。此时，如果没有其他引用指向这个对象，它就会自动变成垃圾回收的候选对象。

##### 2、自动垃圾回收

Java 的垃圾回收机制可以检测到哪些对象不再被引用，并自动回收这些对象占用的内存。所以，在许多情况下，**不需要显式地将对象设置为`null`来触发垃圾回收。**

---

##### 可能需要赋值为 null 的情况（不建议！）

##### 1、长生命周期的对象持有短生命周期的对象引用

如果一个长生命周期的对象持有对短生命周期对象的引用，那么即使这些短生命周期的对象不再需要，它们也不会被垃圾回收，因为仍然存在对它们的引用。在这种情况下，如果确定某个短生命周期的引用不再需要，将其赋值为`null`可以帮助垃圾回收器回收这些不再使用的对象。

##### 2、内存敏感的大对象

对于占用大量内存的对象，如果你知道它们不再被需要，将它们赋值为`null`可以更快地释放内存，尤其是在内存敏感的应用中。

---

总之，在大多数情况下，应该让 Java 的垃圾回收机制来管理内存，只有在确实需要时才考虑将对象显式设置为`null`，频繁地将对象设置为勺`null`还会增加阅读和维护成本。

## 81、如何实现对象克隆？

可以有以下两种方法：

1、实现 Java 中的 Cloneable 接口，然后重写其 clone(方法。

```java
public class Person implements Cloneable {
    private string name;
    private int age;

    public Person(string name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge(){
        return age;
    }

    @override
    public Person clone() throws CloneNotsupportedException {
        return (Person) super.clone();
    }
}

public class Test {
    public static void main(string[] args) throws CloneNotsupportedException {
        Person person1 = new Person("张三", 20);
        Person person2 = personl.clone();
        //faLse，克隆出的对象和原始对象不是同一个对象
        System.out.println(personl == person2);
    }
}
```

2、实现序列化接口，先序列化对象，再反序列化对象。

> 具体见 IO 相关面试题。

## 82、对象克隆浅拷贝和深拷贝的区别？

##### 浅拷贝

---

拷贝对象时仅仅**只拷贝对象本身和基本类型变量**，而不拷贝引用类型变量（拷贝的只是对象的引用，还是同一个对象）。

示例代码：

```java
@Data
public class ShallowCopyTest implements Cloneable {
    private string name = "浅拷贝";
    private int[] data;

    public shallowcopyTest(int[] data) {
        this.data = data;
    }
    @overrideprotected object clone() throws CloneNotsupportedException {
        //默认行为是浅拷贝
        return super.clone();
    }
}
```

##### 深拷贝

---

拷贝对象时**不仅拷贝对象本身、还有全部变量**（包括引用类型变量，拷贝后是不同的对象）

示例代码：

```java
@Data
public class DeepcopyTest implements Cloneable {
    private String name ="深拷贝";
    private int[] data;
    public DeepcopyTest(int[] data) {
        this.data = data;
    }
    @Override
    protected object clone() throws CloneNotsupportedException {
        DeepcopyTest copy = (DeepcopyTest) super.clone();

        //复制数组，实现深拷贝
        copy.data = this.data.clone();
        return copy;
    }
}
```

##### 测试一下

---

```java
public static void main(string[] args) throws CloneNotsupportedException {
    //测试浅拷贝
    int[] data1 = {1, 2, 3};
    ShallowCopyTest shallowCopyTestl = new ShallowcopyTest(data1);
    ShallowCopyTest shallowCopyTest2 = (ShallowCopyTest) shallowCopyTest1.clone();
    shallowCopyTest1.getData()[2] = 222;
    System.out.println("shallowcopyTest1 is " + shallowcopyTest1);
    System.out.println("shallowcopyTest2 is " + shallowcopyTest2);
    //测试浅拷贝
    int[] data2 = {1, 2, 3};
    DeepCopyTest deepCopyTest1 = new DeepCopyTest(data2);
    DeepcopyTest deepcopyTest2 = (DeepCopyTest) deepCopyTest1.clone();
    deepcopyTest1.getData()[2] = 666;
    System.out.println("deepcopyTest1 is " + deepcopyTest1);
    System.out.println("deepcopyTest2 is " + deepcopyTest2);
}
```

输出结果：

> shallowCopyTest1 is ShallowCopyTest(name=浅拷贝, data=[1, 2, 222])
>
> shallowCopyTest2 is ShallowCopyTest(name=浅拷贝, data=[1, 2, 222])
>
> deepCopyTest1 is DeepCopyTest(name=深拷贝, data=[1, 2, 666])
>
> deepCopyTest2 is DeepCopyTest(name=深拷贝, data=[1, 2, 3])

浅拷贝默认只拷贝了基本数据类型，当改变某个对象数组的数据时，因为数组是引用类型，所以，所有对象的数组内容都一起发生变化。

深拷贝不但默认拷贝了基本数据类型，还手动复制了数组，相当于每个对象拥有了不同的数组实例，当改变其中某个对象数组的数据时，只有该对象数组受影响。其他对象保持独立，并不受影响。

## 83、什么是宏变量和宏替换？

```java
public static void main(string[] args) {
    String hw = "hello world";
    String hello = "hello";
    final string finalworld2 = "hello";
    final string finalworld3 = hello;
    final string finalworld4 = "he" + "llo";

    String hw1 = hello + " world";
    string hw2 = finalworld2 + " world";
    String hw3 = finalworld3 + " world";
    String hw4 = finalworld4 + " world";
    System.out.println(hw == hw1);
    System.out.println(hw == hw2);
    System.out.println(hw == hw3);
    System.out.println(hw == hw4);
}
```

程序输出：

> false
>
> true
>
> false
>
> true

同样是字符串 “hello"，为什么用 final 定义的，且个进行== 操作却是 true 有一个是 false，而没用 final 的却是 false？

##### 首先来理解下宏变量：

Java 中，一个用 final 定义的变量，不管它是类型的变量，只要用 final 定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个 final 变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。

如：

```java
final string a = "hello";
final string b = a;
final string c = getHello();
```

a 在编译期间就能确定下来，而 b、c 不行，所以 a 是宏变量，b、c 不是。

所以，再回到上面的程序，finalWorld2 和 finalWorld4 是 final 定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让 finalWorld2 和 finalWorld4 指向字符串池中缓存的字符串“hello world"，所以它们就是同一个对象。

## 84、什么是逃逸分析？

##### 什么是逃逸分析？

---

关于 Java 逃逸分析的定义:逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：

- 启逃逸分析：-XX:+DoEscapeAnalysis
- 闭逃逸分析：-XX:-DoEscapeAnalysis
- 示分析结果：-XX:+PrintEscapeAnalysis

逃逸分析技术在 Java SE6u23+开始支持，并默认设置为启用状态，可以不用额外加这个参数。

##### 逃逸分析算法

---

Java Hotspot 编译器实现下面论文中描述的逃逸算法：

> [Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,
>
> ​ Vugranam c. Sreedhar, Sam Midkiff,
>
> ​ "Escape Analysis for Java", Procedings of ACM SIGPLAN
>
> ​ OPSLA Conference, November 1, 1999

根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文**《Escape Analysis for Java》**中描述的算法进行逃逸分析的。

该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。

由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。

##### 对象逃逸状态

---

我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。

##### 1、全局逃逸（GlobalEscape)

即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

- 对象是一个静态变量
- 对象是一个已经发生逃逸的对象
- 对象作为当前方法的返回值

##### 2、参数逃逸(ArgEscape)

即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。

##### 3、没有逃逸

即方法中的对象没有发生逃逸。

##### 逃逸分析优化

---

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。

##### 1、锁消除

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。

例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

锁消除的 JVM 参数如下：

- 开启锁消除：-XX:+EliminateLocks
- 关闭锁消除：-XX:-EliminateLocks

锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

##### 2、标量替换

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。

对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下:

- 开启标量替换：-XX:+EliminateAllocations
- 关闭标量替换：-XX:-EliminateAllocations
- 显示标量替换详情：-XX:+PrintEliminateAllocations

标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

##### 3、栈上分配

当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。

#### 总结

逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。

我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。

简单举一个例子吧，如：

```java
return sb;
```

可以改为：

```java
return sb.toString();
```

这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。

## 85、native 关键字有什么用？

Java 中的 native 关键字用来修饰方法：

![](/images/进阶/85.jpg)

native 关键字在 Java 中用于声明一个方法是本地方法，即这个方法的实现不是用 Java 编写的，而是用其他编程语言（比如 C 或 C++）实现的。

因为 Java 不能直接访问操作系统及硬件底层的，需要通过 native 关键字来实现对底层的控制，这就需要更底层的语言的支持了，这个就是 native 的作用了。

比如你现在要使用某个底层的功能，但 Java 不支持，这时候就可以定义一个 native 方法，用 C 语言去实现了。

## 86、native 能和 abstract 一起使用吗？

不能，**native 不能和 abstract 一起使用**，因为 native 方法在底层是有实现的，而 abstract 就是一个抽象（并没有实现），所以两者冲突，不能一起使用。

如果将`native`和`abstract`起使用将导致编译错误：

```java
public abstract class Test {
    //下面的声明会导致编译错误
    public native abstract void test();
}
```

## 87、怎么实现一个 native 方法？

##### 1、写一个自定义的 native 方法然后编译

```java
public class Test {
    //声明 native 方法
    public native void helloNative();
    //加载包含native方法实现的本地库
    static {
        System.loadLibrary("hello");
    }
    public static void main(string[] args) {
        new Test().helloNative();
    }
}
```

在 Java 中使用`System.loadLibrary()`方法主动加载该动态链接库文件，这个自定义的 native 方法就可以在 Java 中被访问了。

2、用 javah 生成一个.h 文件

使用`javac`编译 Java 类，然后使用`javah`来生成包含本地方法声明的 C/C++头文件，这个头文件将作为编写本地代码的基础。

> 输译 Java 类
>
> javac Test.java
>
> 生成头文件
>
> javah -jni Test

##### 3、编写本地代码

写一个.cpp 文件实现 native 导出方法，需要包含上面的.h 文件，注意其中又包含了 JDK 带的 jnih 文件，最后将该.cpp 文件编译成动态链接库文件。

## 88、Unsafe 类有什么用？

Unsafe 类，即：**sun.misc.Unsafe**，它是 CAS 的核心操作类，其内部方法操作可像 C 语言中的指针一样直接操作内存数据。

```java
public final class Unsafe fstatic {
    static {
    Reflection.registerMethodsToFilter(Unsafe.class, Set.of("getUnsafe"));
    }
    private Unsafe() {}
    ...
}
```

Unsafe 提供了一些底层、不安全的操作，这些操作是由本地语言（如 C/C++）实现的，包括直接内存访问、线程调度、同步机制等，所以`Unsafe`类功能非常强大，但同时也非常危险，因为使用不当能会导致 JVM 崩溃。

所以，Unsafe 是不安全的，使用 Unsafe 类会加大出错的几率，所以官方是不建议使用的。

另外，Unsafe 类也是 final +私有构造的，不允许继承+外部实例化，所有方法也都是 native 的。

## 89、怎么查看一个 Java 类的字节码？

在我们工作、学习、以及研究 JVM 过程当中，不可避免的要查看 Java 字节码，通过查看字节码可以了解一个类的编译结果，也能通过编译器层面来分析一个类的性能。

字节码文件是不能直接打开的，下面教大家几种简单的方法如何查看 Java 字节码。

##### 1、使用 javap 命令查看字节码

命令格式如下:

> javap -c xxx.class

JDK 提供的了，不解释，来，演示操作一把：

> $ javap -c Test.class
>
> Compiled from "Test.java"
>
> public class com.test.Test {
>
> ​ public com.test.Test();
>
> ​ Code:
>
> ​ 0: aload_0
>
> ​ 1: invokespecial #8 // Method java/Lang/object."<init>":()v
>
> ​ 4: return
>
> ​ public static void main(java.lang.String[]);
>
> ​ Code:
>
> ​ 0: return
>
> }

如上所示，可以看到 Test 类的的字节码。

2、Intellij IDEA 中查看字节码

Intellij IDEA 直接集成了一个工具菜单，可以直接查看字节码，打开`ByteCode`插件窗口方法如下：

> View -> Show bytecode

![](/images/进阶/89_1.jpg)

![](/images/进阶/89_2.jpg)

如图所示，可以看到 String 类的的字节码。

是不是很方便？

如果看不到这个菜单，那可能你当前的类没有编译，需要你编译一下。

不会用 Intellj IDEA 的可以关注公众号：Java 技术栈，在后台回复：IDEA，可以获取栈长整理的历史教程，都是无废话干货。

想当初从 Eclipse 转 IDEA 数次都失败，现在早习惯了，说实话写代码是真智能，基友搭配，效率翻倍。

##### 3、Eclipse 中查看字节码

在 Eclipse 中查看字节码稍显麻烦，需要安装插件，并打开插件窗口，安装和使用方式如下：

![](/images/进阶/89_3.jpg)

**Name**: bytecode

**Location**: http://andrei.gmxhome.de/eclipse

安装完后需要重启 Eclipse 才能生效。

Eclipse 打开`ByteCode`插件窗口:

> Window-> Show View -> Other -> Java -> Bytecode

![](/images/进阶/89_4.jpg)

如图所示，可以看到 String 类的的字节码。

## 90、StringJoiner 有什么用?

你只会用 StringBuilder/ StringBuffer 拼接字符串？

那你就 OUT 了！！

如果需要拼接分隔符的字符串，建议使用 Java 8 中的这款拼接神器：StringJoiner，你值得拥有。

##### StringJoiner 基本使用

---

字面上理解就是用来拼接字符串的，一般需要分隔符进行拼接，如：

> hello, guys, Java 面试题

这种三段式由"”分隔的字符串，在 Java 8 之前要使用 StringBuilder/ StringBuffer 进行拼接，如：

```java
tringBuilder sb = new StringBuilder();
sb.append("hello");
sb.append(",");
sb.append("guys");
sb.append(",");
sb.append("Java面试题");
String str = sb.tostring();
```

都是相同的分隔符逗号，这样拼接显然过于傻瓜式，如果要拼接的字符串非常多，代码会十分难看，写完感觉要崩溃。

然而 Java 8 之后有了 StringJoiner，这件事件就变得更简单，分隔符这种全部一次性交给 StringJoiner 即可。

##### StringJoiner 基本使用示例：

```java
 public static void main(String[] args) {
     StringJoiner stringJoiner = new StringJoiner(",");
     stringJoiner.add("hello");
     stringJoiner.add("guys");
     stringJoiner.add("Java面试题");
     System.out.println(stringJoiner.toString());
 }
```

输出：

> hello,guys,Java 面试题

可以看到，这样写十分的干净清爽，也省去了许多没有必要的分隔符拼接操作，代码更优雅、只是可读性没 SB 直接拼接那么直观。

##### StringJoiner 就这么简单？

No!!!

StringJoiner 还有其他几种用法，下面的篇幅栈长会带大家解读一下。

##### StringJoiner 详细介绍

---

StringJoiner 的类结构图：

![](/images/进阶/90_1.jpg)

它的父类就是 Object，这些成员变量和方法都有什么用呢？

##### 成员变量：

- prefix：拼接后的字符串前缀
- delimiter：拼接时的字符串分隔符
- suffix：拼接后的字符串后缀
- value：拼接后的值
- emptyValue：空值的情况，value 为 null 时返回

##### 构造方法：

![](/images/进阶/90_2.jpg)

提供了两个构造方法，一个必须带分隔符，另一个必须带分隔符、前缀、后缀，可以看了`emptyValue`默认为前缀+后缀组成。

##### 公开方法：

- etEmptyValue：设置空值
- toString：转换成 String
- add：添加字符串
- erge：从另一个 StringJoiner 合并
- length：长度（包括前缀后缀）

##### 流式 API

---

我们重点看下 add 方法源码：

![](/images/进阶/90_3.jpg)

![](/images/进阶/90_4.jpg)

可以看到内部其实就是用的 StringBuilder 进行封装的，首次创建会先拼接前缀，后续先添加分隔符，再添加字符串。

其实 String 底层也是用的 StringBuilder，具体可以关注公众号 Java 技术栈在 Java 核心技术系列专栏中进行阅读。

另外一点，add 方法就是返回 StringJoiner 本身，所以可以像 StringBuilder/ StringBuffer 一样进行流式处理。

如上面的示例一行代码搞定：

```java
 public static void main(String[] args) {
     StringJoiner stringJoiner = new StringJoiner(",").add("hello").add("guys").add("Java面试题");
     System.out.println(stringJoiner.toString());
 }
```

##### 前后缀拼接

---

在示例中需要指定前后缀：

```java
public static void main(String[] args) {
    StringJoiner stringJoiner = new StringJoiner(",", "[", "]");
    stringJoiner.add("hello");
    stringJoiner.add("guys");
    stringJoiner.add("Java面试题");
    System.out.println(stringJoiner.toString());
}
```

输出：

> [hello,guys,Java 面试题]

如上所示，前后都带中括号进行了包装。

#### 空值处理

---

没有拼接任何字符串的几个空值处理场景。

##### 输出空白字符串：

```java
public static void main(String[] args) {
    StringJoiner stringJoiner = new StringJoiner(",");
    System.out.println(stringJoiner.toString());
}
```

##### 输出前后缀：

```java
public static void main(String[] args) {
    StringJoiner stringJoiner = new StringJoiner(",", "[", "]");
}
```

##### 输出：

> []

##### 输出指定字符串：

通过`setEmptyValue`进行设置。

```java
public static void main(String[] args) {
    StringJoiner stringJoiner = new StringJoiner(",", "[", "]");
    stringJoiner.setEmptyValue("void");
    System.out.println(stringJoiner.toString());
}
```

输出：

> void

##### String.join()

StringjoinO 这是针对 StringJoiner 又封装了一层的 APl，同样出自 Java 8，可以传入动态参数或者迭代器。

- ava.lang.String#join(java.lang.CharSequence, java.lang.CharSequence..)
- ava.lang.String#join(java.lang.CharSequence, java.lang.lterable<? extends java.lang.CharSequence>)

源码如下：

![](/images/进阶/90_5.jpg)

看源码，这两个方法只能进行简单的拼接操作，不能添加前后缀、空值设置处理等。

来个示例：

```java
ublic static void main(String[] args) {
    String str = String.join(","，"hello"，"guys"，"Java面试题");
    System.out.println(str);
}
```

可以看到，简单处理这样使用更简便。

##### 总结

---

今天介绍了 StringJoiner、StringBuilder、String.join( 之间的关系及使用。在使用拼间多个相同的分隔符时,使用 StringJoiner，简单处理使用 Stringjoin()也能完成。

针对不同的场景使用不同的 APl，这才是最佳最优雅的处理方式，不要只会使用 StringBuilder!

## 91、Java8 都新增了哪些新特性?

##### Java8 中添加的新特性，比如：

- Lambda 表达式
- stream 流
- 函数式接口
- 接口默认方法和静态方法
- Optional 类
- 重复注解
- ...

这个在面试库都能找到相应的面试知识点，还有一些新特性这里也一并讲下。

##### BASE64

---

base64 编码解码已经被加入到了 jdk8 中了。

```java
import java.nio.charset.Standardcharsets;
import java.util.Base64;
public class Base64Test {
    public static void main(String[] args) {
        String text = "hello javastack";
        String encoded = Base64.getEncoder() 								.encodeToString(text.getBytes(StandardCharsets.UTF_8));
        System.out.println(encoded);
        String decoded = new String(Base64.getDecoder().decode(encoded), 		Standardcharsets.UTF_8);
        System.out.println(decoded);
    }
}
```

##### Date/Time API(JSR 310)

新的时间、日期。

```java
Clock clock = Clock.systemUTc();
System.out.println(clock.instant());
System.out.println(clock.millis());
```

输出：

> 2017-09-06T07:26:18.541Z
>
> 1504682778593

可以代替`System.currentTimeMillis()`方法。

另外，可以看下 LocalDate、LocalTime、LocalDateTime、Duration 的用法。

##### Nashorn JavaScript 引擎

---

可以运行 js 代码的引擎。

```java
ScriptEngineManager manager - new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JavaScript");

System.out.println(engine.getclass() ·getName());
System.out.println("Result:" + engine.eval("function f() { return 10; J; f() * 24;"));
```

输出：

> jdk.nashorn.api.scripting.NashornScriptEngine
>
> Result:240.0

##### JVM 内存取消永久代

---

JDK8 使用了 Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize 和-XX:MaxMetaspaceSize 代替原来的-XX:PermSize 和-XX:MaxPermSize。

还有一些别的新特性，个人觉得某些新特性用处不是很大。

## 92、Lambda 表达式是什么?

Lambda 表达式是 Java 8 引 l 入的一个重要特性，它提供了一种简洁的方式来表示可传递的匿名方法（或函数）。

Lambda 表达式主要用于编写简洁的代码块，尤其是在需要使用函数式接口的地方，如在集合的操作或者线程运行时。一个函数式接口是只有一个抽象方法的接口，这使得 Lambda 表达式与之非常契合。

##### 一行执行语句的写法：

> (parameters) -> expression

如果有多行执行语句，可以加上{}

> (parameters) -> { statements; }

如：

```java
public int add(int x, int y) {
    return x + y;
}
```

转换成 Lambda 表达式有以下几种写法：

```java
//指定参数类型及return
(int x,int y)-> { return x + y;}
//指定参数类型，，不指定return
(int x,int y)-> x + y;
//不指定参数类型和return，编译器会自动推断
(x，y)-> x + y
```

## 93、Lambda 表达式的用途有哪些？

##### 1、只有一个抽象方法的函数式接口

Lambda 表达式的目标类型是函数式接口，下面拿创建线程来举例，用 Lambda 表达式可以有以下几种写法。

```java
public static void main(String[] args) {
    new Thread(new Runnable() {
        @overridepublic void run(){
            System.out.println("t1");
        }
        }).start();
    Runnable runnable = () -> System.out.println("t2");
    new Thread(runnable).start();
    new Thread(() -> System.out.println("t3")).start();
    new Thread(() -> run("t4")).start();
    new Thread(()->{
        String str = "t5";
        System.out.println(str);
    }).start();
    private static void run(String str) {
        System.out.println(str);
    }
}
```

最后输出：

> t1
>
> t2
>
> t3
>
> t4
>
> t5

##### 2、集合批量操作

下面打印 list 集合的两种写法是等价的。

```java
ist<String> list = Arrays.asList("a","b","c");
for(String str : list){
    System.out.println(str);
    list.forEach((e) -> System.out.println(e));
}
```

##### 3、流操作

下面是流查询 list 集合中等于"a"的数量。

```java
list.stream().filter((e) -> "a".equals(e)).count();
```

等等。

## 94、写一个 Lambda 表达式的使用示例

##### 示例 1

可以写一个创建简单的线程示例：

```java
public static void main(String[] args) {
    //使用Lambda表达式创建
    RunnabLeRunnable task=（）->System.out.println("这是通过Lambda 表达式创建的线程"）;
    Thread thread = new Thread(task);
    thread.start();
}
```

或者直接这样写：

```java
public static void main(String[] args) {
    //使用Lambda 表达式创建
    RunnabLeThread thread= new Thread(（）-> System.out.println("这是通过 Lambda 表达式创建的线程"));
    thread.start();
}
```

##### 示例 2

假设我们有一个字符串列表，我们想要按照字符串的长度进行排序。

```java
public static void main(String[] args) {
    //创建一个字符串列表
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dave");
    //使用Lambda表达式和CoLLections.sort方法对列表进行排序
    //这里的Lambda 表达式（s1,s2）->s1.Length(）－s2.Length(）实现了 Comparator 接口的 compare 方法
    Collections.sort(names, (s1, s2) -> s1.length() - s2.length());
    //打印排序后的列表
    System.out.println(names);
}
```

输出结果：

> [Bob, Dave, Alice, Charlie]

## 95、Optional 类有什么用?

##### Optional 是什么

`Optional`是 Java 8 引 l 入的一个新特性类，其位于`java.util`包中，主要目的是提供一种更优雅的方式来处理可能为`null`的情况，从而减少空指针异常的风险。

在 Java 8 之前，一般通过显式判断 `null` 来防止空指针，Optional 类通过封装可能为 null 的值提供了一种更好的解决方案。

##### Optional 常用方法

---

##### of

```java
public static <T> Optional<T> of(T value) {
    return new Optional<>(value);
}
```

为 value 创建一个 Optional 对象，如果 value 为空则 会报出 NullPointerException 异常。

##### ofNullable

```java
public static <T> Optional<T> ofNullable(T value) {
    return value == null ? empty() : of(value);
}
```

为 value 创建一个 Optional 对象，但可以允许 value 为 null 值。

##### isPresent

```java
public boolean isPresent() {
    return value != null;
}
```

判断当前 value 是否为 null 如果不为 null 则返回 true， 否则 false。

##### ifPresent

如果不为 null 值就执行函数式接口的内容。

```java
public void ifPresent(Consumer<? super T> consumer) {
    if (value != null)
        consumer.accept(value);
}
```

##### get

```java
public T get() {
    if (value == null) {
        throw new NoSuchElementException("No value present");
    }
    return value;
}
```

返回当前的值，如果为空则报异常。

##### orElse

返回当前值，如果为 null 则返回 other。

```java
public I orElse(T other) {
    return value != null ? value : other;
}
```

##### orElseGet

orElseGet 和 orElse 类似，只是 orElseGet 支持函数式接口来生成 other 值。

```java
public T orElseGet(Supplier<? extends T> other) {
    return value != null ? value : other.get();
}
```

##### orElseThrow

如果有值则返回，没有则用函数式接口抛出生成的异常。

```java
public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {
    if (value != null) {
        return value;
    } else {
        throw exceptionSupplier.get();
    }
}
```

##### 示例代码

User 类：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Stringgname;
    private int age;
}
```

测试类：

```java
public class Test {

    public static void main(String[] args) {
        testof();
        testNullable();
    }
    private static void testof() {
        try {
            User user1 = new User();
            Optional<User> useroptional1 = Optional.of(user1);
            if (useroptional1.isPresent()) {
                System.out.println("user is not null");
            }

            User user2 = null;
            Optional<User> userOptional2 = Optional.of(user2); //NuLLPointerException
            if (user0ptional2.isPresent()) {
                System.out.println("user is not null");
            }
         }catch (Exception e) {
            e.printStackTrace();
         }
         System.out.println();
    }
    private static void testNullable() {
        User user = null;
        User john = new User("john", 18);
        User dick = new User("dick", 12);
        System.out.println(Optional.ofNullable(user).orElse(john));
        System.out.println(Optional.ofNullable(john) -get());
        System.out.println(Optional.ofNullable(dick) .orElse(john));
        System.out.println(Optional.ofNullable(user).orElseGet(() -> john));
        System.out.println();
    }
}
```

`optional`在 JDK 8 中有大量使用，比如像 Stream 流中，在 Spring 中也可以用 Optional 来代替`@Autowired(required = false)`的情况。

## 96、Stream（流）是什么?

Stream 流是 Java 8 引 l 入的一个重要新特性，它提供了一种高效且易于使用的处理数据集合的方式。

Stream 流可以对数据集合执行复杂的操作，如**过滤、转换、聚合**等，Stream API 通过提供一系列的中间操作和终端操作，使得数据处理更加直观和声明式，极大地提升了编码效率和可读性。

**Stream 不存储数据**，它只是在原有数据结构（如集合）的基础上，提供了一系列的操作管道。**Stream 的遍历是一次性的**，一旦遍历过或被终端操作消费后，就不能再次使用。

以下举了流的一些常用的用法：

```java
public class StreamTest {
    public static void main(String[] args) {
        System.out.println("过滤－找出年纪大于18岁的人");
        List<User> list = initList();
        list.stream().filter((User user)) -> user.getAge() > 18.collect(Collectors.tolist()).forEach(System.out::println);
        System.out.println();

        System.out.println("最大值－找出最大年纪的人");
        list = initlist();
        Optional<User> max = list.stream().max((u1, u2) -> u1.getAge() - u2.getAge());
        System.out.println(max.get());
        System.out.println();

        System.out.println("映射-规纳－求所有人的年纪总和");
        list = initlist();
        Optional<Integer> reduce = list.stream().map(User::getAge).reduce(Integer::sum);
        System.out.println(reduce.get());
        System.out.println();

        System.out.println("分组-按年纪分组");
        list = initlist();
        Map<Integer, List<User>> userMap = list.stream().collect(Collectors.groupingBy(User::getAge));
        MapUtils.verbosePrint(System.out, null, userMap);
        System.out.println();

        System.out.println("创建-去重-统计");
        Stream<User> userstream = Stream.of(new User("u1", 1), new User("u2", 21), new User("u2", 21));
        System.out.println(userStream.distinct().count());
        System.out.println();
    }
    public staticList<User>initlist() {
        List<User>list =newArrayList<>();
        list.add(new User("oaby", 23));
        list.add(new User("tom", 11));
        list.add(newUser("john",16));
        list.add(neww User("jennis", 26));
        list.add(new User("tin", 26));
        list.add(new User("army", 26));
        list.add(new User("mack", 19));
        list.add(neww User("jobs", 65));
        list.add(new User("jordan", 23));
        return list;
    }
}
```

输出结果：

> 过滤－找出年纪大于 18 岁的人
>
> User [username=oaby, age=23]
>
> User [username=jennis, age=26]
>
> User [username=tin, age=26]
>
> User [username=army, age=26]
>
> User [username=mack, age=19]
>
> User [username=jobs, age=65]
>
> User [username=jordan, age=23]
>
> 最大值－找出最大年纪的人
>
> User [username=jobs, age=65]
>
> 映射-规纳－求所有人的年纪总和
>
> 235
>
> 分组－按年纪分组
>
> {
>
> ​ 16 = [User [username=john, age=16]]
>
> ​ 65 = [User [username=jobs, age=65]]
>
> ​ 19 = [User [username=mack, age=19]]
>
> ​ 23 = [User [username=oaby, age=23], User [username=jordan, age=23]]
>
> ​ 26 = [User [username=jennis, age=26], User [username=tin, age=26], User [username=army, age=26]]
>
> ​ 11 = [User [username=tom, age=11]]
>
> }
>
> 创建-去重－统计
>
> 2

可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。

## 97、Stream（流）分为哪几类？

流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。

```java
List<Integer> numbers = Arrays.aslist(1, 2, 3);
//顺序流
numbers.stream().forEach(n -> System.out.print(n));
//并行流
numbers.parallelstream().forEach(n -> System.out.print(n));
```

以上例子，顺序流总是输出`123`，而并行流则每次结果都不一定，并行流使用了 ForkJoinPool 分而治之，所以明白了 ForkJoinPool 原理的同学就知道并行流的真面目了。

## 98、Stream 中的 map 和 flatMap 方法的区别？

如图所示：

![](/images/进阶/98_1.jpg)

在 Java 8 Stream（流）接口中有 8 个特别有意思的方法，其实就是分为两大类：

- map
- flatMap

##### map

map 方法的作用：

> 对流中的每个元素进行转换

比如现在有一个 List<String>集合：

```java
private static List<String> LIST = Arrays.asList("https://", "slq1893", ".", "github", ".", "io");
```

我想让每个元素后面都加上“—"：

```java
private static void map() {
    List<String> maplist = LIST.stream().map(e -> e.concat("---")).collect(Collectors.tolist());
    mapList.forEach(System.out::print);
    System.out.println("\nmap list size:" + maplist.size());
    System.out.println();
}
```

（1）先把 List 转换为 Stream；

（2）调用 Stream.map 方法对 Stream 中的每个元素再封装操作一遍；

（3）把 Stream<Stream>转换为 List；

输出结果：

> map list=
>
> https://—slq1893—----github—.---io—
>
> map list size: 6

结果符合预期。

---

如果 List 中的元素都是整数型：

```java
private static List<String> NUMBERS_LIST = Arrays.asList("22", "19", "89", "90");
```

那么就可以 直接使用内置的 mapToXxx 方法，这里以 mapToLong 演示：

```java
private static void mapTolong() {
    System.out.println("=====map to long list====");
    List<Long> longList = NUMBERs_LIST.stream() .mapToLong(Long::valueOf) .boxed().collect(Collectors.toList());
    longList.forEach(System.out::println);
    System.out.println("map to long list size: " + longlist.size());
    System.out.println();
}
```

（1）先把 List 转换为 Stream;

（2）调用 Stream.mapToLong 方法把流转换为 LongStream 类型;

（3）调用 LongStream.boxed 方法收集为 Stream<Long>类型;

（4）把 Stream<Long>转换为 List;

输出结果:

> =map to long list=
>
> 22
>
> 19
>
> 89
>
> 90map to long list size: 4

当然这个使用 map 也能实现，但使用 mapToXxx 可以将原始流（Stream）转换为 XxxStream：

![](/images/进阶/98_2.jpg)

XxxStream 可以有更多基于整数型的功能，比如快速对元素进行汇总（sum）、求最大数（max）、最小数(min）等等，如果要涉及到元素计算，使用 mapToXxx 会更香。

如源码所示：

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
LongStream mapToLong(ToLongFunction<? super T> mapper);
```

map 和 mapToXxx 的返回类型是不一样的。

##### flatMap

---

flatMap 方法的作用：

> flat 是平铺的意思，flatMap 即对流中每个元素进行平铺后，形成多个流合在一起

比如现在有 3 个字符串数组：

```java
String[] arrl = {"https://", "slq1893", ".","github"， "."，""io"};
String[］arr2={"github"，":"，"Java面试题"};
String[] arr3 = {"作者"，":"，"SLQ1893"};
```

现在直接转换为 Stream：

```java
System.out.println("=====arrays list=====");
List<String[]> list = Stream.of(arr1, arr2, arr3).collect(collectors.tolist());
list.forEach(System.out::print);
System.out.println("\narrays list size: " + list.size());
System.out.println();
```

结果输出：

> arrays list=[Ljava.lang.String;@21b8d17c[Ljava.lang.String;@6433a2[Ljava.lang.String;@ 5910e440
>
> arrays list size: 3

没错，是 3 个数组元素。

再来看使用 flatMap 方法的效果：

```java
System.out.printin("=---flatmap list==--=");
List<String> mapList = list.stream().flatMap(Arrays::stream) .collect(Collectors.tolist());
mapList.forEach(System.out: :print);
System.out.println("\nflatmap list size: " + maplist.size()); System.out.println();
```

结果输出：

> flatmap list=
>
> https://slq1893.github.io网站:Java面试题:SLQ1893
>
> flatmap list size: 12

元素大小变成了 12，把 3 个数组流中的元素全部平铺合到一个流中了，然后流中总共为 12 个元素。

这里我用的数组类型，如果是多个 List<String>类型也是可以的，其底层也是数组，只要能将元素转换成流都是可以的。

##### 总结

---

map 是对流元素进行转换，flatMap 是对流中的元素（数组）进行平铺后合并，即对流中的每个元素平铺后又转换成为了 Stream 流。

来看下两个方法的源码：

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
```

其参数是不一样的，map 前、后的每个元素都是 R 类型，flatMap 前、后的每个元素由原来的 R 类型都变成了 Stream 类型。

##### 再小小总结下：

> map 适用于对每个元素进行简单的转换，flatMap 适用于对数组流进行平铺后合并，两个方法的应用场景不一样。

## 99、Stream 中的 map、peek、foreach 方法的区别？

##### peek 和 map 有什么区别？

map 和 peek 都是 Stream 提供的流处理方法。

首先看 peek 的使用源码注释：

> This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline:

翻译：

> 这个方法主要用于支持 debug 调试，当你想看处于某个特定点的流元素时。

如：

```java
@Test
public void peekTest1() {
    Stream.of("one", "two", "three", "four").filter(e ->e.length() > 3)
        .peek(e -> System.out.println("Filtered value: " + e))
        .map(String: :toUpperCase)
        .peek(e -> System.out.println("Mapped value: " + e))
        .collect(collectors.tolist());
}
```

输出结果：

> Filtered value: threeMapped value: THREE Filtered value: fourMapped value: FOUR

先后输出 filter、map 之后的流元素，实际工作中如果想看某个过程的结果，可以派上用场。

##### 再来分别看下 map 和 peek 的方法参数：

![](/images/进阶/99_1.jpg)

![](/images/进阶/99_2.jpg)

可以看到，map 接收 Function 函数式接口参数（接收一个参数，返回一个参数），peek 接收 Consumer 函数式接口参数（接收一个参数，无返回）。

不理解的话来看下面的示例：

假如有以下 List:

```java
private List<String> languageList = new Arraylist<String>() {{
    add("java");
    add("python");
    add("c++");
    add("php");
    add("go");
}
```

peek 方法中的函数式接口参数不能有返回值：

![](/images/进阶/99_3.jpg)

意味着它不能像 map 一样处理流中的元素然后形成新流：

![](/images/进阶/99_4.jpg)

peek 不能修改流中的元素，只能对元素进行打印输出或者其他外部处理操作。

但流元素如果是引 l 用类型,peek 却可以达到 map 的效果：

```java
private List<User> userList = new Arraylist<User>() {{
    add(new User("张三"));
    add(new User("李四"));
    add(new User("王五"));
    add(new User("赵六"));
}}
@Test
public void peekTest3() {
    userList.stream()11.peek(user -> user.setName("peek: " + user.getName()))
        .forEach(System.out::println);
}
```

输出结果：

```java
SteamPeekTest.User(name=peek: 张三)
SteamPeekTest.User(name=peek: 李四)
SteamPeekTest.User(name=peek: 王五)
SteamPeekTest.User(name=peek: 赵六)
```

虽然不能有返回值形成新的流，但却可以修改引用类型字段的值。因为是引用类型，使用 peek 就没必要 set 之后还要进行 return 了。

```java
List<Menu> children = all.stream().filter(...).map(
    (m)->{m.setchildlist(getchildrens(m, all));
          return m;
         }
    ).collect(collectors.tolist());
```

修改为：

```java
List<Menu> children = all.stream().filter(...).peek(
    m -> m.setchildlist(getchildrens(m, all))
).collect(collectors.tolist());
```

是不是优雅多了？

##### peek 和 foreach 有什么区别？

---

如 foreach 的源码：

![](/images/进阶/99_5.jpg)

和 peek 一样也是接收 Consumer 参数，不同是 foreach 没有返回参数，意味着 foreach 会中断流操作，只能用来遍历，不能再进行后续的流处理。

---

根据文中的示例，大家应该都搞清楚了 map、peek、foreach 的区别和用法了，现在再来总结下：

- map：用于对流中的每个元素进行映射处理，然后再形成新的流；
- peek：用于 debug 调试流中间结果，不能形成新的流，但能修改引 l 用类型字段的值；
- foreach：用于遍历，会中断流操作;

## 100、怎么创建一个 Stream 流？

今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。

##### 1、Stream.of 可变参数

```java
Stream<String> stream1 = Stream.of("A", "B", "c"); System.out.println("stream1:" + stream1.collect(joining()));
```

程序输出：

> stream1:ABC

##### 2、Stream.of 数组

```java
String[] values = new String[]f"A", "B", "c"};
Stream<String> stream2 = Stream.of(values);
System.out.println("stream2:" + stream2.collect(joining()));
```

程序输出：

> stream2:ABC

看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。

```java
public static<T> Stream<T> of(T... values) {
    return Arrays.stream(values);
}
```

我们直接使用源码中的方式也是一样的。

##### 3、Arrays.stream

```java
String[] values = new String[]f"A", "B", "c"};
Stream<String> stream3 = Arrays.stream(values);
System.out.println("stream3:" + stream3.collect(joining()));
```

程序输出：

> stream3:ABC

##### 4、List

```java
ist<String> list = Arrays.asList("A", "B","C");
Stream<String> stream4 = list.stream();
System.out.println("stream4:" + stream4.collect(joining()));
```

程序输出：

> stream4:ABC

##### 5、Set

```java
Set<String> set = new Hashset<>(Arrays.asList("A", "B", "c"));
Stream<String> stream5 = set.stream();
System.out.println("stream5:" + stream5.collect(joining()));
```

程序输出：

> stream5:ABC

##### 6、 Map

```java
Map<String, String> map = new HashMap<>();
map.put("1", "A");
map.put("2", "B");
map.put("3", "C");
Stream<String> stream6 = map.values().stream();
System.out.println("stream6:" + stream6.collect(joining()));
```

程序输出：

> stream6:ABC

##### 7、 Stream.iterate

```java
Stream<String> stream7 = Stream.iterate("A", e -> String.value0f((char) (e.charAt(θ) + 1))).limit(3);
System.out.println("stream7:" + stream7.collect(joining()));
```

程序输出：

> stream7:ABC

8. ##### Pattern

```java
String value = "A B C";
Stream<String> stream8 = Pattern.compile("\\w").splitAsStream(value);
System.out.println("stream8:" + stream8.collect(joining()));
```

程序输出：

> stream8:ABC

##### 9、 Files.lines

```java
try {
    Stream<String> stream9 = Files.lines(Paths.get("d:/data.txt"));
    System.out.println("stream9:" + stream9.collect(joining()));
} catch (I0Exception e) {
    e.printStackTrace();
}
```

data.txt 文件内容如下：

> A
>
> B
>
> C

程序输出：

> stream9:ABC

##### 10、 Stream.generate

```java
Stream<String> stream10 = Stream.generate(() -> "A").limit(3); System.out.println("stream1e:" + stream10.collect(joining()));
```

程序输出：

> stream10:AAA

## 101、接口是否可以继承接口？

接口可以继承接口，而且支持多重继承，这样做可以实现接口的分层和组织，当一个接口继承了另一个接口时，它将继承父接口的所有抽象方法。

接口的继承使用 extends 关键字，示例代码如下：

```java
interfaceInterfaceA {
    void methodA();
}
 interface InterfaceB{
  void methodB();
}
interface CombinedInterface extends InterfaceA,InterfaceB {
  void combinedMethod();
}
```

在这个例子中，`CombinedInterface`同时继承了`InterfaceA`和`InterfaceB`，因此任何实现`CombinedInterface`的类都需要实现`methodA`、`methodB`以及`combinedMethod`这三个方法。我们再来看 JDK 中的实现：

```java
public interface Descriptor extends Serializable, Cloneable {
    ...
}
```

接口继承接口是 Java 接口多继承特性的一个重要方面，它为设计灵活且强大的 API 提供了基础。

## 102、接口里面可以写方法实现吗？

最近也面试一些 Java 程序员，不乏工作 4、5 年经验的，当我问他一些 Java 8 的新特性时大多却答不上来。

##### 比如下面这道题：

**R 哥**：接口里面可以写方法吗?

**小 A**：当然可以啊，默认就是抽象方法。

**R 哥**：那接口里面可以写实现方法吗？

**小 A**：不可以，所有方法必须是抽象的。

**R 哥**：你确定吗?

**小 A**：确定.

小 A 看起来对我的问题有点怀疑人生，心里肯定估摸着，我不会在给他埋了什么坑吧。然后他还是仔细再想了一下，最后还是斩钉截铁的告诉我：**接口里面只能写抽象方法，不能写实现方法。**

##### R 哥：接口里面是可以写实现方法的，Java8 开始就可以了，你用过 Java8 吗？

**小 A**：好吧，看来是我学艺不精，Java 8 有了解一点，比如那个 Lambda 表达式，但实际项目中也没怎么用。

通过和小 A 的交流，我也看到了许多开发者的问题，虽然开发版本用的是 Java 8，但实际用的还是 Java 8 之前的最基础的语法，对 Java 8 新增的特性一无所知。

## 103、接口默认方法和静态方法是什么？

Java8 开始接口里面是可以有方法实现的，可以在接口中添加默认方法和静态方法。

默认方法用`default`修饰，只能用在接口中静态方法用`static`修饰，这个我们不陌生了。并且接口中的默认方法、静态方法可以同时有多个。

在接口中写实现方法一点也不稀奇，像这样的用法，从 Java8 到 Java14 已是遍地开花，到处都可以看到接口默认方法和静态方法的身影。

比如我们来看下在 JDKAPI 中`java.util.Map`关于接口默认方法和静态方法的应用。

```java
public interface Map<K,V> {
    // 接口默认方法
    default boolean remove(object key, Object value) {
        Object curValue = get(key);
        if (!objects.equals(curValue, value) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }
    ...
    // 接口静态方法
    public static <K extends Comparable<? super K>, V> Comparateor<Map.Entity<K, V>> comparingByKey() {
    return (Comparator<Map.Entry<K，V>> & Serializable)
            (c1,c2)-> c1.getKey().compareTo(c2.getKey());
     }
     ....
}
```

## 104、接口为什么新增了默认方法和静态方法？

##### Java8 中的接口为什么新增了默认方法？

举一个很现实的例子：

我们的接口老早就写好了，后面因为各种业务问题，避免不了要修改接口。

在 Java 8 之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。

所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务，爽歪歪。

另外，接口默认方法可以被接口实现类重写。

---

##### Java8 中的接口为什么新增了静态方法？

接口静态方法和默认方法类似，只是接口静态方法不可以被接口实现类重写。

接口静态方法只可以直接通过静态方法所在的`接口名`.`静态方法名`来调用。

## 105、接口默认方法有哪些注意的问题？

因为接口默认方法可以被继承并重写，如果继承的多个接口都存在相同的默认方法，那就存在冲突问题。

下面我会列举 3 个冲突示例场景。

##### 冲突一

来看下面这段程序：

```java
interface People {
    default void eat(){
        System.out.println("人吃饭");
    }
}

interface Man {
    default void eat(){
        System.out.printin("男人吃饭");
    }
}

interface Boy extends Man, People {

}
```

Boy 同时继承了 People 和 Man，此时在 IDEA 编辑器中就会报错：

![](/images/进阶/105_1.jpg)

这就是接口多继承带来的冲突问题，Boy 不知道该继承谁的，这显然也是个问题，IDEA 也会提示，需要重写这个方法才能解决问题：

```java
interface Boy extends Man, People {
    @Override
    default void eat() {
        System.out.println("男孩吃饭");
    }
}
```

在方法里面还能直接调用指定父接口的默认方法，比如：

```java
interface Boy extends Man, People {
    @overridedefault void eat() {
        People.super.eat();
        Man.super.eat();
        System.out.println("男孩吃饭");
    }
}
```

再加个实现类测试一下：

```java
static class Student implements Boy {
    public static void main(string[] args) {
        Student student = new Student();student.eat();
        student.eat();
    }
}
```

输出：

> 人吃饭
>
> 男人吃饭
>
> 男孩吃饭

嗯，很强大！

##### 冲突二

我们再换一种写法，把 Man 继承 People，然后 Man 重写 People 中的默认方法。

![](/images/进阶/105_2.jpg)

此时，编辑器不报错了，而 People 的默认方法置灰了，提示没有被用到。

再运行一下上面的示例，输出：

> 男人吃饭

因为 Man 继承 People，Man 又重定了默认方法。很显然，这个时候，Boy 知道该继承谁的默认方法了。

##### 冲突三

在 Man 接口中新增一个方法：say，然后在 Boy 接口中新增一个默认方法：say。

![](/images/进阶/105_3.jpg)

这时候，Man 中的抽象方法居然被忽略了，IDEA 都提示说没用到，这显然是默认方法优先于抽象方法。

## 106、方法引用是什么？

##### 什么是方法引用

---

自 Java 8 引 l 入，方法引用是一种简化 lambda 表达式的写法，使你能够以更简洁的方式引用已存在的方法。方法引用可以指向静态方法、实例方法、构造函数以及特定类型的实例方法。

方法引 l 用是只需要使用方法的名字，而具体调用交给函数式接口，需要和 Lambda 表达式配合使用。

代码示例：

```java
List<string> list = Arrays.asList("a","b","c");
list.foreach(str -> System.out.print(str));
list.forEach(System.out::print);
```

上面两种写法是等价的。

##### 示例代码

---

往 User 类添加方法引用方法：

```java
public static User create(Supplier<User> supplier){
    return supplier.get();
}
public static void updateusername(User user){
    user.setusername(user.getusername() + " updated.");
    public void updateAge()fthis.setAge(this.getAge() + 10);
}
public void changeAge(User user){
    user.setAge(user.getAge() + 10);
}
```

方法引用测试：

```java
public static void main(string[] args) {
    List<User> list = initlist();
    //1、构造器方法引用
    User newuser = User.create(user::new);
    newUser.setAge(1);newUser.setusername("new");
    System.out.println(newuser) ;
    //2、类静态方法引用
    list.forEach(user::updateUsername);
    //3、类普通方法引用
    list.forEach(User::updateAge);
    //4、实例方法引用
    User user = new User();
    list.forEach(user::changeAge);
    list.forEach(System.out::println);
}
private static List<User> initlist() {
    List<User> list = new ArrayList<>();
    list.add(new User("oaby", 23));
    list.add(new user("tom", 11));
    list.add(new User("john", 16));
    list.add(new User("jennis", 26));
    list.add(new User("tin", 26));
    list.add(new User("army", 26));
    list.add(new User("mack", 19));
    list.add(new User("jobs", 65));
    list.add(new User("jordan", 23));
    return list;
}
```

输出结果：

> User [username=new, age=1]
>
> User [usernane=oaby updated., age=43]
>
> User [username=tom updated., age=31]
>
> User [username=john updated., age=36]
>
> User [username=jennis updated., age=46]
>
> User [username=tin updated., age=46]
>
> User [username=army updated., age=46]
>
> User [username=mack updated., age=39]
>
> User [username=jobs updated., age=85]
>
> User [username=jordan updated., age=43]

可以看出方法引 l 用都生效了，username 和 age 都相应更新了。

## 107、方法引用分为哪几类？

##### 1、构造器方法引用

格式：`Class::new`，调用默认构造器

##### 2、类静态方法引用

格式：`Class::static_method`

##### 3、类普通方法引用

格式：`Class::method`

##### 4、实例方法引用

格式：`instance::method`

## 108、函数式接口是什么？

##### 什么是函数式接口

---

Java 8 引 l 入了函数式接口（Functional Interface）的概念，函数式接口是只包含一个抽象方法的接口，它可以很优雅的配合 Lambda 表达式使用，使得实例化函数式接口变得更加简单和直观。

先来看看传统的创建线程是怎么写的

```java
Thread t1 = new Thread(new Runnable() {
    @overridepublic void run() {
        System.out.printin("t1");
    }
});
tl.start();
```

再来看看使用了函数式接口是怎么写的

```java
hread t2 = new Thread(() -> System.out.println("t2"));
t2.start()
```

Runnable 接口直接可以使用 Lambda 表达式来编写，这是因为 Runnable 接口是一个函数式接口，来看看 Runnable 的源码。

```java
@Functionalinterface
public interface Runnable {
    public abstract void run();
}
```

发现该接口加上了函数式接口的定义注解：`@FunctionalInterface`，表明该接口是一个函数式接口。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Functionalinterface {
}
```

在 JDK 8+中，除了 Runnbale 接口，还有像 Comparator、Callable 等接口都加上了该注解定义为函数式接口。

##### 函数式接口规范

---

1、@Functionallnterface 标识为一个函数式接口只能用在只有一个抽象方法的接口上。

2、接口中的静态方法、默认方法、覆盖了 Object 类的方法都不算抽象方法。

3、@Functionallnterface 注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。

##### 举例说明

---

正确的函数式接口。

```java
@Functionalinterface
public interface CalcInterface<N, V> {
    V operation(N nl, N n2);
}
```

加了几个符合函数式的方法也没事，编译器也不会报错。

```java
@Functionalinterfac
epublic interface Calcinterface<N, V> {
    V operation(N nl, N n2);
    public boolean equals(object object);
    public default void defaultMethod() {
    }
     public static void staticMethod() {
     }
}
```

这个没用@Functionallnterface 函数式接口，有两个抽象方法，不能用于 Lambda 表达式。

```java
public interface CalcInterface<N, V> {
    V operation(N nl, N n2);
    V operation2(N nl, N n2);
}
```

这个有两个抽象方法的用@Functionallinterface 注解的函数式接口编译会报错。

```java
@Functionalinterface
public interface Calcinterface<N, V> {
    V operation(N nl, N n2);
    V operation2(N n1, N n2);
}
```

这个没有一个抽象方法，编译报错。

```java
public interface CalcInterface<N, V> {

}
```

## 109、函数式接口分为哪几类？

Java 在`java.util.function`包中提供了一系列标准的函数式接口，这些接口可以分为以下几个类别。

##### 1、消费者（Consumer)

消费者接口表示接受单个输入参数并且不返回结果的操作，它的主要目的是对参数执行一些操作。

- `Consumer<T>`：接受一个输入参数，无返回值。
- `Biconsumer<T，U>`：接受两个输入参数，无返回值。

##### 2、供应者(Supplier)

供应者接口代表一个结果的供应源，不接受参数，返回一个结果。

- `Supplier<T>`：无参数，返回一个结果。

##### 3、函数(Function)

函数接口代表接受一个参数并产生结果的函数。

- `Function<T，R>`：接受一个输入参数，返回一个结果。
- `BiFunction<T，U，R>`：接受两个输入参数，返回一个结果。
- `Unaryoperator<T>`：接受一个参数，类型与结果类型相同。

- `BinaryOperator<T>`：接受两个相同类型的参数，返回一个同类型的结果。

#### 4、断言(Predicate)

断言接口代表一个参数的谓词（布尔值函数）。

- `Predicate<T>`：接受一个输入参数，返回一个布尔值结果。
- `BiPredicate<T，u>`：接受两个输入参数，返回一个布尔值结果。

##### 5、其他

除了上述主要类别外，java.util.function 包还包括了一些其他实用的函数式接口，如：

- `ToIntFunction<T>`、`ToLongFunction<T>`、`ToDoubleFunction<T>`：分别将对象转换为基本类型`int`、`long`和`double`。

- `IntFunction<R>`、`LongFunction<R>`、`DoubleFunction<R>`：接受一个基本类型的参数，返回泛型类型的结果。

---

##### 示例代码：

来演示几个 JDK 8 提供的几个内置的函数式接口，用在了许多 API 的地方，都可以拿来用，可以满足大部分应用。

```java
public static void main(string[] args) {
    //Consumer<T》－T作为输入，执行某种动作但没有返回值
    Consumer<string> con = (x) -> {
        system.out.println(x);
    }
    con.accept("hello world");

    //suppLier<T>－没有任何输入，返回T
    Supplier<string> supp = () -> {
        return "supplier";
    }
     System.out.println(supp.get());
    //Predicate<T>-T作为输入，返回的booLean值作为输出
    Predicate<string> pre = (x) -> {
        System.out.print(x);
        return x.startswith("op");
    }
    System.out.println(": " + pre.test("op, hello World"));

    //Function<T，R>-T作为输入，返回的R作为输出
    Function<string, String> function = (x) -> {
        System.out.print(x + ": ");
        return "Function";
    }
    System.out.println(function.apply("hello world"));

    //Binaryoperator<T》-两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用
    Binaryoperator<string> bina = (x, y) -> {
        System.out.print("x + " + y);
        return "Binaryoperator";
    }
    System.out.println("" + bina.apply("hello ", "world"));
}
```

输出结果：

> hello world
>
> Supplier
>
> op, hello World: true
>
> hello world: Function
>
> hello world BinaryOperator

## 110、编程实现一个自定义函数式接口，并运用该函数式接口

##### 1、自定义一个函数式接口

```java
@Functionalinterface
public interface CalcInterface<N, V> {
    V operation(N nl, N n2);
}
```

这里只有一个抽象方法，按规范@FunctionalInterface 注解可以不用写。

##### 2、新建一个引用函数式接口的类

```java
public static class Numberoperation<N extends Number, V extends Number> {
    private N nl;
    private N n2;

    public Numberoperation(N n1, N n2) {
        this.nl = n1;
        this.n2 = n2;
    }
    public V calc(calcInterface<N, V> ci) {
        V v = ci.operation(nl, n2);
        return V;
    }
}
```

##### 3、测试函数式接口

```java
public static void main(string[] args) {
    Numberoperation<Integer, Integer> np = new Numberoperation(13, 10);
    Calcinterface<Integer, Integer> addoperl = (n1, n2) -> nl + n2;
    Calcinterface<Integer, Integer> multioperl = (nl, n2) -> n1 * n2;
    System.out.println(np.calc(addoperl));
    System.out.println(np.calc(multioper1));
    System.out.printin(np.calc((n1, n2) -> n1 + n2));
    System.out.printin(np.calc((n1, n2) -> n1 * n2));
}
```

最后输出：

> 23
>
> 130
>
> 23
>
> 130

## 111、Java 中的 3 个双引号是什么语法？

3 个双引号是指**文本块**，它是一个多行字符串，它可以避免使用大多数转义符号，自动以可预测的方式格式化字符串，并让开发人员在需要时可以控制格式。

文本块最早准备在 JDK 12 添加的，但最终撤消了，然后在 JDK 13 中作为预览特性进行了添加，然后又在 JDK 14 中再次预览，在 JDK 15 中,文本块终于转正，暂不再做进一步的更改。

使用示例

---

来看下这个 HTML 语言示例你就懂了:

##### 不使用 Text Blocks：：

```java
String html1 = "<html>\n" +
         "  <body>\n" +
         "  	<p>Hi，Java面试题</p>\n" +
           "    <p>欢迎关注，分享更多干货</p>\n" +
           "  </body>\n" +
               "</html>\n";
```

##### 使用 Text Blocks:

```java
String html2 ="""
    <html>
        <body>
            <p>Hi，Java面试题</p>
            <p>欢迎关注，分享更多干货</p>
        </body>
    </html>""";
```

文本块需要用三个双引号包起来，熟悉 Python 的都知道，三个双引号表示多行注释，没想到 Java 竟然用作了多行字符串...

再来看下字节码：

![](/images/进阶/111_1.jpg)

看到了吧？文本块编译后会自动添加换行符，和原始的拼接写法编译结果一致，再也不用再拼接字符串了。

##### 详细介绍

---

其实文本块的作用远不止换行符这么简单，下面我详细介绍下。

##### 1、Line terminators (换行符)

如上面介绍，编译期自动增加换行符可以用来增强用非 Java 语言编写的代码的字符串的可读性，比如我们经常要拼接 HTML、XML、SQL 语言代码等，代码非常难看。

> """
>
> Java
>
> line 2
>
> line 3
>
> """

就等同于：

> "line 1\nline 2\nline 3\n"

或者：

> "line 1\n" +
>
> "line 2\n" +
>
> "line 3\n"

如果最后一行不需要换行，可以这么写：

> """
>
> line 1
>
> line 2
>
> line 3"""

还可以定义一个空的文本块：

> String empty = """
>
> """;

一个空字符串也需要两行代码，所以这个方式是不推荐使用的。

##### 2、Incidental white space (空格编排)

继续看上面那段代码：

![](/images/进阶/111_2.jpg)

注意这根线没有，线前面有一排空格，意味着是不会被编译进去的，只是用来缩进格式化方便阅读，所以我叫它空格编排。如果“"在最后单独占一排，则以它左对齐，否则以最靠左的一列左对齐。

![](/images/进阶/111_3.jpg)

![](/images/进阶/111_4.jpg)

另外，Java 15 中新增了［string·stripIndent 实例方法，可以直接删除每一行的开头和结尾空白字符。

##### 3、Escape sequences (转义字符)

如下面代码所示:

![](/images/进阶/111_5.jpg)

我在代码中又增加了`\s`、`\n`、`\t`之类的转义字符，可以直接拿来用，双引号也不需要转义。

结果输出：

> <html>
>
> <body>
>
> <p>Hi,"java面试题"</p>
>
> <p>欢迎关注，\分享"更多"干货</p>
>
> </body>
>
> </html>

实际工作中可能出现的 SQL 语句的拼写就有救了！

##### 不使用 TextBlocks:

```java
String query = "SELECT \"EMP_ID\", \"LAST_NAME\" FROM \"EMPLOYEE_TB\"\n" "WHERE \"CITY\" = 'INDIANAPOLIS"\n" +"ORDER BY \"EMP_ID\", \"LAST_NAME\";\n";
```

##### 使用 TextBlocks:

```java
String query =SELECT "EMP_ID", "LAST_NAME" FROM "EMPLOYEE_TB"WHERE "CITY" = 'INDIANAPOLIS'ORDER BY "EMP_ID", "LAST_NAME";
""";
```

当然，拼接 SQL 要注意别造成 SQL 注入漏洞了，这里只是介绍使用。

另外，Java 15 新增了一个`string.translateEscapes`转义方法，可以直接对字符串内容进行转义。

##### 4、格式化参数

Java 15 之前格式化字符串中的参数需要使用`String.format`静态方法，感觉不是很方便，而在 Java 15 中新增了直接格式化字符串的方法：

![](/images/进阶/111_6.jpg)

对上面的 SQL 语句进行扩展下，参数使用占位符进行格式化：

```java
String query = """
    SELECT "EMP_ID", "LAST_NAME" FROM "EMPLOYEE_TB"
    WHERE "CITY" = '%s' AND author = '%s'
    ORDER BY "EMP_ID", "LAST_NAME";
  """;
System.out.printin(query.formatted("sz", "SLQ1893"));
```

结果输出：

> SELECT "EMP_ID", "LAST_NAME" FROM "EMPLOYEE_TB"
>
> WHERE "CITY" ='sz' AND author = 'SLQ1893'
>
> ORDER BY "EMP_ID", "LAST_NAME";

直接使用字符串对象的 formatted 实例方法感觉更方便了！

## 112、@Deprecated 注解的作用？

这是 JDK 自带的注解：

![](/images/进阶/112_1.jpg)

被此注解标识的元素，表示不建议使用，建议使用其他方式替代，并且在后续的版本中也不再更新，并且有可能被移除。如果使用了此注解标识的元素，在 IDE 中会有划线警告提示，比如我们常用的 Date 类：

![](/images/进阶/112_2.jpg)

这个构造方法已经标识@Deprecated 注解了，不建议使用了，建议使用见 See Also 部分。

## 113、@Repeatable 注解有什么用？

##### 什么是重复注解

---

下面是 JDK8 中的重复注解（`java.lang annotation.Repeatable`）定义的源码。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    Class<? extends Annotation> value();
}
```

重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如 Spring 中可以使用多个扫描组件来扫描多个包的注解。

```java
@componentscan
@componentscan
public class Configuration{

}
```

##### ComponentScan

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(componentscans.class)
public @interface Componentscan {
}
```

##### ComponentScans

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented@Repeatable(componentscans.class)
public @interface Componentscan {
    ....
}
```

##### 重复注解实现

---

下面来演示下重复注解的实现。

```java
public static void main(string[] args) {
    for (Token token : UserToken.class.getAnnotationsByType(Token.class)) {
        System.out.println(token.value());
    }
}
@Target(ElementType. TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Tokens {
    Token[] value();
}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(Tokens.class)
public @interface Token {
    String value();
}
@Token("666666")
@Token("888888")
public interface UserToken {
}
```

输出结果：

> 666666
>
> 888888

## 114、@Repeatable 注解在哪里有用到？

如 Spring 中可以使用多个扫描组件来扫描多个包的注解。

```java
@componentscan
@componentscan
public class Mainconfig {
}
```

##### @ComponentScan 源码：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented@Repeatable(componentscans.class)
public @interface Componentscan {
  ...
}
```

##### @ComponentScans 源码：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface Componentscans {
    Componentscan[] value();
}
```

## 115、OracleJDK 和 OpenJDK 有啥区别？

##### 1、开源性质

- OpenJDK 是开源的，它是一个由 OpenJDK 社区维护的开源项目。
- Oracle JDK 是 Oracle 官方的，是闭源的，有条件免费使用，也含有商业服务，这对于需要长期支持和企业级服务的商业用户来说可能更具优势。

##### 2、授权协议不同

OpenJDK 采用 GPL V2 协议， 而 Oracle JDK 则采用 JRL 等多个协议。

##### 3、功能不同

OpenJDK 一般只包含最精简的 JDK，但随着 Oracle 对 JDK 的策略变化，特别是从 JDK 11 开始，Oracle JDK 和 OpenJDK 之间的差异已经变得非常小了。

##### 4、性能和兼容性

早期，Oracle JDK 因包含一些专有优化而被认为在某些情况下性能更优。但自从 Oracle JDK 和 OpenJDK 在 JDK 11 及以后版本中趋于一致以来，OpenJDK 和 Oracle JDK 在性能上没有区别。

另外，OpenJDK 和 Oracle JDK 在大多数情况下是互相兼容的，相互迁移不会引发太多兼容性问题。

## 116、JDK 实现定时任务有哪些方式？

是的，不用任何框架，用我们朴素的 Java 编程语言就能实现定时任务。

#### 1、sleep

---

这也是我们最常用的 sleep 休眠大法，不只是当作休眠用严我们还可以利用它很轻松的能实现一个简单的定时任务。

##### 实现逻辑：

新开一个线程，添加一个 for/while 死循环，然后在死循环里面添加一个 sleep 休眠逻辑，让程序每隔 N 秒休眠再执行一次，这样就达到了一个简单定时任务的效果。

##### 实现代码如下：

```java
/**
* 休眠实现定时任务
*/
private static void sleepTask() {
    newThread(()-> {
        while (true) {
            System.out.println("hi，欢迎关注：Java");
            try {
            // 每隔3秒执行一次
                Thread.sleep(3000);
            } catch(InterruptedException e) {
                e.printStackTrace();
            }
        }
    }).start();
}
```

这种方式比较傻瓜化了，只能按固定频率运行不能指定具体运行的时间。

##### 2、Timer

来看下 JDK 自带的 java.util.Timer 类：

![](/images/进阶/116_1.jpg)

JDK1.3 就内置了 java.util.Timer 类，可以用来调度 java.util.TimerTask 任务。

![](/images/进阶/116_2.jpg)

几个重要的方法：

- schedule：开始调度任务，提供了几个包装方法；
- cancle：终止任务调度，取消当前调度的所有任务，正在运行的任务不受影响；
- purge：从任务队列中移除所有已取消的任务；

另外，java.util.TimerTask 就是实现了 Runnable 接口，具体任务逻辑则是在 run 方法里去实现。

![](/images/进阶/116_3.jpg)

##### 实现代码如下：

```java
private static void timerTask() throws InterruptedException {
    Timer timer = new Timer();

    TimerTask timerTask = new TimerTask() {
        @Override
        public void run() {
            System.out.println("hi, 欢迎关注： Java技术栈");
        }
    }
    // 第一次任务延迟时间
    long delay = 2000;
    // 任务执行频率
    long period = 3 * 1000;20
    // 开始调度
    timer.schedule(timerTask, delay, period);
    // 指定首次运行时间
    // timer.schedule(timerTask, Dateutils.addseconds(new Date(), 5), period);
    Thread.sleep(20000);

    // 终止并移除任务
    timer.cancel();
    timer.purge();
}
```

这种实现方式比较简单，可以指定首次执行的延迟时间、首次执行的具体日期时间，以及执行频率，能满足日常需要。另外，需要注意的是，Timer 是线程安全的，因为背后是单线程在执行所有任务。

##### Timer 也会有一些缺陷：

- Timer 是单线程的，假如有任务 A,B,C，任务 A 如果执行时间比较长，那么就会影响任务 B,C 的启动和执行时间，如果 B,C 执行时间也比较长，那就会相互影响；
- Timer 不会捕获异常，如果 A,B,C 任何一个任务在执行过程中发生异常，就会导致 Tmer 整个定时任务停止工作；
- mer 是基于绝对时间调度的，而不是基于相对时间，所以它对系统时间的改变非常敏感；

所以，如果在使用 Timer 的过程中要注意这些缺陷，虽然可以用，但不推荐。

##### 3、ScheduledExecutorService

---

因 Timer 有一些缺陷，所以不太建议使用 Timer，推荐使用 ScheduledExecutorService :

![](/images/进阶/116_4.jpg)

ScheduledExecutorService 即是 Timer 的替代者，JDK1.5 并发包引 l 入，是基于线程池设计的定时任务类：

> java.util.concurrent.Executors.newScheduledThreadPool

![](/images/进阶/116_5.jpg)

上了线程池，每个调度任务都会分配到线程池中的某一个线程去执行，任务就是并发调度执行的，任务之间互不影响。几个重要的调度方法：

![](/images/进阶/116_6.jpg)

- chedule：只执行一次调度；
- heduleAtFixedRate：按固定频率调度，如果执行时间过长，下一次调度会延迟，不会同时执行；
- cheduleWithFixedDelay：延迟调度，上一次执行完再加上延迟时间后执行；

另外，可以看出，任务是支持 Runnable 和 Callable 调度的。

##### 实现代码如下：

```java
public static void pooltask() {
    ScheduledExecutorservice pool = Executors.newscheduledThreadPool(10) ;
    pool.scheduleAtFixedRate(() -> {
        System.out.println("hi， 欢迎关注： Java技术栈");
    }, 2000, 3000, TimeUnit.MILLIsECONDS);
}
```

这是一个按固定频率调度的任务，创建了 10 个核心线程数，首次执行延迟 2 秒，后续每 3 秒执行一次。

这种方式简单、好用，避免了使用 Timer 带来的各种问题，推荐使用这种实现方式。

## 117、Java 事件机制包含哪三部分？

Java 事件机制包括三个部分：事件对象、事件监听器、事件源。

##### 1、事件对象

一般继承自`java.util.Eventobject`类，封装了事件源对象及跟事件相关的信息。

##### 2、事件监听器

实现`java.util.EventListener`接口，注册在事件源上，当事件源的属性或状态改变时，取得相应的监听器调用其内部的回调方法。

##### 3、事件源

事件发生的地方，由于事件源的某项属性或状态发生了改变，导致某项事件发生。

## 118、Java 中的 UUID 是什么？

UUID 全称：**Universally Unique Identifier**，即通用唯一识别码。

UUID 是由一组**32 位数的 16 进制数字**所构成，UUID 理论上的总数为 16^32=2^128，约等于 3.4×10^38，也就是说若每纳秒产生 1 兆个 UUID，要花 100 亿年才会将所有 UUID 用完。

UUID 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为**8-4-4-4-12**的 32 个字符，如：d52fe3fb-3b50-4ef9-8bbe-ad7208343dee。

UUID 的目的是让分布式系统中的所有元素都能有一个唯一的标识符，而不需要通过中央协调来确保其唯一性。

示例代码：

```java
public static void main(string[] args) {
    //生成随机
    UUIDUUID uuid = UUID.randomUUID();
    //打印 UUID
    System.out.println(uuid);
}
```

> 市面上也有不少批量生成 UUID 在线网站。

## 119、Java 日期格式中 YYYY 与 yyyy 的区别？

如 JDK 所描述：

> https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html

| Letter | Date or Time Component                         | Presentation       | Examples                                |
| ------ | ---------------------------------------------- | ------------------ | --------------------------------------- |
| G      | Era designator                                 | Text               | AD                                      |
| y      | Year                                           | Year               | 1996 ; 96                               |
| Y      | Week year                                      | Year               | 2009; 09                                |
| M      | Month in year (context sensitive)              | Month              | July ; Jul ; 07                         |
| L      | Month in year (standalone form)                | Month              | July ; Jul ; 07                         |
| w      | Week in year                                   | Number             | 27                                      |
| W      | Week in month                                  | Number             | 2                                       |
| D      | Day in year                                    | Number             | 189                                     |
| d      | Day in month                                   | Number             | 10                                      |
| F      | Day of week in month                           | Number             | 2                                       |
| E      | Day name in week                               | Text               | Tuesday ; Tue                           |
| u      | Day number of week (1 = Monday, ., 7 = Sunday) | Number             | 1                                       |
| a      | Am/pm marker                                   | Text               | PM                                      |
| H      | Hour in day (0-23)                             | Number             | 0                                       |
| k      | Hour in day (1-24)                             | Number             | 24                                      |
| K      | Hour in am/pm (0-11)                           | Number             | 0                                       |
| h      | Hour in am/pm (1-12)                           | Number             | 12                                      |
| m      | Minute in hour                                 | Number             | 30                                      |
| s      | Second in minute                               | Number             | 55                                      |
| S      | Millisecond                                    | Number             | 978                                     |
| z      | Time zone                                      | General time zone  | Pacific Standard Time ; PST ; GMT-08:00 |
| Z      | Time zone                                      | RFC 822 time zone  | -0800                                   |
| X      | Time zone                                      | ISO 8601 time zone | -08 ;-0800 ; -08:00                     |

**y：**年，当天所在的年份

**Y：**Week year，当天所在周的年份，一周从周日开始，周六结束，只要本周跨年，那么这周就会算入到下一年。

示例代码：

```java
 public static void main(string[] args) throws Exception {
     SimpleDateFormat formatwithyYY = new SimpleDateFormat("vYYY-MM-dd");
     SimpleDateFormat formatwithYyyy = new SimpleDateFormat("yyyy-MM-dd");
     Date date = new SimpleDateFormat("yyyy-MM-dd").parse("2022-12-26");
     //输出：使用YYYY:2023-12-26
     System.out.printin("使用 yY: " + formatwithyyy.format(date));
     //输出：使用yyyy:2022-12-26
     System.out.println("使用 yyyy: " + formatwithyyyy.format(date));
 }
```

> 这里有个坑！！！
>
> 一般情况下要用 yyyy，而不是 YYYY，这几年很多程序员因为用了 YYYY 而出现系统漏洞，记得吸取教训 l。

## 120、Java 中的 SPI 机制是什么？

SPI 全称：**ServiceProvider Interface**

SPI 它是 Java 为服务提供者和服务加载器之间提供的一种**松耦合的连接机制**，它允许服务提供者通过配置文件来注册服务，而服务使用者可以通过 SPI 机制动态加载这些服务，而不需要知道服务提供者的具体实现类。

![](/images/进阶/120.jpg)

这种机制广泛应用于 Java 中的很多库和框架中，比如**JDBC 驱动的加载，日志框架、以及 Dubbo、Sentinel 等**，都可以看到 SPI 机制的应用，SPI 机制可以提高 Java 应用的可扩展性和灵活性。

## 121、SPI 机制的实现流程是怎样的？

SPI 机制的使用流程如下：

1、定义 SPI 接口标准，服务提供者实现服务接口。

2、在`META-INF/services`目录下创建一个以服务接口全路径命名的文件。

3、在这个文件中列出实现该服务接口的具体实现类的全路径名称。

4、服务使用者通过`java.util.Serviceloader`类加载这个服务接口、加载配置文件并实例化所有列出的实现类。

---

拿 JDBC 为例，看它是怎么实现 SPl 机制的，它提供了一个`java.sql.Driver`接口，而接口的实现则需要各个数据库厂商实现，也就是在各个数据库驱动包的`META-INF/services/java.sql.Driver`文件中指定的。

如 MySQL 驱动包所示：

![](/images/进阶/121_1.jpg)

当调用 DriverManager·getConnection 方法获取连接时，DriverManager 类内部会使用 ServiceLoader 类来加载 java.sql.Driver 服务的实现：

![](/images/进阶/121_2.jpg)

加载完后，后面再负责驱动实现类的实例化。

## 122、为什么说 SPI 打破了双亲委派机制？

先说说双亲委派模型，双亲委派模型是类加载器的一个特性，当一个类加载器试图加载一个类时，它首先会委托给其父类加载器去尝试加载这个类，**只有在所有父类加载器不能加载时，它自己才会去加载这个类**，确保了类加载的唯一性和安全性。

如 ServiceLoader 源码所示：

```java
@caller5ensitive
public static <s> Serviceloader<s> load(class<s> service) {
    Classloader cl = Thread.currentThread() .getcontextclassloader();
    return new Serviceloader<>(Reflection.getcallerclass(), service, cl);
}
```

它默认就使用当前线程上下文类加载器去加载实现类的，也就是应用类加载器。

原则上，**一个类以及这个类依赖的类应该由相同的类加载器加载**，但因为 SPI 的特殊性，一些 SPI 接口，如 java.sql.Driver 它是由引导类加载器加载的，实现类必须依赖 SPI 接口，理应也由引导类加载器加载，**但引导类加载器无法加载实现类，所以不得不由应用类加载器加载，所以它就打破了双亲委派模型的规则**。

总的来说，SPI 机制的实现依赖于 Java 类加载器，而类加载器自身遵循双亲委派模型，但 SPI 机制本身并不需要遵循双亲委派模型，这是由 Java 类加载器底层机制决定的。

## 123、SPI 接口与 API 接口的区别？

这两个虽然都是接口，但使用场景却截然不同：

- **APl（Application Programming Interface）**：它主要面向最终用户或开发者，它提供了一套明确的 HTTP 定义来实现特定的功能，强调易用性和稳定性。
- **SPl（ServiceProviderInterface）**：它则是一种服务发现机制，它允许开发者扩展和替换框架中的部分功能，更侧重于内部实现的扩展性和可替换性。

直白点说，**API 用于构建应用程序，而 SPI 用于框架或库的扩展开发**，API 是更大维度的东西，它的内部实现可能包含 SPI 机制，但反过来则不大可能。

## 124、JNDI 是什么？有什么用？

JNDl：**Java Naming and DirectoryInterface**，即：**Java 命名和目录接口**，它专为 Java 应用程序提供命名和目录功能。JNDI 架构图：

![](/images/进阶/124.jpg)

如图，JNDI 包含以下两部分：

##### 1、JNDI API：

Java 应用程序即是通过 JNDI API 来访问各种命名和目录服务的。

##### 2、JNDISPI(服务提供接口)

Java 应用程序通过 JNDI SPI 插入各种命名和目录服务的，然后通过 JNDI API 进行访问。

比如，没用 JINDI 之前，你可能要在 Java 代码中写死一些 JDBC 的数据库配置，有了 JINDI，就可以把数据源定义一种资源，然后通过名称进行查找，示例代码如下：

```java
Connection conn = null;
try {
    Context ctx = new Initialcontext();
    Datasource ds = (Datasource) ctx.lookup("java:MysqlDatasource");
    conn = ds.getconnection();
    ...
} catch(Exception e) {

}finally {
    ...
}
```

当然，数据源及配置现在都是 Spring 进行管理了，这里只是介绍 JNDI 的一种用法。

##### 说白了，JNDI 就是 JaVa 的一套规范，相当于把某个资源进行注册，再根据资源名称来查找定位资源。

---

要使用 JNDI，必须要有一个 JDNI 类，以及 1 个或者多个服务提供者（SPI），比如，在 JDK 中就包含以下几个服务提供者：

- 量级目录访问协议(LDAP)
- 用对象请求代理体系结构（CORBA)
- 用对象服务命名服务(COS)
- Java 远程方法调用 (RMI)
- 域名服务 (DNS)

这里的`LDAP`协议正是频频爆漏洞的根源（如：Log4j2），攻击者屡试不爽。

## 125、LocalDateTime 和 Date 的区别?

LocalDateTime 是 JDK 8 中新增的时期时间类:

- LocalDateTime (日期时间)

- LocalDate (日期)
- ocalTime (时间)

最大的区别就是 Date 默认值打印可读性差：

```java
public static void main(string[] args) {
    Date date = new Date();
    LocalDateTime localDateTime = LocalDateTime.now();
    System.out.printin("小程序：Java面试库 "+ date);
    System.out.println("小程序: Java面试库 " + localDateTime);
}
```

![](/images/进阶/125.jpg)

LocalDateTime 默认打印出来可读性好多了吧。

另外就是，LocalDateTime 更强，更灵活，功能上不输 Date，和 Date 的 SimpleDateFormat 相比，LocalDateTime 的 DateTimeFormatter 是线程安全的。

```java
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd H:mm:ss");
LocalDateTime localDateTime = LocalDateTime.now();
String datestring = localDateTime.format(dateTimeFormatter)
```

## 126、你怎么理解 Java 模块化？

传统的 Java 开发中，代码是以类和包的形式组织的，但随着应用程序变得越来越复杂，类和包的层次结构变得庞大且难以维护。

Java 9 引 l 入了新功能：**模块系统（Jigsaw）**，旨在提供一种更好的方式来组织、管理和复用代码，模块化允许开发者将包划分为更小的单元（即模块），从而提供了更好的代码组织和模块化边界。

模块是包的集合，模块可以包含多个包，如图所示：

![](/images/进阶/126_1.jpg)

模块，可用于控制包的暴露方式及访问权限。

##### 模块之间，及和包、类的层级关系如下：

![](/images/进阶/126_2.jpg)

## 127、为什么要引入模块化？

来看 Java 9 之前的版本的 JDK 目录， 以 JDK 8 为例：

![](/images/进阶/127_1.jpg)

JDK 包的目录都是以 jar 包存在的，并且所有包都能外开放。

##### JDK8-会存在以下问题：

- DK 包臃肿，就算不用那个 jar 包也会被打包其中，比如：swing/小 wt 等，万年用不到；
- 所有包都能对外公开，不方便控制包的使用权限，开发者会误用其中的 API，比如：BASE64 相关的类；
- ...

所以，JDK 引入了模块化的功能。

来看 Java 9+ 模块化后的 JDK 目录，以 JDK 17 为例：

![](/images/进阶/127_2.jpg)

JDK 包的目录都是以模块（module）存在的，JDK 17 中一共有 70 个模块，有些模块默认是公开的，而有些模块是需要导入的。

在 JDK 9 之前，Java 的运行时类库（Runtime Library）是由一个庞大的 rtjar 承载的，模块化后的 JDK 运行环境得到大大缩减：

![](/images/进阶/127_3.jpg)

##### 模块化的优势：

1、模块化使应用变得极简，不用再依赖不需要的 JDK 内部包，可以自行导入使用。

2、模块化的安全性和权限控制更好，我们可以灵活控制各个模块包的暴露权限。

3、模块化可以帮助我们更好地管理项目依赖，做到包的最小引入。

4、模块化可以提供更清晰的模块化边界，松耦合变得非常容易。
