## 1、面向对象编程有哪些特征？

##### 1、抽象

抽象就是对同一个目标的共有的**属性、特征、方法、功能、行为**等进行抽取并归纳总结，它是一种将复杂实现简化为模型的过程，它关注的是对象的行为，而不用关注具体的实现细节。

在面向对象编程中，抽象主要是通过**抽象类和接口**来实现的：

- 抽象类是不能被实例化的，他会包含一些抽象方法和具体实现的方法。
- 接口则是一种特殊的抽象类型，一般仅包含抽象方法的声明，在 Java 8+中可以包含默认方法和静态方法实现。

抽象可以在不知道具体实现的情况下编程，提高了代码的灵活性和扩展性。

##### 2、封装（Encapsulation）

封装就是指隐藏对象的属性和实现细节，将对象的数据、属性、行为、方法等组合到一个单一的单元中，并通过访问修饰符控制成员属性的访问和修改权限，再通过特定公开的方法（比如：getter 和 setter 方法）暴露给外面访问。

比如以下代码：

```java
private String name = "Java面试题";

public String getName() {
    return name;
}
```

name 属性被 private 封装起来，外面只能通过对象的 getName 才能访问。

##### 3、继承（Inheritance）

继承是一种实现代码重用的机制，允许一个类继承另外一个类的成员和方法，使得子类也能具有父类相同的行为。

继承是通过`extends`关键字实现的：

```java
public class Dog extends Animal {

    @Override
    void eat() {
        System.out.println("狗吃饭")
    }
}
```

> Java 类之间只能实现单继承，接口之间可以多继承。

##### 4、多态（Polymorphism）

多态即【多种形态】，指同一个行为在不同的情况下有多种不同的表现形式或形态，主要体现为同一个接口或父类的引用指向不同的实现对象，并能够在运行时动态决定调用的具体实现，这使得程序具有更好的灵活性和可扩展性。

比如下面的代码：

```java
Animal animal = new Dog();
animal.eat();   // 狗吃饭
```

通过父类引用变量指向子类时，当调用父类的方法时，它实际上会根据实际对象的类型，去调用子类中的方法，所以输出的是狗吃饭，而不是动物吃饭。

## 2、JDK 与 JRE 的区别是什么？

#### JDK

JDK 全称：Java Development Kit，是整个 Java 的核心，包含了 Java 运行环境（JRE）和一系列 Java 开发工具完整的包。

#### JRE

JRE 全称：Java Runtime Environment，是 Java 程序的运行环境，包含 JVM、Java 核心类库等。

JRE 只能用来运行 Java 应用程序，不能用于编译开发，它是 JDK 的子集。

![](/images/基础/2.png)

安装完 JDK 后，就会有 JRE 目录，JRE 属于 JDK 的子集。

## 3、如何编译和运行 Java 文件？

1、使用**javac**命令来编译.java 文件

> javac Test.java

运行之后会生成 Test.class 文件

2、使用 java 命令来运行

> java Test

## 4、Java 中的关键字有哪些？

##### Java 中的关键字：

| 关键字       | 含义                           |
| ------------ | ------------------------------ |
| package      | 指定包名                       |
| import       | 引用类                         |
| class        | 定义类                         |
| interface    | 定义接口                       |
| abstract     | 抽象类或者抽象方法             |
| new          | 创建对象                       |
| this         | 实例本身                       |
| super        | 引用父类                       |
| void         | 无返回                         |
| byte         | 字节型                         |
| char         | 字符型                         |
| int          | 整型                           |
| short        | 短整型                         |
| long         | 长整型                         |
| float        | 单精度浮点数                   |
| double       | 双精度浮点数                   |
| boolean      | 布尔型                         |
| enum         | 枚举型                         |
| strictfp     | 精确浮点                       |
| extends      | 继承类                         |
| implements   | 实现接口                       |
| private      | 私有权限，本类中可用           |
| protected    | 保护权限，本包、本类和子类可用 |
| public       | 公开权限，可挎包用             |
| final        | 类不可继承，方法不可重写、常量 |
| static       | 静态属性                       |
| synchronized | 线程同步                       |
| if           | 如果                           |
| else         | 或者                           |
| for          | for 循环                       |
| do           | do while 循环                  |
| while        | do while 循环                  |
| switch       | switch case 分支               |
| case         | switch case 分支               |
| default      | switch case 分支               |
| break        | 结束循环                       |
| continue     | 继续循环                       |
| return       | 返回                           |
| try          | 异常代码捕获                   |
| catch        | 异常处理                       |
| finally      | 最后处理                       |
| throw        | 手动抛出一个异常               |
| throws       | 声明要抛出的异常               |
| instanceof   | 判断是否 xx 类的实例           |
| volatile     | 线程可见                       |
| transient    | 不用序列化                     |
| native       | 非 Java 实现方法               |
| assert       | 断言                           |
| var          | 任意类型，JDK10 增加           |

| 保留关键字 |      |
| ---------- | ---- |
| goto       | 跳转 |
| const      | 常量 |

| 特殊关键字 |      |
| ---------- | ---- |
| true       | 真   |
| false      | 假   |
| null       | 空值 |

## 5、Java 标识符命名规则是怎样的？

（1）标识符只能由字母（a-z, A-Z）、数字（0-9）、下划线（\_）和美元符号（$）组成；

（2）标识符不能以数字开头；

（3）标识符不能使用 Java 关键字；

（4）标识符区分大小写；

## 6、Java 类命名规范是怎样的？

类名首字母大写，后面每个单词首字母大写，符合**UpperCamelCase**大驼峰式风格，如：

- Order
- OrderDetail
- OrderMonthSummary

但一般像这种众所周知的缩写例外：DO、BO、DTO、VO、AO、PO、UID 等。

## 7、Java 方法命名规范是怎样的？

方法名首字母小写，后面每个单词首字母大写，符合**小驼峰式**，如：

- println
- indexOf
- saveOrderInfo

## 8、Java 变量命名规范是怎样的？

变量包括方法参数名、成员变量、局部变量。

变量首字母小写，后面每个单词首字母大写，符合 LowerCamelCase 小驼峰式风格，如：

- amount
- orderPrice
- orderStockInfo

## 9、Java 常量命名规范是怎样的？

常量名全部大写，单词间用下划线（\_）隔开，如：

- MAX_LIMIT
- MAX_LOOP_COUNT
- ALIPAY_PAY_URL

## 10、Java 常量和变量的区别？

##### Java 常量和变量的主要区别在于：

常量是一个固定的值，赋值后是不能被改变的；

变量是一个不固定的值，赋值后是可以随时被改变的；

## 11、Java 怎么定义一个常量？

Java 使用`final`关键字来定义一个常量，如：

```java
final int MAX_COUNT = 100;
```

也可以加修饰范围，以及静态关键字，如：

```java
private static final int MAX_COUNT = 100;
```

## 12、Java 常量有几种类型？

##### Java 常量有三种类型：

1、静态常量（类中）

2、成员常量（类中）

3、局部常量（类方法中）

## 13、Java 有哪几种基本数据类型？

##### Java 有 4 类 8 种数据类型，它们分别是：

###### 1、整型

byte、short、int、long

###### 2、浮点型

float、double

###### 3、字符型

char

###### 4、布尔型

boolean

## 14、什么是枚举类型？

Java 中的枚举是一种特殊的数据类型，用于定义一组常量，枚举使用`enum`进行定义，并且可以包含零个或多个枚举常量，多个用逗号分开。

枚举常量实际上是枚举类的静态实例，编译器会为每个枚举常量生成一个私有构造函数，用于创建枚举常量的实例。枚举常量在内存中只有一个实例，确保唯一性。

> 枚举类型可以用来表示一组固定的值，例如星期几、月份、颜色等，它提供了一种更简洁、可读性更高的方式来表示一组相关的常量。

以下是一个使用枚举的示例，表示一周的星期几：

```java
enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

上面`Day`就是一个枚举类，它定义了七个枚举常量，分别代表一周的每一天。

每个常量还可以添加多个字段，比如我添加一个中文名称字段：

```java
public class Test {

    public static void main(String[] args) {
        Day today = Day.MONDAY;
        System.out.println("Today is " + today);
        System.out.println("Today is " + today.getChineseName());
    }

    enum Day {
        MONDAY("星期一"),
        TUESDAY("星期二"),
        WEDNESDAY("星期三"),
        THURSDAY("星期四"),
        FRIDAY("星期五"),
        SATURDAY("星期六"),
        SUNDAY("星期日");

        private String chineseName;

        Day(String chineseName) {
            this.chineseName = chineseName;
        }

        public String getChineseName() {
            return chineseName;
        }
    }
}
```

输出结果：

```
Today is MONDAY
Today is 星期一
```

## 15、枚举和类的区别？

Java 中枚举和类之间的区别：

|          | 枚举                     | 类                                 |
| -------- | ------------------------ | ---------------------------------- |
| 定义方式 | 使用`enum`关键字进行声明 | 使用`class`关键字进行声明          |
| 继承关系 | 不能继承                 | 可以继承其他类                     |
| 实例化   | 枚举常量是枚举类型的实例 | 可以创建类的实例对象               |
| 可修改性 | 枚举常量是不可修改的     | 类的属性和状态可以被修改           |
| 字段     | 可以有自己的字段         | 可以有自己的字段                   |
| 方法     | 可以有自己的方法         | 可以有自己的方法                   |
| 唯一性   | 每个枚举常量是唯一的     | 可以创建多个类的实例对象           |
| 比较     | 使用“==”进行比较         | 可以通过重写`equals()`方法进行比较 |
| 用途     | 表示一组相关的常量       | 封装数据和行为，实现复杂的功能     |

## 16、枚举可以修改吗？

枚举中的常量是不可以修改的，一旦枚举常量被定义，它们的值就是固定的，不能在运行时进行修改，枚举常量是在编译时就确定了的。

比如下面的枚举类型：

```java
enum Day {
        MONDAY("星期一"),
        TUESDAY("星期二"),
        WEDNESDAY("星期三"),
        THURSDAY("星期四"),
        FRIDAY("星期五"),
        SATURDAY("星期六"),
        SUNDAY("星期日");

        private String chineseName;

        Day(String chineseName) {
            this.chineseName = chineseName;
        }

        public String getChineseName() {
            return chineseName;
        }
    }
```

在程序运行期间，这些枚举常量不能删除，也不能添加新的枚举常量，它们的值也不能修改。

但是，枚举常量的字段的值是可以修改的，比如上面的枚举中的 chineseName 字段，添加一个 set 方法：

```java
public void setChineseName(String chineseName) {
    this.chineseName = chineseName;
}
```

测试一下：

```java
public static void main(String[] args) {
    Day today = Day.MONDAY;
    Day.MONDAY.setChineseName("礼拜一");
    System.out.println("Today is " + today);
    System.out.println("Today is " + today.getChineseName());
}
```

输出结果：

```
Today is MONDAY
TOday is 礼拜一
```

但是在开发中不建议这样做，一般建议把字段定义为`final`类型，这样就不能修改了。

## 17、枚举命名规范是怎样的？

枚举就是特殊的常量类，命名和类一样。

##### 阿里开发手册推荐：

- 枚举以\*Enum 命名；
- 枚举字段名称全大写，单词之间使用下划线分隔；

命名示例：

> 状态枚举：StatusEnum
>
> 枚举字段：SUCCESS / FAILED / PROCESS...

## 18、==和 equals 比较有什么区别？

**==**

（1）如果比较的对象是基本数据类型，则比较的是数值是否相同；

（2）如果比较的对象是引用数据类型，则比较的是对象的地址是否相同。

**equals**

equals 是 Object 类提供的方法，接收 Object 参数类型，如源码所示：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

即用来比较两个对象是否相等，默认比较的是对象的地址，不能用于比较基本数据类型，但可以是包装类型，所以，如果要比较两个对象的值是否相等，一般需要重写 equals 和 hashCode 方法。

比如常用的 String、Date、Integer 等类都重写了 equals 和 hashCode 方法，使其比较的是存储对象的内容是否相等，而不是堆内存地址。

## 19、字符串比较是用 equals 还是==？为什么？

如 String 类源码所示，它已经重写了 equals 方法：

![](/images/基础/19.png)

String 中的 equals 方法是先用==比较是否同一个对象，然后再比较内容是否相同。

**所以如果要比较字符串对象的内容是否相等就用 equals 方法，而要比较字符串的内存地址是否相等就用==比较，不过实际情况都是比较字符串内容而不会是比较内存地址。**

如下面的示例：

```java
public static void main(String[] args) {
    String str1 = new String("java面试题");
    String str2 = new String("java面试题");

    // 两个不同字符串对象==比较，返回false
    System.out.println(str1 == str2);

    // 两个字符串内容相同equals比较，返回true
    System.out.println(str1.equals(str2));
}
```

输出结果：

```
false
true
```

## 20、Java 支持 xx≠null 不等于写法吗？

不支持，正常的不等于写法是：`!=`

## 21、public、private、protected、默认的区别？

具体区别如下表所示：

| 作用域       | 当前类 | 当前包 | 子孙类 | 其他包 |
| ------------ | ------ | ------ | ------ | ------ |
| public       | √      | √      | √      | √      |
| protected    | √      | √      | √      |        |
| 默认（不写） | √      | √      |        |        |
| private      | √      |        |        |        |

不写为默认作用域，比如以下用来修饰成员变量：

```java
public class User {
    String name;
}
```

这个默认没有关键字，不用写。

## 22、this 和 super 有什么区别？

##### this：代表当前对象本身：

- this(...)：调用本类的构造方法；
- this.成员变量：调用当前对象的成员变量，包括从父类继承的；
- this.成员方法(...)：调用当前对象的成员方法，包括从父类继承的；

##### super：代表当前对象的父类：

- super(...)：调用父类的构造方法；
- super.成员变量：调用父类的成员变量；
- super.成员方法(...)：调用父类的成员方法；

## 23、Java 中的运算符都有那些？

Java 中运算符有以下几类：

| 运算符     | 示例                                  |
| ---------- | ------------------------------------- |
| 算术运算符 | + - \* / % ++ -                       |
| 关系运算符 | == != > < >= <=                       |
| 位运算符   | & ^ ~ >> << >>>                       |
| 逻辑运算符 | && \|\| !                             |
| 赋值运算符 | = += -= \*= /= (%)= <<= >>= &= ^= \|= |
| 三目运算符 | ? :                                   |

优先级从高到低排列：

| 类别     | 操作符                              | 关联性   |
| -------- | ----------------------------------- | -------- |
| 后缀     | () [] .                             | 左到右   |
| 一元     | i++ i-                              | 从左到右 |
| 一元     | ++i --i + - ~ !                     | 从右到左 |
| 乘性     | \* / %                              | 左到右   |
| 加性     | + -                                 | 左到右   |
| 移位     | >> >>> <<                           | 左到右   |
| 关系     | > >= < <=                           | 左到右   |
| 相等     | == !=                               | 左到右   |
| 按位与   | &                                   | 左到右   |
| 按位异或 | ^                                   | 左到右   |
| 按位或   | \|                                  | 左到右   |
| 逻辑与   | &&                                  | 左到右   |
| 逻辑或   | \|\|                                | 左到右   |
| 条件     | ? :                                 | 从右到左 |
| 赋值     | = += -= \*= /= %= >>= <<= &= ^= \|= | 从右到左 |
| 逗号     | ,                                   | 左到右   |

## 24、`s1 = s1 + 1`和`s1 += 1`的区别？

如果 s1 原有数据类型小于 int 类型，则 s1 = s1 + 1 会发生编译异常，如下面的程序所示：

![](/images/基础/24.png)

因为 s1 为 short 类型，而数字 1 默认为 int 类型，所以计算的结果则为 int 类型，它不能自动转换为比它更小的类型，所以会发生编译异常。

解决办法就是使用类型强制转换：

```java
public static void main(String[] args) throws Exception {
    short s1 = 1;
    s1 = (short) (s1 + 1);
    System.out.println(s1);    // s1 = 2
}
```

使用 s1 += 1 则不会有任何问题，因为 s1 += 1 支持`隐式强制类型转换`，涉及到表达式类型自动提升，会自动提升为计算结果的数据类型，如以下程序：

```java
public static void main(String[] args) throws Exception {
    short s1 = 1;
    s1 += 1;
    System.out.println(s1);   // s1 = 2
}
```

## 25、`short s1 = 1; s1 += 1;`有错吗？

没错，可以正常编译，如下图所示：

![](/images/基础/25.png)

因为 s1 += 1;相当于 s1 = (short) (s1 + 1)，其中有隐式强制类型转换。

## 26、`short s1 = 1; s1 = s1 + 1;`有错吗？

有错，如下图所示：

![](/images/基础/24.png)

因为 1 是 int 类型，因此 s1 + 1 运算结果也是 int 类型，需要强制转换类型才能赋值给 short 型。

![](/images/基础/26.png)

## 27、`float n = 1.8`有错吗？

答案：**有错！！！**

数字 1.8 默认是双精度数（double），将双精度型（double）赋值给单精度型浮点型（float）属于向下转型（down-casting），会产生编译错误：

![](/images/基础/27.png)

因此，需要强制类型转换：

> float n = (float) 1.8;

或者写成这种形式：

> float f = 1.8F;

F 即表示 float 类型。

## 28、`i++`和`++i`的区别？

`i++`是先取值后再自增，`++i`是先自增后再取值，来看下面这段程序就明白了：

```java
public static void main(String[] args) {
    int i = 1;
    int j = i++ + 1;
    System.out.println(j);   // j = 2

    i = 1;
    int k = ++i + 1;
    System.out.println(k);    // k =3
}
```

程序解读：

- i++先取值再自增，所以 j = 1 + 1 = 2
- ++i 先自增再取值，所以 k = 2 +1 = 3

## 29、`while`和`do while`有啥区别？

`while`和`do while`都是循环语句，不同的是，`while`是先判断条件再执行循环，而`do while`是先执行循环再判断条件：

```java
public static void main(String[] args) {
    int i = 0;
    while (i < 5) {
        System.out.println("i = " + ++i);
    }

    i = 0;
    do {
        System.out.println("i = " + ++i);
    } while (i < 5);
}
```

所以说，在同样条件下，如果初始条件不成立，do while 是会多执行一次的。

## 30、如何跳出 Java 中的循环？

###### 可以使用以下关键字：

| 关键字   | 说明                   |
| -------- | ---------------------- |
| continue | 跳出当前本次循环       |
| break    | 跳出整个循环           |
| return   | 跳出整个循环及当前方法 |

## 31、如何跳出 Java 中的多层嵌套循环？

可以在最外面的循环语句前定义一个标号，然后在最里层循环体中使用`break`标号语句跳出嵌套循环。

如以下程序所示：

```java
public static void main(String[] args) {
    breakPrint:
    for (int i = 0; i < 100; i++) {
        for (int j = 0; j < 100; j++) {
            System.out.println("i=" + i + ", j=" + j);
            if (j == 66) {
                break breakPrint;
            }
        }
    }
}
```

输出结果如下：

![](/images/基础/31.png)

可以看到，i 只输出到 0，证明多层循环被全部跳出了。

## 32、`&`和`&&`的区别？

> 逻辑判断推荐使用&&，位运算则需要使用&

&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。

&&还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式。

&还可以用作位运算符，当&操作符两边的表达式不是 boolean 类型时，&表示按位与操作，我们通常使用 0x0f 来与一个整数进行&运算，来获取该整数的最低 4 个 bit 位，例如，0x31 & 0x0f 的结果为 0x01。

## 33、Java 怎么进行数组初始化？

方法一：

```java
// 一维数组
int[] arr = new int[5];

// 二维数组
int[][] arr = new int[3][4];
```

方法二：

```java
// 一维数组
int[] arr = {1, 2, 3, 4, 5};
```

方法三：

```java
int[] arr = new int[]{1, 2, 3, 4, 5};
```

## 34、数组有没有 length 方法？Sring 呢？

数组没有 length()方法，但是有 length 属性，String 有 length()方法。

使用示例如下：

```java
public static void main(String[] args) {
    String str = "Java";
    String[] languages = new String[]{"java", "PHP", "GO"};
    System.out.println(str.length());
    System.out.println(languages.length);
}
```

结果输出：

![](/images/基础/34.png)

## 35、怎么理解值传递和引用传递？

**值传递**：传递的是基本类型参数的字面量值的拷贝，方法对参数的修改不会影响之前参数的值。

**引用传递**：传递的是该引用的对象在堆中地址值的拷贝，而不是拷贝整个对象本身，方法对参数的修改会直接影响参数之前的值。

## 36、Java 到底是值传递还是引用传递？

网上很多争议，这里解读下：

> **Java 中只有值传递：**
>
> - \*\*\*\*对于基本数据类型，传递的是它们的实际值的副本；
> - 对于引用类型，传递的是对象的引用的值的副本，即对象的内存地址，而不是对象本身。
>
> 值传递传递的是数据的拷贝，而不是数据本身，引用类型的传递虽然可以修改引用对象的内容，但不能修改引用本身（引用类型和内存地址），所以，引用传递其实就是值传递的一种形式。

所以，严格来说，Java 中只有值传递。

## 37、Java 中的注释有哪些写法？

1、单行注释

```java
private int id;   // 这是ID
```

2、块注释

```java
private int id;  /* 这是ID */
```

3、文档注释

```java
/**
* 这是ID
*/
private int id;
```

## 38、Java 中的构造方法是什么？

构造方法是构造类的主要方法，Java 中的每个类都必须要有构造方法，构造方法名和类名相同，没有返回类型， new 一个对象的时候就会调用指定的构造方法，如图：

```java
public class Test {
    private int id;

    public Test() {
        this.id = 100;
    }
}
```

如果只有一个默认的构造方法，不需要赋值初始化，则可以省略，比如：

```java
public class Test {

    private int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}
```

## 39、Java 一个类可以有多少个构造方法？

一个类**至少要有一个**构造方法，也可以**有多个**构造方法，即构造方法重载，方法参数数量或者类型不同，如代码所示：

```java
public class Test {

    private int id;

    public Test() {
        this.id = 100;
    }

    public Test(int id) {
        this.id = id;
    }
}
```

如果没有显式地创建构造方法，Java 编译器也会为该类提供一个默认构造方法。

## 40、`static`关键字有什么用？

static 代表“**静态**”的意思，可以用来修饰：

- 静态内部类（静态内部类可以不依赖外部类实例对象而被实例化，而内部类需要在外部类实例化后才能被实例化）
- 静态方法（静态方法属于类方法，不需要实例化对象就能调用）
- 静态变量（静态变量属于类，不需要实例化对象就能调用）
- 静态代码块（静态代码块只会在类被加载时执行且执行一次）

使用实例如下：

```java
public class Test {
    static {
        System.out.println("静态代码块");
    }

    // 静态内部类
    static class Test2 {

    }

    // 静态变量
    private static int id = 0;

    // 静态方法
    public static void staticMethod() {

    }
}
```

## 41、`static`变量和普通变量地区别？

##### 1、所属目标不同

静态变量属于类的变量，普通变量属于对象的变量。

##### 2、存储区域不同

静态变量存储在方法区地静态区，普通变量存储在堆区。

> 另外：JDK7 及以上，静态变量存储在其对应的 Class 对象中，而 Class 对象和其他普通对象一样，都存储在堆中的。

##### 3、加载时间不同

静态变量是随着类的加载而加载，随着类的消失而消失；

普通变量随着对象的加载而加载，随着对象的消失而消失。

##### 4、调用方式不同

静态变量只能通过类名、对象调用，普通变量只能通过对象调用。

## 42、`static`可以修饰局部变量吗？

static 不能修饰局部变量，可以是内部类、全局成员变量、方法、代码块。

## 43、在`static`方法中可不可使用`this`或`super`，为什么？

在`static`方法中不可以使用`this`和`super`关键字：

![](/images/基础/43.png)

因为 this 和 super 代表的是实例化后的操作对象，而 static 属于类级别，无法指向任何实例。

## 44、final 关键字有哪些用法？

final 关键字的用法如下表：

| 修饰类型 | 说明                                 |
| -------- | ------------------------------------ |
| 修饰类   | 表示该类不能被继承                   |
| 修饰方法 | 表示该方法不能被重写                 |
| 修饰变量 | 表示常量，只能复赋值一次，不能被修改 |

## 45、final、finally、finalize 有什么区别？

#### final

final 是修饰符：

- 如果修饰类，此类就不能被继承；
- 如果修饰方法，此方法就不能被重写；
- 如果修饰变量，此变量就不能再被改变；

#### finally

finally 是 try-catch-finally 最后的一部分，表示不论发生任何情况都会执行的部分，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码（发生 Error 错误等非程序性异常除外）。

#### finalize

finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会自动调用被回收对象的此方法，一般不建议主动使用。

## 46、Java 支持多继承吗？

Java 类与类之间不支持多继承，只能单继承：

![](/images/基础/46_1.png)

Java 接口与接口之间支持多继承：

![](/images/基础/46_2.png)

## 47、Java 类可以实现多个接口吗？

可以的，一个类可以实现多个接口：

![](/images/基础/47.png)

## 48、重载和重写有什么区别？

##### 方法重写

是父类与子类之间多态性的一种表现，即子类可以覆盖从父类继承的方法，重写的方法一般使用@Override 标识，比如以下示例：

```java
@Override
public String toString() {
    return this.getName() + ...
}
```

这里是重写了 Object 祖先类的 toString 方法。

##### 方法重载

是一个类中方法多态性的一种表现，即一个类中可以有多个同名的方法，方法的参数类型不同，或者参数个数不同，返回类型可以相同也可以不同，比如以下实例：

```java
public Connection connection(String host) {
    ...
}

public Connection connection(String host, int port) {
    ...
}
```

同一个方法名，可以有多个不同的连接参数创建连接，这是很常见的方法重载方式。

## 49、构造器可以被重写和重载吗？

一个类的构造器只属于当前类，它不能被继承，所以它不能被重写。

一个类里面可以有多个构造器，所以它可以被重载。

## 50、私有方法能被重载或者重写吗？

##### 使用 private 修饰的私有方法，只可以重载，不能被子类重写。

因为 private 该作用域就只能在当前类中可见，子类见都见不到，别谈重写，重写至少需要 protected 及以上的作用域。

## 51、静态方法能被重载或者重写吗？

**静态方法可以被重载**，一个类可以存在多个同名但不同参数的 static 方法。

**静态方法不可以被重写**，如果子类也定义了相同的，会被子类同名的静态变量，静态方法所隐藏。

## 52、静态方法可以被继承吗？

（1）父类的静态属性、静态方法可以被子类继承；

（2）如果子类也定义了相同的静态属性、方法，那父类中的定义就会被子类同名的静态变量，静态方法所隐藏。

## 53、Java 异常有哪些分类？

下面是 Java 异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。

![](/images/基础/53.png)

##### Throwable

Throwable 是 Java 异常的顶级类，所有的异常都继承于这个类。

Error，Exception 是异常类的两个大分类。

##### Error

Error 是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如 OutOfMemorry 内存溢出异常等。

##### Exception

Exception 是程序异常类，由程序内部产生，Exception 又分为运行时异常、非运行时异常。

##### 运行时异常

运行时异常的特点是 Java 编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用 try-catch 语句捕获它，也没有用 throws 子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。

常见的运行时异常如 NullPointException、ArrayIndexOutOfBoundsException 等。

##### 非运行时异常

非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的 IOException、ClassNotFoundException 等。

## 54、`Error`和`Exception`有什么区别？

`Error`和`Exception`都属于异常总父类 Throwable 的子类：

![](/images/基础/54.png)

**Error**表示系统级的错误和程序不必处理的异常，它是一种严重的非程序性的错误，比如内存溢出错误，它不能由程序控制和处理。

**Exception**则表示程序性异常，可以由程序进行定义、控制和处理。

## 55、Java 中常见的异常有哪些？

##### 1、NullPointerException

空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。

##### 2、OutOfMemoryError

内存溢出异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。

##### 3、IOException

IO，即：input，output，我们在读写磁盘文件、网络内容的时候经常会发生的一种异常，这种异常是受检查异常，需要进行手工捕获。

如文件读写会抛出 IOException：

```java
public int read() throws IOException
public void write(int b) throws IOException
```

##### 4、FileNotFoundException

文件找不到异常，如果文件不存在就会抛出这种异常。

如定义输入输出文件流，文件不存在会报错：

```java
public FileInputStream(File file) throws FileNotFoundException
public FileOutputstream(File file) throws FileNotFoundException
```

FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。

##### 5、ClassNotFoundException

类找不到异常，这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。

看一个示例：

```java
public static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {
    try {
        return (Class<T>) Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException e) {
        return null;
    }
}
```

它是受检查异常，需要进行手工捕获。

##### 6、ClassCastException

类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。

如将一个数字强制转换成字符串就会报这个异常：

```java
Object x = new Integer(0);
System.out.println((String)x);
```

这是运行时异常，不需要手工捕获。

##### 7、NoSuchMethodException

没有这个方法异常，一般发生在反射调用方法的时候，如：

```java
public Method getMethod(String name, Class<?>...parameterTypes) throws NoSuchMethodException, SecurityException {
    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
    Method method = getMethod0(name, parameterTypes, true);
    if (method == null) {
        throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
    }
    return method;
}
```

它是受检查异常，需要进行手工捕获。

##### 8、IndexOutOfBoundsException

索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。

![](/images/基础/55_8.png)

如图所示，它是运行时异常，不需要手工捕获。

##### 9、ArithmeticException

算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。

```java
double n = 3 / 0;
```

这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：

```java
public static TimeStamp from(Instant instant) {
    try {
        TimeStamp stamp = new TimeStamp(instant.getEpochSecond() * MILLIS_PER_SECOND);
        stamp.nanos = instant.getNano();
        return stamp;
    } catch (ArithmeticException ex) {
        throw new IllegaArgumentException(ex);
    }
}
```

##### 10、SQLException

SQL 异常，发生在操作数据库时的异常。

如下面的获取连接：

```java
public Connection getConnection() throws SQLException {
    if (getUser() == null) {
        return DriverManager.getConnection(url);
    } else {
        return DriverManager.getConnection(url, getUser(), getPassword());
    }
}
```

又或者时获取下一条记录的时候：

```java
boolean next() throws SQLException;
```

它是受检查异常，需要进行手工捕获。

## 56、Java 中常见的运行时异常有哪些？

常见的运行时异常（RuntimeException）主要有：

| 异常                      | 说明             |
| ------------------------- | ---------------- |
| NullPointerException      | 空指针异常       |
| IndexOutOfBoundsException | 数组越界异常     |
| ClassCastException        | 类型强制转换异常 |
| ArithmeticException       | 算术异常         |
| SecurityException         | 违背安全原则异常 |

更多可以查看 RuntimeException 运行时异常类的子异常。

## 57、运行时异常与受检查异常有什么区别？

##### 运行时异常

指 RuntimeException 异常类及其子类，表示在程序运行时才可能发生的异常，编译器编译时不用检查，方法可以不用主动 catch，也可以不用 throws 声明抛出运行时异常。

##### 受检查异常

指非 RuntimeException 类型的异常，即编译器在编译时就会检查的异常，方法需要主动 catch 或者用 throws 声明所用的受检查异常，不然会出现编译错误。

---

空指针异常是运行时异常：

![](/images/基础/57_1.png)

在程序中可以不用声明，也不用捕获。

IO 异常是受检查异常：

![](/images/基础/57_2.png)

在程序中必须声明或者捕获。

## 58、什么时候会发生空指针异常？

当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。

所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。如下面示例会发生空指针异常：

```java
Object object = null;
String string = object.toString();
```

![](/images/基础/58.png)

从类结构图来看，空指针它是属于运行时异常`RuntimeException`的子类，他不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。

## 59、你知道有哪些避免空指针的方法？

下面说几个空指针的几个最常见的案例及解决之道。

##### 1、字符串比较，常量放前面

```java
if(status.equals(SUCCESS)) {

}
```

这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。

```java
if(SUCCESS.equals(status)) {

}
```

这个应该在各种开发规范里面都会提到，也是最基础的。

##### 2、初始化默认值

在对象初始化的时候给它一个默认值或者默认构造实现，如：

```java
User user = new User();
String name = StringUtils.EMPTY;
```

##### 3、返回空集合

在返回一个集合的话，默认会是 null，统一规范返回一个空集合。

举个 List 例子，如：

```java
public List getUserList() {
    List list = userMapper.getUserList();
    return list == null ? new ArrayList() : list;
}
```

这样接收方就不用担心空指针异常了，也不会影响业务。

##### 4、断言

断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。

Java 中自带的断言关键字，assert，如：

```java
assert name == null : "名称不能为空";
```

输出：

```java
Exception in thread "main" java.lang.AssertionError: 名称不正确
```

不过默认是不启动断言检查的，需要带上 JVM 参数：-enableassertions 才能生效。

Java 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。

Spring 中的用法：

```java
Assert.notNull(name, "名称不能为空");
```

##### 5、Optional

Optional 是 JDK 8 新增的新特性，再也不用 `!=null`来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。

> 这里大概介绍 5 种，其实还有更多，如何避免空指针，一是要注意代码编写规范，二是要提高代码素养。

## 60、`throw`和`throws`的区别？

`throw`用在方法中，用来主动抛出一个异常，`throws`则是用在方法声明中，声明方法可能会抛出的异常。

来看 Object#wait 方法的使用示例：

![](/images/基础/60_1.png)

两个不一定要同时使用，如果方法中抛出的是 RuntimeException 及其子异常，则方法可以不用 throws 声明，否则需要强制声明，比如下面的示例：

![](/images/基础/60_2.png)

test1 方法正常编译，而 test2 方法抛出的不是 RuntimeException 类型，又没有使用 throws 声明抛出，所以会报编译错误：

正确修改后：

```java
public void test1() {
    throw new RuntimeException("发生异常");
}

public void test2() throws Exception {
    throw new Exception("发生异常");
}
```

## 61、`try-catch-finally`中哪个部分可以省略？

`try-catch-finally`其中`catch`和`finally`都可以被省略，但是不能同时省略，也就是说有`try`的时候，必须后面跟一个`catch`或者`finally`。

如果是资源处理类型，并且实现了 AutoCloseable 接口，把定义它放在 try(...)中，然后方法上再加上 throws 异常，是可以省略 catch 和 finally 的，只需要 try 即可，比如：

```java
private void test() throws Exception {
    try (InputStream is = new FileInputStream("")) {
        ...
    }
}
```

## 62、Java 可以一次`catch`多个异常吗？

Java 7 开始可以一次 catch 多个异常，比如：

```java
public static void mian(String[] args) throws Exception {
    try {
        System.out.println("java面试题");
    } catch (SecurityException | NullPointerException | NoClassDefFoundError e) {

    }
}
```

## 63、使用`try-catch`会影响性能吗？

一般情况下，`try-catch`块的执行时间很短，它不会对性能产生显著的影响，但是在极端情况下，try-catch 块的使用可能会对性能产生影响。比如在代码中频繁地抛出和捕获异常，尤其是在高并发的情况下，`try-catch`块的性能可能会成为瓶颈。在这种情况下，可以使用其他方式处理异常，如：**条件判断**，以提高代码的性能。

来自阿里巴巴《Java 开发手册》中的异常规范：

> 异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多，所以：
>
> （1）可以通过预检查的方式规避异常，而不是依赖 try-catch 来处理。
>
> （2）异常捕获后不要用来做流程控制，条件控制。

## 64、`int`和`Integer`有什么区别？

##### 最主要的几点区别：

（1）int 是一种基本数据类型，Integer 则是 int 的包装类型。

（2）int 的默认值是 0，而 Integer 属于 Java 类，所以它的默认值是 null。

（3）int 可以直接使用，而 Integer 属于 Java 类，所以它需要经过实例化才能使用。

（4）Integer 属于 Java 类，所以它的使用范围更广，比如泛型，int 则不行。

## 65、什么是包装类型？有什么用？

#### 什么是包装类型

Java 设计当初就提供了 8 种基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。

下面是基本数据类型与对应的包装类型。

| 基本数据类型 | 包装类型  |
| ------------ | --------- |
| byte         | Byte      |
| boolean      | Boolean   |
| short        | Short     |
| char         | Character |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

下面是包装类型的继承结构图。

![](/images/基础/65.png)

从以上图表可以对基本类型和包装类型有一个全面的了解。

##### 包装类应用场景

###### 1、集合类泛型只能是包装类；

```java
// 编译报错
List<int> list1 = new ArrayList<>();

// 正常
List<Integer> list2 = new ArrayList<>();
```

###### 2、成员变量不能有默认值；

```java
private int status;
```

基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null，所以就不会有默认值影响。

###### 3、方法参数允许定义空值；

```java
private static void test1(int status) {
    System.out.println(status);
}
```

看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合包装类比较合适。

## 66、什么是自动装箱、拆箱？

##### 自动装箱、拆箱

Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。

##### 自动装箱

自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码：

```java
public static void main(String[] args) {
    Integer i1 = new Integer(8);   // 此种方式，Java9已标识废除
    Integer i2 = Integer.valueOf(8);

    // 自动装箱
    Integer i3 = 8;
}
```

第 3 种方法也正是自动装箱功能，其实自动装箱的原理就是调用包装类的`valueOf`方法，如第 2 个方法中的 Integer.valueOf()方法。

> 另外，第一种构造器方法也不推荐使用了，已经标为废弃了。

##### 自动拆箱

自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解，看下面的例子，

```java
public static void main(String[] args) {
    Integer i1 = new Integer(8);
    Integer i2 = Integer.valueOf(8);

    // 自动装箱
    Integer i3 = 8;

    // 自动拆箱
    int i4 = i3;
    int i5 = i3.intValue();
}
```

把 i3 赋值给 i4 就是实现的自动拆箱功能，自动拆箱的原理就是调用包装类的`xxValue`方法，如 i5 中的 Integer 的`intValue`方法。

> 自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。

## 67、你怎么理解 Java 中的强制类型转换？

强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。

如以下示例：

```java
short s = 199;
int i = s;   // 199

double d = 10.24;
long l1 = (long)d; // 10
```

以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况：

```java
int ii = 300;
byte b = (byte)ii;
```

300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。

## 68、你怎么理解 Java 中的自动类型转换？

**自动类型转换**：是指数字表示范围小的数据类型可以自动转换成范围大的数据类型。

如：

```java
long l = 100;

int i = 200;
long ll = i;
```

具体自动转换如下图所示。

![](/images/基础/68.png)

实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。

**自动转换也要小心数据溢出问题，看下面的例子。**

```java
int count = 100000000;
int price = 1999;
long totalPrice = count * price;
```

编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int，相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。

```java
int count = 100000000;
int price = 1999;
long totalPrice = (long)count * price;
```

另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。

## 69、你怎么理解 Java 中的类型提升？

##### 类型提升

所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。

如下面的示例：

```java
long count = 100000000;
int price = 1999;
long totalPrice = price * count;
```

price 为 int 型，count 为 long 型，运算结果自动向上提升为 long 型，运算结果正常，没有出现溢出的情况。

## 70、怎么理解 Java 中的多态机制？

多态，即”**多种状态**“的意思，在 Java 中有以下几种情形。

##### 一、方法多态

- **方法重写**：是父类与子类之间多态性的一种表现，即子类可以覆盖从父类继承的方法；
- **方法重载**：是一个类中方法多态性的一种表现，即一个类中可以有多个同名的方法，方法的参数类型不同，或者参数个数不同，返回类型可以相同也可以不同。

##### 二、对象多态

- **接口和实现类**：接口可以有多种不同的实现形式；
- **抽象类和实现类**：抽象类和实现类可以有多种不同的形式；

## 71、Java 如何获取用户的输入？

可以通过 Scanner 类来获取用户的输入，即：

java.util.Scanner。

基本语法：

```java
Scanner sc = new Scanner(System.in);
```

然后通过 next()或者 nextLine()方法获取输入的字符串，比如以下示例：

```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    String text = scanner.nextLine();
    System.out.println(text);
}
```

![](/images/基础/71.png)

先输入一行文字再换行，结果正常输出。

## 72、`switch`是否能用在`long`上？

长整型（long）在目前所有的版本中都是不支持的：

![](/images/基础/72.png)

在开发工具中会出现编译错误，并提示可用的类型。

## 73、`switch`是否能用在`String`上？

从 Java 7 开始，是可以用在字符串（String）上的，来看使用示例：

```java
public static void mian(String[] args) {
    String str = "Java";
    switch (str) {
        case "C++":
            System.out.println(0);
            break;
        case "Java":
            System.out.println(1);
            break;
        default:
            System.out.println(2);
    }
}
```

程序输出：1

## 74、`switch case`支持哪几种数据类型？

java 中`switch case`语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。

##### 语法格式如下：

```java
switch(expression) {
    case value:
        // 语句
        break;  // 可选
    case value:
        // 语句
        break;  // 可选
    // 你可以有任意数量的case语句
    default:   // 可选
        // 语句
}
```

###### 这里的`expression`都支持那些类型呢？

- 基本数据类型：byte、short、char、int
- 包装数据类型：Byte、Short、Character、Integer
- 枚举类型：Enum
- 字符串类型：String（JDK 7+开始支持）

基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。

```java
// 使用包装类型
Integer value = 5;
switch (value) {
    case 3:
        System.out.println("3");
        break;
    case 5:
        System.out.println("5");
        break;
    default:
        System.out.println("default");
}

// 使用枚举类型
Status status = Status.PROCESSING;
switch (status) {
    case OPEN:
        System.out.println("open");
        break;
    case PROCESSING:
        System.out.println("processing");
        break;
    case CLOSE:
        System.out.println("close");
        break;
    default:
        System.out.println("default");
}
```

以下为官网的介绍文档。

> https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html

**使用 switch case 语句也有以下几点需要注意。**

1、case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现；

2、case 条件里面只能是常量或者字面常量；

3、default 语句可有可无，最多只能有一个；

## 75、String 属于基础的数据类型吗？

String 是字符串类，属于 Java 中的“**类**”，它不属于基础数据类型。

![](/images/基础/75.png)

## 76、String 类的常用方法都有哪些？

String 类常用的方法有：

| 方法        | 说明                       |
| ----------- | -------------------------- |
| equals      | 比较值是否相同             |
| indexOf     | 返回指定字符的索引         |
| charAt      | 返回指定索引处的字符       |
| replace     | 字符串替换                 |
| trim        | 去除字符串两端空白         |
| split       | 分割字符串成数组           |
| getBytes    | 获取字符串的 byte 类型数组 |
| length      | 获取字符串长度             |
| toLowerCase | 转成小写字母               |
| toUpperCase | 转成大写字母               |
| subString   | 截取字符串                 |

## 77、String 字符串如何进行反转？

（1）最快的方法是借助 StringBuilder 或者 StringBuffer 中的 reverse 方法。

（2）借助字符串的 charAt 方法，从后到前遍历字符串，然后填充起来。

（3）借助 Collections.reverse(List...)方法，先把字符串转为 List 然后再反转。

（4）借助其他第三方工具类，比如 CollectionUtils 工具类等。

## 78、String 字符串如何实现编码转换？

先通过 getBytes 方法获取字节数组，再使用带编码的 String 构造器。

如代码所示，把字符串转换成 UTF-8：

```java
public static void main(String[] args) throws UnsupportedEncodingException {
        String text1 = "java面试题";
        String text2 = new String(text1.getBytes(), "UTF-8");
        System.out.println(text1);
        System.out.println(text2);
    }
```

结果输出：

> java 面试题
>
> java 面试题

## 79、String 与 byte[]之间如何转换？

String > byte[]通过 String 类的 getBytes 方法：

![](/images/基础/79_1.png)

byte[] > String 通过各种 String 构造器：

![](/images/基础/79_2.png)

## 80、String.trim()方法有什么用？

String.trim()用于去掉字符串**首尾**的空白字符，如下面的示例程序：

```java
public static void main(String[] args) {
        String text = "   java面试题   ";
        System.out.println(text.trim());
    }
```

输出结果：

![](/images/基础/80.png)

它不能去除中间的空白字符。

## 81、字符串分割有哪些方式？

（1）使用字符串自身的 split 方法；

（2）使用 JDK 的 StringTokenizer 工具类；

（3）使用 Spring/Apache commons-long 等工具包中的工具类；

（4）自己可以利用 indexOf 方法写一个分割工具类；

## 82、字符串工具类 isEmpty 和 isBlank 的区别？

isEmpty 和 isBlank 到底有啥区别？

##### 1、isEmpty

判断字符串是否为空字符串，只要有一个任意字符（包括空白字符）就不为空。

来看 isEmpty 的方法源码：

```java
public static boolean isEmpty(CharSequence cs) {
    return cs == null || cs.length() == 0;
}
```

看到没，这个方法只判断了是为 null 或者长度为 0。

意味着，如果用户输入“ ”等空白字符，这个方法就不通过了，结果就是不为空了。

如验证输入以下内容：

| 输入内容      | 是否为空 |
| ------------- | -------- |
| " "           | 否       |
| ""            | 是       |
| "Java 面试题" | 否       |

##### 2、isBlank

判断字符串是否为空字符串，全部空字符也为空。

来看 isBlank 的方法源码：

```java
public static boolean isBlank(CharSequence cs) {
    int strLen = length(cs);
    if (strLen == 0) {
        return true;
    } else {
        for(int i = 0; i < strLen; ++i) {
            if (!Charracter.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }
        return true;
    }
}
```

第 7 行，只要有一个字符不为空字符就返回 false，也就是说，如果全部都为空白字符就返回 true，也就是全部空白字符也为空。

如验证输入以下内容：

| 输入内容      | 是否为空 |
| ------------- | -------- |
| " "           | 是       |
| ""            | 是       |
| "java 面试题" | 否       |

这时候，如果用户输入" "等空白字符，这个方法也返回空了，这也是大部分业务场景下我们期望出现的结果。

##### isEmpty 和 isBlank 怎么选？

---

很明显，我们要判断一个字符串为空，绝大部分情况下“空白字符”也要为空的，严谨来说肯定要用 isBlank，虽然 isEmpty 也可以，但如果在最前端的接口不被拦截掉，请求到了后端的服务、数据库，就可能会造成压力，甚至是系统异常，这是完全可以避免的。

但万事也没有绝对，如果你的程序可以接受任意字符，包括“空白字符”，那就要选择 isEmpty，isBlank 会拦截所有空白字符，就达不到要求。

与之相对应的一般还有 isNotEmpty 和 isNotBlank，这都是对工具类的封装。

## 83、StringBuffer 和 StringBuilder 的区别？

先看看 StringBuffer 和 StringBuilder 的类结构吧：

![](/images/基础/83.png)

其实很简单，就是继承了一个抽象的字符串父类：`AbstractStringBuilder`。下面我们再来看看它们的三个区别。

##### 区别 1：线程安全

StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 synchronized 修饰。

###### StringBuffer 代码片段：

```java
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

##### 区别 2：缓冲区

###### StringBuffer 代码片段：

```java
private transient char[] toStringCache;

@Override
public syncronized String toString() {
    if (toStringCache == null) {
        toStringCache == Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
```

###### StringBuilder 代码片段：

```java
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
```

可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。

而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。

所以，缓冲区也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个 toString 方法仍然是同步的。

##### 区别 3：性能

既然 StringBuffer 是线程安全的，他的所有公开方法都是同步的，StringBuilder 是没有方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。

#### 总结

---

所以，StringBuffer 适用于在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。

## 84、StringBuilder，StringBuffer 默认容量大小？

![](/images/基础/84_1.png)

![](/images/基础/84_2.png)

默认都是 16 个字符。

![](/images/基础/84_3.png)

扩容大小都是为原来的 2 倍 + 2 个字符。

## 85、Java 中的 main 方法有什么用？

main 方法是 Java 程序的入口方法，在执行 Java 应用程序的时候会首先查找 main 方法，比如启动一个 Spring Boot 应用程序，就必须要有一个包含 main 方法的主类，如下所示：

```java
public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
```

## 86、怎么向 main 方法传递参数？

通过一个 String 数组：

```java
public static main(String[] args) {
    for (int i = 0; i < args.length; i++) {
        System.out.println("args[" + i + "]=" + args[i]);
    }
}
```

命令传递方式：

> java 面试题 酷酷酷酷

在开发工具中也可以传递：

![](/images/基础/86.png)

输出结果：

> args[0]=java
> args[1]=面试题
> args[2]=酷酷酷酷

## 87、不用 main 方法如何运行一个类？

不行，没有 main 方法不能运行 Java 类，main 方法是 Java 程序的入口。

> java 7 之前，可以通过使用静态初始化运行 Java 类，Java7+就行不通了。

## 88、Java 所有类的祖先类是哪个？

Java 所有类的祖先类是**java.lang.Object**类，Java 中每个类都是由它拓展而来，也会继承它的所有方法。

## 89、Object 类有哪些常用的方法？

Object 类所有方法如下：

![](/images/基础/89.png)

## 90、普通类和抽象类有什么区别？

##### 普通类和抽象类有什么区别：

（1）抽象类必须用 abstract 关键字标识，普通类则不用；

（2）抽象类可以包含 abstract 标识的抽象方法，抽象方法不用在抽象类中实现，普通类则不能包含抽象方法；

（3）抽象类是设计子类继承用的，不能直接通过 new 实例化，只能通过子类继承来实例化，或者通过匿名内部类进行实例化，普通类可以直接 new 实例化。

---

抽象类示例代码：

```java
public abstract class AbstractAccessLog {
    protected abstract void log(Log log) {

    }
}
```

## 91、静态内部类和普通内部类有什么区别？

先来看下面的示例程序，Test 类中分别创建一个静态内部类和普通内部类：

```java
public class Test {
    public static class StaticInnerClass {

    }

    public class InnerClass {

    }
}
```

然后在其它类中进行实例化：

```java
class InnerClassTest {
    public void test() {
        // 静态内部类
        Test.StaticInnerClass staticInnerClass = new Test.StaticInnerClass();

        // 普通内部类
        Test.InnerClass innerClass1 = new Test.InnerClass();
        Test.InnerClass innerClass2 = new Test().new InnerClass();
    }
}
```

编译结果出来：

![](/images/基础/91.png)

所以，静态内部类可以不依赖于外部类实例被实例化，而普通的内部类需要在外部类实例化后才能实例化。

## 92、静态方法可以直接调用非静态方法吗？

静态方法不可以直接调用非静态方法，静态方法调用非静态方法，需要先将对象实例化才能调用。

来看下面的示例：

```java
public static void main(String[] args) throws Exception {
    test();
}

public void test() {

}
```

![](/images/基础/92.png)

修改后：

```java
public static void main(String[] args) throws Exception {
    new Test().test();
}
```

## 93、静态变量和实例变量有什么区别？

**静态变量**，即被 static 修饰的变量，它属于类，但不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝，静态变量可以实现让多个对象共享内存。

**实例变量**，它属于某一对象实例，需要通过一个类的对象实例才能访问它。

```java
// 实例变量
private int id = 100;

// 静态变量
private static long maxId = 999;
```

## 94、内部类可以访问其他外部类的成员吗？

可以的，内部类可以访问创建它的外部类对象的成员，包括私有成员，来看下面的程序：

```java
public class Test {
    private int id = 100;

    public class InnerClass {
        /**
        * 访问外部类的私有成员
        */
        private void print() {
            System.out.println(id);
        }

        public static void main(String[] args) {
            Test.InnerClass innerClass = new Test().new InnerClass();
            innerClass.print();
        }
    }
}
```

结果输出：100

## 95、接口和抽象类有什么区别？

##### 区别 1：

首先抽象类是一个“类”，而接口只是一个“接口”，两者的概念和应用场景不一样，这也是抽象类和接口的主要区别。

##### 区别 2：

即使在 Java 8 中接口也能实现方法了，但却不能写构造方法，而在抽象类是可以写构造方法的，意味着抽象类是参与类的实例化过程的，而接口则不是。

##### 区别 3：

抽象类可以有自己的各种成员变量，并且可以通过自己的非抽象方法进行改变，而接口中的变量默认全是`public static final`修饰的，意味着都是常量，并且不能被自己和外部修改。

##### 区别 4：

接口可以实现多继承，而抽象类只能单继承。

下面我举两个例子：

```java
public class HashMap<K, V> extends AbstractMap<K, V> implements Map<K, V>, Cloneable, Serializable {
    ...
}
```

```java
public interface Connection extends Wrapper, AutoCloseable {
    ...
}
```

类与类只能单继承，而类与接口，接口与接口可以多继承。

![](/images/基础/95.png)

Java8 中的接口和抽象类的区别除了接口中可以写实现方法之外这点变化，其他的还是保持不变的。

既然接口可以写方法实现了，那么抽象类的存在貌似弱化了，因为类只能是单继承，耦合性不好，而接口可以多实现，可以灵活扩展，也不会增加类的耦合性。

## 96、抽象类必须要有抽象方法吗？

不需要，抽象类不一定非要有抽象方法，如以下示例代码：

```java
public abstract class User {
    public String getUserName () {
        return "java面试题";
    }
}
```

抽象类没有抽象方法也可以正常运行。

## 97、抽象类能使用 final 修饰吗？

**abstract**不能和**final**一起使用。

定义抽象类就是让其它类继承的，如果把一个类定义为 final 则表示该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。

如果这样定义，在开发工具中也会提示编译错误：

![](/images/基础/97.png)

抽象方法也是一样的道理，抽象方法也不能和 final 一起使用。

## 98、抽象类是否可以继承具体类？

抽象类可以继承普通类，也可以继承抽象类，来看 Spring 中的应用。

抽象类继承抽象类：

```java
public abstract class AbstractBeanFactoryAwareAdvisingPostProcessor extends AbstractAdvisingBeanPostProcessor implements BeanFactoryAware {
    ...
}
```

抽象类继承普通类：

```java
public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {
    ...
}
```

## 99、抽象类是否可以实现接口？

抽象类可以实现接口，来看一个 Spring 中的应用：

```java
public abstract class AbstractBeanFactoryAwareAdvisingPostProcessor extends AbstractAdvisingBeanPostProcessor implements BeanFactoryAware {
    ...
}
```

## 100、如何判断一个对象是某类、接口的实例？

使用**instanceOf**关键字，比如有以下测试类：

> User：用户基类
>
> PrivateUser：私人用户子类，继承 User 类

判断方式如下：

```java
public static void main(String[] args) {
    PrivateUser privateUser = new PrivateUser();

    // true
    boolean result1 = privateUser instanceOf PrivateUser;

    // false
    boolean result2 = privateUser instanceOf User;
}
```

## 101、如何判断两个类或者接口之间的派生关系？

使用类的**isAssignableFrom**方法，如果当前类与指定类是否相同，或者当前类是指定类的基类或接口，则返回 true，否则返回 false。

比如有以下测试类：

> User：用户基类
>
> PrivateUser：私人用户子类，继承 User 类

判断方式如下：

```java
public static void main(String[] args) {
    // true
    boolean result1 = User.class.isAssignableFrom(PrivateUser.class);

    // false
    boolean result1 = PrivateUser.class.isAssignableFrom(User.class);
}
```

User 是 PrivateUser 的父类，所以返回 true，反过来则是 false。

## 102、Java 创建对象，除了 new 关键字，你还知道哪些？

> 这里介绍创建对象的 6 种方式

假设有个女朋友类：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
class GirlFriend {
    private String name;
}
```

注解使用的是 Lombok 框架注解，方便快速开发。

##### 方法 1：new 一个对象

没对象就 new 一个吧，没错，使用 new 关键字，这也是 Java 创建对象最简单直接的方式了。

示例代码：

```java
@Test
public void girlFriend1() {
    GirlFriend girlFriend = new GirlFriend("new一个对象");
    System.out.println(girlFriend);
}
```

输出结果：

> GirlFriend(name=new 一个对象)

##### 方法 2：克隆一个对象

朋友有女朋友，你没有，如果可以，把别人的女朋友克隆一个吧？

让女朋友类先实现 Cloneable 接口，并且实现其 clone()方法：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
class GirlFriend implements Cloneable {
    private String name;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

> 注意：这里演示默认使用的是浅拷贝，即只可隆基本类型的字段，引用类型的需要再重写 clone()方法手动赋下引用字段的值。

现在克隆一个对象，示例代码：

```java
@Test
public void girlFriend2() throws CloneNotSupportedException {
    GirlFriend girlFriend1 = new GirlFriend("克隆一个对象");
    GirlFriend girlFriend2 = （GirlFriend）girlFriend1.clone();
    System.out.println(girlFriend2);
}
```

> GirlFriend(name=克隆一个对象)

使用克隆的好处就是可以快速创建一个和原对象值一样的对象，对象的字段值一样，但是两个不同的引用。

##### 方法 3：类派发一个对象（反射）

直接使用女朋友类派发一个吧：

```java
@Test
public void girlFriend3() throws InstantiationException {
    GirlFriend girlFriend = GirlFriend.class.newInstance();
    girlFriend.setName("类派发一个对象");
    System.out.println(girlFriend);
}
```

输出结果：

> GirlFriend(name=类派发一个对象)

##### 方法 4：动态加载一个对象（反射）

知道女朋友类在哪里（类全路径），但却没有被加载，那就反射一个对象吧：

```java
@Test
public void girlFriend4() throws InstantiationException {
    GirlFriend girlFriend = (GirlFriend) Class.forName("cn.com.slq.GirlFriend").newInstance();
    girlFriend.setName("反射一个对象");
    System.out.println(girlFriend);
}
```

输出结果：

> GirlFriend(name=反射一个对象)

##### 方法 5：构造一个对象（反射）

知道女朋友类的构造，就可以调用构造器构造一个对象：

```java
@Test
public void girlFriend5() throws NoSuchMethodException {
    GirlFriend girlFriend = GirlFriend.class.getConstructor().newInstance();
    girlFriend.setName("构造一个对象");
    System.out.println(girlFriend);

}
```

输出结果：

> GirlFriend(name=构造一个对象)

##### 方法 6：反序列化一个对象

这个和克隆的作用类似，加入以前序列化（保存）了一个女朋友在磁盘上，现在就可以反序列化出来。

首先让女朋友可序列化，实现 Serializable 接口：

```java
@Data
@NoArgsConstructor
@AllArgsCOnstructor
class GirlFriend implements Cloneable, Serializable {
    private static final long serialVersionUID = 1L;

    private String name;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

序列化/反序列化对象示例代码：

```java
@Test
public void girlFriend6() throws IOException, ClassNotFoundException {
    GirlFriend girlFriend1 = new GirlFriend("反序列化一个对象");

    //序列化一个女朋友
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("gf.obj"));
    ObjectOutputStream.writeObject(girlFriend1);
    ObjectOutputStream.close();

    // 反序列化出来
    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("gf.obj"));
    GirlFriend girlFriend2 = (GirlFriend) objectInputStream.readObject();
    ObjectInputStream.close();

    System.out.println(girlFriend2);
}
```

输出结果：

> GirlFriend(name=反序列化一个对象)

## 103、Java 怎么生成随机数？

##### 1、Math.random

它只能生成伪随机浮点数（double），需要进行转换才能生成其他类型的随机数，它是线程安全的。

##### 2、java.util.Random

它提供了许多随机数生成选项，包括不同类型的随机数和种子设置，线程安全，但是多线程并发使用同一个实例性能不佳，它适用于并发量不高的或者单线程环境。

##### 3、java.util.concurrent.ThreadLocalRandom

它也提供了各种随机数生成选项，是多线程环境下的首选，每个线程都有自己的生成器，无需同步操作。

---

另外，推荐使用一些第三方开源工具包，没有必要重复造轮子，比如 Apache 的 commons-lang3 开发工具包中的两个工具类：

- RandomUtils
- RandomStringUtils

## 104、equals 和 hashCode 的区别和联系？

关于**hashCode**和**equals**方法是有一些常规协定：

1、两个对象用 equals()比较返回 true，那么两个对象的 hashCode()方法必须返回相同的结果。所以，如果重写 equals()方法，则必须重写 hashCode()方法，如果不重写，在 Java 中（比如：HashMap）会产生逻辑错误。

2、两个对象用 equals()比较返回 false，不要求 hashCode()方法也一定返回不同的值，避免 hash 冲突，以提高哈希表性能。

举个例子：

> 可以把`equals`比喻为判断两本书的内容是否完全相同，而`hashCOde`就像是每本书的 ISBN 号。

如果两本书内容完全一样（`equals`返回`true`），那么它们的 ISBN（`hashCode`的值）也应该是一样的。这样，在图书馆（类似 HashMap）中就能根据 ISBN 快速找到相应的书。

如果两本书内容不完全一样（`equals`返回 false），理论上它们的 ISBN（`hashCode`的值）应该是不一样的，如果 ISBN 一样（`hashCode`的值），说明冲突了（`hashCode`冲突），但不影响根据 ISBN 来找书，只是会慢一点。

## 105、两个对象的 equals 方法相等，hashCode 方法也会相等吗？

答案：**不一定，但是，严格意义上必须相等！！！**

> 根据 Java 通用约定：
>
> 两个对象 equals 相等，则它们的 hashCode 必须相等，反过来则不需要相同。

也就是说，重写了一个类的 equals 方法之后，必须要重写其 hashCode 方法，不然会出现各种潜在的问题或危害。

## 106、两个对象的 hashCode 方法相等，equals 方法也会相等吗？

答案：**不一定。**

> 根据 Java 通用约定：
>
> 两个对象 equals 相等，则它们的 hashCode 必须相等，反过来则不需要相同。

因为对象的 hashCode 可能存在冲突的情况，即多个对象对应同一个 hashCode，这在 Java 规范中是允许的，但是如果重写了 equals 方法，比较的则是对象的值，这时两个对象 equals 比较就可能不相同。

## 107、为什么重写 equals 就要重写 hashCode？

**如果只重写了对象的 equals 方法而没有重写 hashCode 方法的话，就会造成对象 equals 相等而 hashCode 不相等。**

而 Hash\*相关的集合都是基于 Hash 表来实现的，比如 HashMap 的底层数据结构就是以数组+链表为基础的，其中的关键是数组索引下标的处理，数组的索引下标是根据传入的元素 hashCode 方法来决定的

**在 hashCode 相等的情况下：**

- 如果数组索引位置上已经有值了，值相等则进行覆盖，若不相等则加入到对应的链表中；
- 如果数组索引位置上没有值，则直接插入；

所以，如果多个 equals 相等的对象，而它们的 hashCode 不相等，它们就会不断插入到数组中，而不会进行覆盖，由此会带来 Hash\*相关的集合不能正常工作。

> 注意事项：
>
> 重写 equals 就要重写 hashCode 是 Java 编程的共识和规范。

## 108、Math.round(1.5)等于多少？

![](/images/基础/108.png)

答案：2。

因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整。

## 109、Math.round(-1.5)等于多少？

![](/images/基础/109.png)

答案：-1。

因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。

## 110、什么是泛型？

JDK1.5 开始引入泛型，泛型提供了编译时类型安全检测机制，可以在编译时检测到非法的类型。

泛型的本质就是参数化类型，可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

如：集合类支持泛型，如果添加不符合的元素类型则会编译报错：

![](/images/基础/110.png)

如上代码指定了泛型为 String 类型，添加其他类型的就会编译报错。

## 111、Java 泛型中的 T、R、K、V、E 是什么？

常用的泛型含义如下表所示：

| 泛型 | 说明               |
| ---- | ------------------ |
| T    | Type（类型）       |
| R    | Result（结果）     |
| K    | Key（键）          |
| V    | Value（值）        |
| E    | Element（元素）    |
| N    | Number（数字）     |
| ?    | 通配符，不确定类型 |

## 112、Java 有没有 goto 关键字？

goto 是 Java 中的保留字，在目前版本的 Java 中还没有被使用，保留关键字不能用作任何标识符。

![](/images/基础/112.png)

## 113、Java 中有没有指针的概念？

Java 中并没有指针的概念，指针是 C 和 C++里面的概念，在 Java 中，指针已经被其他语法所取代，学习起来更加轻松。

## 114、Java 中的 classpath 环境变量作用？

class = class + path，即 Java 源文件编译后的.class 文件的路径。

设置 classpath 环境变量的作用是用于指定类的搜索路径，JVM 在运行时就是通过 classpath 环境变量来寻找.class 类文件，所以一般建议把当前应用程序的目录（.）设置为 classpath 环境变量。

## 115、怎么设置 classpath 环境变量？

Linux 设置 CLASSPATH 环境变量：

> export CLASSPATH = .

查看 classpath：

> echo $CLASSPATH

一般使用命令行编译运行需要指定 classpath，在开发工具中 classpath 不用自己指定，由工具指定编译后的目录，它会自动搜索，如在 IDEA 中指定：

![](/images/基础/115.png)

## 116、判断两个数字是否相等

以下代码的输出结果是？

```java
public class Test {
    public static void main(String[] args) {
        Integer n1 = 123;
        Integer n2 = 123;
        System.out.println(n1 == n2);

        Integer n3 = 128;
        Integer n4 = 128;
        System.out.println(n3 == n4);
    }
}
```

答案如下：

> true
>
> false

## 117、Java 怎么获取当前系统时间戳？

在 Java 中可以使用以下方式来获取系统时间戳。

##### 1、使用 System 类（最常用）

```java
long timestamp = System.currentTimeMillis();
```

这也是最常用的获取时间戳的方法。

##### 2、使用 Date 类

```java
Date date = new Date();
long timestamp = date.getTime();
```

##### 3、使用 Calendar 类

```java
Calendar calendar = Calendar.getInstance();
long timestamp = calendar.getTimeInMillis();
```

##### 4、使用 Instant 类（Java8+）

这是在 Java8+版本中引入的新的日期时间 API，这个`Instant.now()`方法返回当前的时间戳，然后使用`toEpochMilli()`方法将时间戳转换为毫秒数。

> 以上几种方法都可以得到当前系统的时间戳，大家可以根据需要选择合适的方式来获取时间戳。
>
> 推荐使用第 1、4 种方法，第一种无疑是最常用的，如果是 Java8+，也可以考虑使用第四种 Instant 类，它可以获得比第一种更强大的时间单位转换等功能。

## 118、Java 怎么统计一段代码的耗时？

1、使用 System.currentTimeMillis()方法获取当前时间，前后再相减就是总耗时：

```java
@Test
public void jdkWasteTime() throws InterruptedException {
    long start System.currentTimeMillis();
    Thread.sleep(3000);
    System.out.println("耗时：%dms."， System.currentTimeMillis() - start);
}
```

2、使用**StopWatch**工具类，这个在 Spring/Apache commons-lang3 包中都有定义，来看一个简单的使用 commons-lang3 包中的 StopWatch 使用例子：

```java
// 创建一个StopWatch实例并开始计时
StopWatch sw = StopWatch.createStarted();

 // 休眠1秒
Thread.sleep(1000);

// 1002ms
System.out.println("耗时：%dms.\n", sw.getTime());
```
