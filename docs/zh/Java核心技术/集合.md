## 1、说说常见的集合有哪些？

**Java 所有集合框架的顶级接口有两大类：**

**Collection 接口和 Map 接口。**

Collection 接口的子接口包括 List 接口和 Set 接口；

- List 接口的实现类主要有：ArrayList、LinkedList、Stack、Vector...
- Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet...

Map 接口的实现类主要有：

- HashMap
- TreeMap
- HashTable
- ConcurrentHashMap
- ...

## 2、常用的并发集合有哪些？

常用的并发集合有：

- ConcurrentHashMap
- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- CopyOnWriteArrayList
- CopyOnWriteArraySet
- ...

并发集合位于 java.util.concurrent 包下，JDK1.5 之后才有的。

## 3、那些集合类可对元素随机访问？

随机访问接口：java.util.RandomAccess

![](/images/集合/3_1.png)

它是 List 集合使用的标记接口，表示它们可以支持快速的随机访问，该接口的主要目的是允许算法在随机或顺序访问列表是改变其行为，已提供良好的性能。

实现了该接口的常用 List 集合如类结构图所示：

![](/images/集合/3_2.png)

如 ArrayList 源码所示：

![](/images/集合/3_3.png)

实现了该接口的集合，推荐使用`for (int i = 0, n = list.size(); i < n; i++)`方式替代`for (Iterator i = list.iterator(); i.hasNext();)`，前者要比后者遍历快。

## 4、Comparable 和 Comparator 接口的区别？

Comparable 是排序接口，如类实现了 Comparable 接口，并实现其排序方法，就表示该类支持排序，相当于是一个内部排序器。

假如 User 类实现了 Comparable 接口：

```java
Collections.sort(userList);
```

Comparator 是比较器接口，可以新建多个 Comparator 接口的实现类实现自定义排序，相当于一个外部排序器。

```java
Collections.sort(userList, new Comparator<User>() {
    ...
})
```

## 5、Collection 和 Collections 的区别？

Collection 是一个集合接口，是 Set、List 集合类的一个顶级接口：

![](/images/集合/5.png)

Collection 则是集合类的一个工具类，提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

## 6、Enumeration 和 Iterator 接口的区别？

##### Enumeration 和 Iterator 接口的区别：

（1）Enumeration 只能读取集合的数据，而不能删除，Iterator 可以读取、删除数据，如它们的方法所示：

![](/images/集合/6_1.png)

（2）Iterator 支持 fail-fast 错误机制，而 Enumeration 不支持；

（3）在 Java 集合框架中，Iterator 接口已经取代了 Enumeration 接口：

![](/images/集合/6_2.png)

## 7、集合使用泛型有什么优点？

##### 集合使用泛型的几个优点：

1、强制集合只能容纳指定类型的对象，避免了在运行时出现 ClassCastException 类转换异常，因为添加了不是指定类型的元素时，在编译期间就会报错；

2、代码更整洁，使用时不需要显式转换和 instanceOf 操作符，取出来的就是指定类型的对象；

3、优化了 JVM 运行时环境，因为它不会产生类型检查的字节码指令；

## 8、List、Set、Map 之间的区别是什么？

List、Set、Map 的区别主要体现在数据结构、元素是否有序、元素是否可重复、键值是否为 null 等。

三个接口的区别如下面思维导图所示：

![](/images/集合/8.png)

## 9、描述一下常用的 Collection 集合的类结构？

如下图所示，我列出了常用的 Collection 集合接口和实现类：

![](/images/集合/9.png)

## 10、描述一下常用的 Map 集合的类结构？

如下图所示，我列出了常用的 Map 集合和实现类：

![](/images/集合/10.png)

## 11、为什么 Map 接口不继承 Collection 接口？

因为 Map 继承 Collection 毫无意义，Collection 集合中定义的是一组对象，而 Map 提供的是包含 key-value 键值对形式的集合，而不是”**一组对象**“的概念，所以它不适用 Collection 的定义。

## 12、常用的线程安全的 Map 有哪些？

下面来总结下线程安全的 Map。

##### 1、Hashtable

> private Map<String, Object> map = new Hashtable<>();

来看看 Hashtable 的源码

![](/images/集合/12_1.png)

Hashtable 中的所有关键方法都被 synchronized 关键字修饰，说明它们是方法级别阻塞的，它们占用共享资源锁，所以导致同时只能一个线程操作，不能同时执行，所以这种同步的集合效率非常低，一般不建议使用这个集合。

##### 2、SynchronizedMap

> private Map<String, Object> map = Collections.synchronizedMap(new HashMap<String, Object>());

这种是直接使用工具类里面的方法创建 SynchronizedMap，把传入进行的 HashMap 对象进行了包装同步而已，来看看它的源码：

![](/images/集合/12_2.png)

这个同步方式实现也比较简单，看出 SynchronizedMap 的实现方式是加了个对象锁，每次对 HashMap 的操作都要先获取这个 mutex 的对象锁才能进入，所以性能也不会比 Hashtable 好到哪里去，也不建议使用。

##### 3、ConcurrentHashMap - 推荐

> private Map<String, Object> map = new ConcurrentHashMap<>();

## 13、HashMap 与 Hashtable 的区别？

HashMap 和 Hashtable 是 Java 开发程序员必须要掌握的。

##### 1、线程安全

Hashtable 是线程安全的，HashMap 不是线程安全的。

来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。

```java
public synchronized V put(K key, V value);
public synchronized V get(Object key);
```

##### 2、性能优劣

既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。

如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。

##### 3、NULL

Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。

为什么 Hashtable 是不允许 KEY 和 VALUE 为 null，而 HashMap 则可以？

##### Hashtable put 方法逻辑：

```java
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?, ?> tab[] = table;
    int hash = key.hashCode();
    ...
}
```

HashMap hash 方法逻辑：

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。

##### 4、实现方式

Hashtable 的继承源码：

```java
public class Hashtable<K, V> extends Dictionary<K, V> implements Map<K, V>, Cloneable, java.io.Serializable
```

HashMap 的继承源码：

```java
public class HashMap<K, V> extends AbstractMap<K, V> implements Map<K, V>, Cloneable, Serializable
```

可以看出两者继承的类不一样，Hashtable 继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类。

Dictionary 是 JDK1.0 添加的，貌似没人用过这个。

##### 5、容量扩容

HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。

```java

```

当现有容量大于容量 \* 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。

##### 6、迭代器

HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。

所以，当其他线程改变了 HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。

###### 可以来看下这个区别的演示：

```java
public static void main(String[] args) {
    Map<String, String> hashtable = new Hashtable<>();
    hashtable.put("t1", "1");
    hashtable.put("t2", "2");
    hashtable.put("t3", "3");

    Enumeration<Map.Entry<String, String>> iterator1 = (Enumeration<Map.Entry<String, String>>) hashtable.entrySet().iterator();
    hashtable.remove(iterator1.nextElement().getKey());
    while (iterator1.hasMoreElements()) {
        System.out.println(iterator1.nextElement());
    }

    Map<String, String> hashMap = new HashMap<>();
    hashMap.put("h1", "1");
    hashMap.put("h2", "2");
    hashMap.put("h3", "3");

    Iterator<Map.Entry<String, String>> iterator2 = hashMap.entrySet().iterator();
    hashMap.remove(iterator2.next().getKey());
    while (iterator2.hasNext()) {
        System.out.println(iterator2.next());
    }
}
```

输出信息：

```
t2=2
t1=1
Exception in rhread "main" java.util.ConcurrentModificationException
at java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)
at java.util.HashMap$EntryIterator.next(HashMap.java:1476)
at java.util.HashMap$EntryIterator.next(HashMap.java:1474)
at cn.javastack.Test.main(Test.java:37)

```

## 14、HashMap 和 TreeMap 怎么选？

对于一般的 K-V 键值对存储和操作，HashMap 是 Map 接口最优的选择。

如果需要对 Map 中的 K-V 进行排序，TreeMap 则是最优的选择，因为 HashMap 本身不能支持排序。

## 15、HashMap 的数据结构是什么？

![](/images/集合/15.png)

JDK 1.7：数组 + 链表

JDK 1.8：数组 + 链表 + 红黑树

## 16、HashMap 键可以使用对象吗？

HashMap 键是可以使用对象的，如源码所示：

![](/images/集合/16.png)

K-V 是泛型，所以，它们可以是任意类型。

使用对象作为 Key 时，需要重写 equals 和 hashCode 方法，这是正确使用 HashMap 的基础，避免因 hashCode 问题导致集合出现混乱等问题。

## 17、HashMap 键可以使用可变对象吗？

可以，但需要保证该对象的属性发生改变时，不会改变对象的 hashCode 值，如果 hashCode 的值发生了改变，可能 HashMap 再也匹配不到之前那个原始对象了。。。

## 18、HashMap 在 JDK 8 中有哪些改变？

##### HashMap 在 JDK8 中的改变：

（1）在 JDK8 中，如果某个链表的长度 >= 8，并且数组容量 >= 64，那么链表将转换为红黑树。（桶的数量必须 >= 64，小于 64 的时候只会扩容）

（2）当发生 hash 碰撞时，JDK7 会在链表的头部插入，而 JDK8 会在链表的尾部插入；

（3）在 JDK8 中，Entry 类被 Node 类替代：

![](/images/集合/18_1.png)

![](/images/集合/18_2.png)

## 19、JDK 8 HashMap 为啥要引入红黑树？

当 HashMap 的 key 冲突过多时，比如我们使用了不好的 hash 算法，导致 key 冲突率极高，我们都知道链表的查找性能很差，**所以引入红黑树就是为了优化 HashMap 集合的查询性能。**

![](/images/集合/19.png)

## 20、JDK 8 HashMap 为什么引入红黑树，而不是 AVL 树？

> 在 JDK 1.8 中，HashMap 内部使用了**红黑树来优化哈希桶中链表过长**的情况。

为什么没有选择 AVL 树？这是因为红黑树相对于 AVL 树，具有以下几个优点。

##### 1、红黑树插入和删除性能相对较好

红黑树的插入和删除操作相对于 AVL 树而言，红黑树的平衡调整次数较少，能够更快地完成旋转操作，相对于 AVL 树而言，性能更优。

但是在查询操作比较频繁地情况下，AVL 树的查询性能更好，因为 AVL 树是更加严格的平衡树，所以查询时需要比较的次数更少。

##### 2、红黑树实现更加简单

相对于 AVL 树而言，红黑树的实现更加简单，不需要维护节点的平衡因子，代码实现也更加简洁。

##### 3、红黑树占用空间更少

由于 AVL 树需要维护节点的平衡因子，高度差会比较小，这会导致空间浪费，而红黑树不需要维护节点的平衡因子，所以高度差相对较小，占用的空间也更少。

## 21、JDK 8 HashMap 什么情况会用红黑树？

![](/images/集合/21.png)

**如果 HashMap 某个链表的长度 >= 8，并且扩容后的数组长度 >= 64，就会将链表转换为红黑树，如源码所示：**

```java
static final int TREEIFY_THRESHOLD = 8;

static final int MIN_TREEIFY_CAPACITY = 64;

final V putval(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<k,V> e; K k;
        if (p.hash == hash & ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).puttreeval(this, tab, hash, key, value);
        else {
            for (int bincount = 0;  ++bincount) {
                if ((e = p.next) == null) {
                    // 最后一个节点为nuLL时插入新元素
                    p.next = newNode(hash, key, value, null);

                    //此时转红黑树（链表>=8)
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldvalue = e.value;
            if (!onlyIfAbsent || oldvalue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldvalue;
        }
    }
     ++modcount;
     if (++size > threshold)
    resize();
    afterNodeinsertion(evict);
    return null;
}

final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<k,V> e;
    //数组<64，扩容，eLse f >=64 转红黑树
    if (tab == null Il (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,v> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            t1 = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

TREEIFY_THRESHOLD 为什么要-1，因为 binCount 索引是从 O 开始的，所以当 binCount =7 时转红黑树，因为 binCount 从 O 开始，所以此时链表的彻底应该是 8 个？

不对，因为，当遍历到最后一个元素的下个节点为 null 时，又通过 p.next = newNode() 插入了一个新元素，所以此时链接的真实长度是 9，所以是>= 8 才转的红黑树。

确实是 8，另外，如源码所示，tab.length 指的是 HashMap 数组容量大小，而不是实际存储的元素长度，所以当某个链表长度达到 8，然后：

- 数组长度（容量）达到 64，则会转红黑树；
- 数组长度（容量）< 64，则只会扩容，而不会转红黑树。

##### 如果 HashMap 某个红黑树的长度<=6，又会将红黑树转换为链表，如源码所示：

```java
static final int UNTREEIFY_THRESHOLD = 6;

final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
    if (loHead != null) {
        //长度<=6取消红黑树
        if (1c <= UNTREEIFY_THRESHOLD)
            tab[index] = loHead.untreeify(map);
        else {
            tab[index] = loHead;
            if (hiHead != null) // (else is already treeified)
                loHead.treeify(tab);
        }
    }

    if (hiHead != null) {
        //长度<=6取消红黑树
        if (hc <= UNTREEIFY_THRESHOLD)
            tab[index + bit] = hiHead.untreeify(map);
        else {
            tab[index + bit] = hiHead;
            if (loHead != null)
                hiHead.treeify(tab);
        }
    }
}
```

## 22、JDK8HashMap 链表转红黑树，为啥是链表长度达到 8 才转？为什么是 8？

来看 HashMap 源码注释：

![](/images/集合/22.jpg)

理想情况下，链表长度符合泊松分布，链表长度很难达到 8，树节点很少使用。

为什么是 8，是根据概率统计而选择的，当长度为 8 的时候，概率仅为 0.00000006，这是一个小于干万分之一的概率，此时的链表性能已经很差了。

所以在这种比较极端罕见的情况下，才会把链表转变为红黑树，因为链表转为红黑树也是需消耗时间、空间的，为了保证查询的性能。

## 23、JDK 8 HashMap 为啥不直接用红黑树？

来看 HashMap 源码注释：

![](/images/集合/23.jpg)

因为树节点所占用的空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。

也就是说，最开始使用链表的时候，链表是比较短的，空间占用也是比较少的，查询性能都差不多，但是当链表越来越长，链表查询越来越慢，为了保证查询效率，这时候才会舍弃链表而使用红黑树，以空间换时间。

所以就没有必要一开始就用红黑树，另外，链表较长的情况非常少见，一开始就使用红黑树反而会导致所有的情况都会占用比链表大 2 倍的空间，适得其反，这也是一种平衡的策略。

## 24、HashMap 的 put 方法逻辑？

HashMap 底层是 hash 数组和链表、红黑树（JDK 8+）实现的，数组中的每个元素默认都是链表，由 Node 内部类实现 Map.Entry 接口来实现，HashMap 的 put 方法主要看 putVal 方法相关的源码。

大概流程如以下流程图所示：

![](/images/集合/24.jpg)

##### 源码如下（JDK8）：

```java
public V put(k key, V value) {
    // 1） 调用 putvaL方法将键值对插入到 HashMap 中
    return putval(hash(key), key, value, false, true);
}

final int hash(object key) {
    int h;
    //2）计算键的哈希值，如果键为nuLL，则哈希值为 0
    return (key == null) ? 0 : (h = key.hashcode()) ^ (h >>> 16);
}

final V putval(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<k,V>[] tab;
    Node<K,V> p;
    int n, i;
    //3）根据哈希值找到键值对应的位置
    //如果 HashMap 的 tabLe 数组为 nuLL 或长度为 O，则需要进行初始化
    if ((tab = table) == null Il (n = tab.length) == 0)
        n = (tab = resize()).length;
    //计算键值对在tabLe 数组中的位置，如果该位置上没有其他键值对，则直接插入键值对
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e;
        K k;
        //4）如果该位置已经存在其他键值对，则需要进行链表或红黑树的插入操作。
        //如果该位置上已经存在相同的键，则直接用新的值替换旧的值
        if (p.hash == hash && ((k = p.key) == key || (key I= null && key.equals(k))))
            e = p;
        // 如果该位置上存在 TreeNode节点，则将键值对插入到红黑树中
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).puttreeval(this, tab, hash, key, value);
        //如果该位置上存在链表，则遍历链表找到合适的位置插入键值对
        else {
            for (int bincount = e;  ++bincount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //如果链表长度超过了闻值，则需要将链表转化为红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyein(tab, hash);
                    break;
                }
                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p= e;
      }
    }
    //5）如果键已经存在，则用新的值替换旧的值
        if (e I= null) {
          // existing mapping for key
            V oldvalue = e.value;
            if (!onlyIfAbsent || oldvalue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldvalue;
        }
  }
  //6）插入成功，增加modcount和size，如果size超过了闻值，则需要进行扩容
    ++modcount;
    if (++size > threshold)
    resize();
  afterNodeInsertion(evict);
  return null;
}
```

##### 大概源码流程如下：

1）调用 putVal 方法将键值对插入到 HashMap 中。

2）计算键的哈希值，如果键为 null，则哈希值为 0

3）根据哈希值找到键值对应的位置：

- 果 HashMap 的 table 数组为 null 或长度为 O，则需要进行初始化；
- 计算键值对在 table 数组中的位置，如果该位置上没有其他键值对，则直接插入键值对；

4）如果该位置已经存在其他键值对，则需要进行链表或红黑树的插入操作：

- 果该位置上已经存在相同的键，则直接用新的值替换旧的值；
- 如果该位置上存在 TreeNode 节点，则将键值对插入到红黑树中；
- 果该位置上存在链表，则遍历链表找到合适的位置插入键值对；
- 果链表长度超过了阈值，则需要将链表转化为红黑树；

5）如果键已经存在，则用新的值替换旧的值。

6）插入成功，增加 modCount 和 size，如果 size 超过了阈值，则需要进行扩容

## 25、HashMap 的 get 方法逻辑？

HashMap#get 方法的主要源码如下（JDK 8）:

```java
public V get(object key) {
    Node<K,V> e;
    //1）首先调用getNode方法查找指定键的节点。
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<k,V>[] tab;
    Node<K,V> first, e;
    int n;
    K k;
    //2）根据哈希值和键找到对应的节点。
    //如果tabLe数组不为nuLL并且长度不为O，则从tabLe中的对应位置开始查找
    if ((tab = table) != null && (n = tab.length) > θ && (first = tab[(n - 1) & hash]) != null) {
        //如果第一个节点就是要查找的节点，则直接返回第一个节点
        if (first.hash == hash && ((k = first.key) == key || (key I= null && key.equals(k))))
            return first;
        //如果第一个节点不是要查找的节点，则从链表/红黑树中查找
        if ((e = first.next) l= null) {
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash && ((k = e.key) -- key || (key != null && key.equals(k)))
                    return e;
        } while ((e = e.next) != null);
      }
    }
    //3）如果不存在要查找的键，则返回null
  return null;
}
```

##### 大概源码流程如下：

1）首先调用 getNode 方法查找指定键的节点。

2）根据哈希值和键找到对应的节点：

- 如果 table 数组不为 null 并且长度不为 O，则从 table 中的对应位置开始查找；
- 如果第一个节点就是要查找的节点，则直接返回第一个节点；
- 果第一个节点不是要查找的节点，则从链表/红黑树中查找；
- 如果存在要查找的键，则返回对应的值；

3）以下几种情况返回 null：

- table 数组为 null 或者长度为 0
- table 数组中不存在要查找的键；

## 26、HashMap 是线程安全的吗？

用的最多的 Map 集合就是 HashMap 了，它是线程不安全的，注释已经说得很清楚了：

![](/images/集合/26_1.jpg)

也就是说所有方法都是非 syncrhonized 的，如果多个线程并发操作同一个 HashMap，就存在线程安全的问题了，如下图所示：

![](/images/集合/26_2.jpg)

另外，HashMap 使用的是链表结构来处理 Hash 冲突的，那么就很容易造成链表数据丢失，或者形成闭合的链路，严重的会产生死循环等问题，导致 CPU 消耗 100%。

## 27、HashMap 是怎么解决 hash 冲突的？

其实问的就是 HashMap 它的数据结构，不同的 JDK 版本的数据结构，其解决 hash 冲突的方式不一样，如下面的 HashMap 数据结构所示：

![](/images/集合/27.jpg)

哈希冲突即多个对象的 hashCode 一样，造成 Hash 冲突，当发生冲突时，它们会放到当前数组索引位置的链表中，在 JDK 8+中，如果链表过长（>= 8）并且数组长度>= 64 还会转换为红黑树。

## 28、HashMap 是怎么扩容的？

##### HashMap 的扩容是由 capacity、loadFactor、threshold 等参数值决定的：

- **cpacity**：table 数组容量大小，默认容量是 16，可以自定义容量，最大限制是 1<<30；
- **loadFactor**：负载因子，默认值是 0.75，用来计算扩容阈值 threshold，决定 HashMap 数组需要扩容的时机；
- **threshold**：扩容阈值，只有当 table 数组实际元素的长度超过扩容阈值时，table 才会扩容；

扩容规则：

##### 1、正常扩容

比如 table 数组默认容量大小为 16，负载因子默认为 0.75 时，threshold 扩容阈值就是 12，此时当数组实际大小>12 时就会扩容。

![](/images/集合/28_1.jpg)

##### 2、Hash 冲突时扩容

当链表长度达到 8 时，此时数组默认容量大小为 16，因为数组容量<64 时只会扩容，所以此时还不会转红黑树，链表一旦达到 8，如果数组<64 就会继续扩容。

> 此种扩容方式具体见《编程实现一个 hash 冲突的例子》

---

扩容时会调用 resize( 方法，将 table 数组长度变为原来的两倍，如以下源码所示：

![](./imags/集合/28_2.jpg)

使用了向左移 1 位的方式，即翻倍扩容。

> ##### 需要注意的是：
>
> 如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。

## 29、HashMap 是先插入元素还是先扩容？为什么这么设计？

答案是：**HashMap 是先插入，后扩容。**

具体可以看面试题《HashMap 的 put 方法逻辑？》源码分析最后一点。

##### 为什么要这样设计？

因为，先插入后扩容，不一定每次都会新增元素，而是有可能直接更新已有的元素值，然后直接返回了。而如果先扩容后插入元素，每次都会检测是否需要扩容，相对前者会多一步判断操作，相对会损耗性能。

所以，先插入元素，如果确定数组新增了元素导致占用了空间，此时再判断扩容是更合理的。

## 30、HashMap 有没有容量限制？

来看 HashMap 构造器源码：

![](/images/集合/30_1.jpg)

HashMap 最大容量为：

```java
static final int MAXIMUM_CAPACITY = 1<< 30;
```

![](/images/集合/30_2.jpg)

容量为 10 亿+。

## 31、HashMap 如何实现同步？

同步的 HashMap 有三种选择：

- 用 Collections.synchronizedMapO 方法；
- 使用 ConcurrentHashMap；
- 对操作 Map 的方法实现一个对象锁；

这三个选项之间的首选是使用 ConcurrentHashMap，因为它不需要锁定整个对象，性能更好。

## 32、HashMap 中的负载因子是什么？

HashMap 中的负载因子指的是 loadFactor 参数：

![](/images/集合/32.jpg)

负载因子用来计算 HashMap 的扩容阈值 threshold，决定 HashMap 数组需要扩容的时机，负载因子默认值为 0.75，在时间和空间成本之间提供了一个很好的折中方案。

具体使用可以见《HashMap 是怎么扩容的？》面试题。

## 33、HashMap 的负载因子为什么是 0.75？

来看 HashMap 的源码注释：

> As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehashoperations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will everoccur.

HashMap 的负载因子（load factor）默认设置为**0.75**，意味着哈希表容量达到 **75**% 时会触发扩容操作。这是在时间和空间成本之间提供了一个很好的权衡，这样可以确保哈希表不会过早地扩容，浪费内存，同时在大部分情况下也不会过度填充，导致性能下降。

##### 比如以下设置：

- 负载因子越大（如：1.0），表示容量满了才扩容，填满的元素就会越多，空间利用率就越高，但 Hash 冲突的机会也加大了；
- 负载因子越小（如：0.5），表示达到一半容量就扩容，填满的元素就会越少，空间利用率就越低，但 Hash 冲突的机会也减少了。

较高的值会减少内存开销，但会增加性能开销。相反，较低的值会增加内存开销，但会减少性能开销。

所以，默认值**0.75**提供了一个很好的选择，这是为了在**平衡内存使用和性能**之间取得较好的权衡。

## 34、HashMap 的负载因子设置为多少合适？

HashMap 的负载因子默认值为 **0.75**，但这个值是可以根据具体应用场景和性能需求进行调整的，设置多少合适可以参考：

- 如果更注重性能，可以降低负载因子，但可能会消耗更多内存；
- 如果更注重内存效率，可以增加负载因子，但可能会降低性能。

所以，选择合适的负载因子需要根据具体应用的需求来平衡内存和性能。

## 35、编程实现删除 HashMap 集合中的元素

##### 假设有以下数据：

```java
public Map<string, String> initMap = new HashMap<>() {{
    put("useri", "张三");
    put("user2", "李四");
    put("user3", "张三");
    put("user4", "李四");
    put("users", "王五");
    put("user6"，"赵六");
    put("user7", "李四");
    put("user8", "王五");
}};
```

> 一般删除 HashMap 集合中的元素，如果知道具体的 Key，并且需要根据 Key 删除元素，使用 remove 方法就可以了。
>
> ##### 但是如何根据 Value 删除 HashMap 集合中的元素呢？这才是你必须掌握的技巧！

##### 1、使用 for 循环删除

```java
@Test
public void removei() {
    Set<Map.Entry<String, String>> entries = new CopyonwriteArraySet<>(initMap.entryset());
    for (Map.Entry<string, String> entry : entries) {
        if ("张三".equals(entry.getvalue())) {
            initMap.remove(entry.getKey());
        }
    }
    System.out.printin(initMap);
}
```

输出结果：

> {user2=李四,user7=李四,user8=王五,user5=王五,user6=赵六，user4=李四}

使用 HashMap 中实现的 entrySet 方法获取元素的集合，然后再进行循环遍历，先根据 Value 值判断要删除的元素，然后再根据 Key 删除元素。增强的 for 循环底层使用的迭代器 Iterator，而 HashMap 是 fail-fast 类型的错误机制，所以遍历时删除元素会出现`java.util.ConcurrentModificationException`并发修改异常。

所以，这里使用了线程安全的 CopyOnWriteArraySet 封装了一层，避免出现并发修改异常，java.util.concurrent 包中的并发集合类都被设计为 fail-safe（安全失败）类型的，比如 CopyOnWrite\*、ConcerrentHashMap 集合，遍历过程中结构发生变更是安全的，不会抛出以上异常。

> ##### 需要注意的是：
>
> 虽然 CopyOnWriteArraySet 并发性能很好，但每次删除时都会复制一份同等集合，所以要考虑数据过多可能导致的内存消耗问题。

##### 2、使用 forEach 循环删除

```java
@Test
public void remove2() {
    ConcurrentHashMap<sString, String> map = new ConcurrentHashMap<>(initMap);map.forEach((k, v) -> {
        if ("张三".equals(v)) {
            map.remove(k);
        }
    });
    System.out.println(map);
}
```

输出结果：

> {user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}

使用 HashMap 自带的 forEach 循环删除指定值的元素，这里为什么使用线程安全的 ConcurrentHashMap 集合包装了一层，同样是为了避免并发修改异常。ConcurrentHashMap 在各版本中都使用了最优的锁设计方案，它的并发性能也是非常优异的。

##### 3、使用 Iterator 选代器删除

```java
@Test
public void remove3() {
    Iterator<Map.Entry<string, String>> iterator = initMap.entryset().iterator();
    while (iterator.hasNext()) {
        Map.Entry<string, String> entry = iterator.next();
        if ("张三".equals(entry.getvalue()) {
            iterator.remove();
        }
    }
    System.out.println(initMap);
}
```

输出结果：

> {user2=李四,user7=李四,user8=王五,user5=王五,user6=赵六,user4=李四}

这种方式即正常使用迭代器遍历删除，它不会发生并发修改异常。

> **需要注意的是：**
>
> 这种方法虽然不会发生并发修改异常，但 HashMap 并不是线程安全的，在迭代删除元素时，另一个线程可能会删除 HashMap 中的数据，这时使用迭代器删除同样会导致并发修改异常。
>
> 所以，要保证线程安全的删除，在创建迭代器之前，可以先用线程安全的 ConcurrentHashMap 集合包装一层。或者使用 synchronized 关键字锁住整个 Map。
>
> 如果没有多线程修改环境，可以不用考虑。

##### 4、使用 removelf 删除

```java
@Test
public void remove4() {
    initMap.entryset().removelf(entry -> "张三".equals(entry.getvalue()));
    System.out.printin(initMap);
}
```

输出结果：

> {user2=李四,user7=李四, user8=王五,user5=王五, user6=赵六, user4=李四}

使用 entrySet 的 removelf 删除，它底层使用的是迭代器：

```java
default boolean removeif(Predicate<? super E> filter) {
    objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

所以，它和方法 3 是一样的，只不过把条件写成了 Predicate 函数式接口而已。

> ##### 需要注意的是：
>
> removelf 虽然更方便了，但它仍然不是线程安全的，多线程场景参考方案同方法 3。

##### 5、使用 Stream 删除

```java
@Test
public void remove5() {
    Map<string, String> map = initMap.entryset().stream().filter(entry -> !"张三".equals(entry.getvalue()))
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getvalue));
    System.out.println(map);
}
```

输出结果：

> {user2=李四,user7=李四,user8=王五,user5=王五,user6=赵六, user4=李四}

利用 Stream 的 fiter 方法进行过滤，这个方法也十分简单，一行代码搞定。

**实际开发过程中，可能会使用不同的遍历方式，所以重点要考虑多线程场景，如果只是简单的删除元素，使用 removelf 和 Stream 过滤是最省事的。**

## 36、什么是 LinkedHashMap？

LinkedHashMap 是 HashMap 的一个实现类，如下面类结构图所示：

![](/images/集合/36_1.jpg)

LinkedHashMap 底层是一个数组+双向链表，根据元素的 hashCode 值来决定元素在数组中的存储位置，同时使用双向链表来保持元素的前后顺序，如下图所示：

![](/images/集合/36_2.jpg)

所以 LinkedHashMap 一般可用来保存需要维持某种前后顺序的数据，如插入顺序、访问顺序。

![](/images/集合/36_3.jpg)

accessOrder 的值为 true（访问顺序排序），默认为 false（插入顺序排序）。

## 37、Map 集合怎么按插入顺序排序？

Map 要按插入顺序、或者访问顺序排序，可以使用：LinkedHashMap，具体见《什么是 LinkedHashMap？》面试题。

## 38、Map 集合怎么按自然顺序排序？

Map 集合要按自然规则排序，可以使用：TreeMap，TreeMap 默认是按 key 自然排序。

## 39、Map 集合怎么按访问顺序排序？

Map 要按插入顺序、或者访问顺序排序，可以使用：LinkedHashMap，具体见《什么是 LinkedHashMap？》面试题。

## 40、Map 集合怎么按自定义规则排序？

一般有以下两种方案：

1）使用 TreeMap，可以构造一个自定义的 Comparator 比较器；

2）使用排序工具类：Collections.sort()；

## 41、TreeMap 的数据结构是什么？

如名称定义，TreeMap =Tree +Map，所以，它是树的数据结构：红黑树。

## 42、Hashtable 为什么不叫 HashTable？

> 什么是驼峰命名规则，来看下面的关键字：
>
> - HashMap
> - ArrayList
> - ConcurrentHashMap
>
> 简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。

当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？

我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。

原贴如下：

> https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized

![](/images/集合/42_1.jpg)

最佳答案是：

> Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.
>
> Which btw made Hashtable obsolete, so it should not be used in new code.
>
> Hope that helps.

意思就是：

> Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。
>
> 顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。

Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。

另外，关于《HashMap 和 Hashtable 的 6 个区别》，有人留言说可以使用 currenthashtable。

![](/images/集合/42_2.jpg)

，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent\*开头的并发类和接口都在这里了。

![](/images/集合/42_3.jpg)

好了，关于 Hashtable 的迷惑就此全都解开了。

## 43、ConcurrentHashMap 的数据结构？

ConcurrentHashMap 它是线程安全版的 HashMap，可以实现线程安全的集合的并发操作，它在不同的 JDK 版本中有不同的数据结构。

##### JDK7

JDK 7 中，ConcurrentHashMap 采用的是分段锁（Segment）机制，底层采用 **数组＋链表**的存储结构，即 Segment 数组＋ HashEntry 数组，如下图所示:

![](/images/集合/43_1.jpg)

Segment 数组一共由 16 个 Segment 组成，每个 Segment 是由若干个 HashEntry 对象链接起来的链表，HashEntry 是用来封装映射表的键值对。每个 Segment 是一个可重入锁，并发操作时，只锁住对应的 Segment，而不是整个 Segment 数组，从而提升了并发性能。

##### JDK 8

然后在 JDK 8 中，ConcurrentHashMap 又进行了优化，取消了 Segment 分段锁机制，和 HashMap 一样，两者均为 数组+链表+红黑树的数据结构，如下图所示：

![](/images/集合/43_2.jpg)

然后再通过灵活运用 CAS + synchronized 机制来保证线程安全，如 putval 方法源码所示：

![](/images/集合/43_3.jpg)

![](/images/集合/43_4.jpg)

若链表为空，此时使用 CAS 乐观锁机制，在添加元素之前，判断线程获取的版本号与实际版本号是否一致，若一致则添加成功，否则，则让线程自旋直到成功为止。

若链表不为空（存在 Hash 冲突的场景），此时使用 synchronized 关键字来保证线程安全，先获取到锁的线程会给链表中的 Node 头节点加锁，加锁成功才能继续，从而保证线程安全。

## 44、WeakHashMap 是哪种引 l 用方式？

WeakHashMap 是一种“弱引用”的实现方式。

## 45、WeakHashMap 有什么用？

WeakHashMap 可作为缓存使用，在垃圾回收器工作时，一旦发现了只具有弱引 l 用的对象，不管当前内存空间足够与否，会自动清除 WeekHashMap 中 key 未被引用的数据，可以在一定程度上避免内存溢出。

## 46、WeakHashMap 会导致内存溢出吗？

如果 WeakHashMap 使用不当，是可能导致内存溢出的。比如，WeakHashMap 中的大量 key 都存在强引 l 用，WeakHashMap 就基本退化为 HashMap 了，所以会导致 WeakHashMap 中的数据不能正常被回收，就可能内存溢出。

## 47、WeakHashMap 和 HashMap 的关系？

两者没有什么联系：

![](/images/集合/47.jpg)

它们都实现了 Map 接口，都是哈希表的实现，只不过 HashMap 是强引用实现，而 WeakHashMap 是弱引引用实现，另外可以看到，WeakHashMap 是不能被克隆和序列化的。

## 48、IdentityHashMap 和 HashMap 的区别？

HashMap 在比较 key 时使用的是 equals，即比较的是 key 的值，如果相同则会覆盖。

IdentityHashMap 在比较 key 时使用的是==，即比较的是地址，即使值相同，但地址不同，则会存储两份，而不会覆盖。

---

如下面的程序：

```java
public static void main(string[] args) {
    IdentityHashMap<String, String> identityHashMap = new IdentityHashMap();
    string mskl = new string("msk");
    String msk2 = new string("msk");
    identityHashMap.put(msk1, "Java面试库1");
    identityHashMap.put(msk2,"Java面试库2");
    System.out.println(identityHashMap.get("msk"));
    System.out.printin(identityHashMap.get(msk1));
    System.out.printin(identityHashMap.get(msk2));
    System.out.printin(identityHashMap);
}
```

结果输出：

> null
>
> Java 面试库 1
>
> Java 面试库 2
>
> {msk=Java 面试库 1， Msk=Java 面试库 2}

根据字符串获取为 null，根据对象的地址则获取正确，可以看到 identityHashMap 中存储的是两份 msk。

## 49、ArrayList 有没有容量限制？

来看 ArrayList 构造器源码：

![](/images/集合/49_1.jpg)

容量参数传入的是 int 类型，所以 ArrayList 最大容量是 int 类型的最大值，即：

![](/images/集合/49_2.jpg)

![](/images/集合/49_3.jpg)

20 多亿，所以大小不是问题，反而应该考虑内存是否装的下。

## 50、LinkedList 有没有容量限制？

来看 LinkedList 构造器源码 ：

![](/images/集合/50.jpg)

理论上链表没有容量限制，可以一直存储，但会受内存限制。

## 51、ArrayList 是线程安全的么？

这个问题是 Java 程序员面试经常会遇到的吧，刚毕业的都应该知道 ArrayList 是线程不安全的，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。

ArrayList 集合类的部分注释如下：

![](/images/集合/51_1.jpg)

注释说它不是 synchronized 同步的，说明它就不是线程安全的。

来随便来看一个添加元素的方法源码：

![](/images/集合/51_2.jpg)

如图，添加元素方法并没有使用 synchronized 同步，如果多个线程执行该集合的 add 方法，就可能造成多线程安全问题，其他像 remove 方法也都是同理。

## 52、常用的线程安全的 List 集合有哪些？

##### 常用的线程安全的 List 集合有：

- Vector
- SynchronizedList
- CopyOnWriteArrayList

下次面试官问你线程安全的 List，你可以从下面这样的顺序依次说上来：

> Vector > SynchronizedList > CopyOnWriteArrayList
>
> 具体介绍可以点击上面链接看相关面试题。

这样才有带入感，也能体现你对知识点的掌握程度。

## 53、循环删除 List 集合可能会发生什么异常？

循环删除 List 集合，可能会报的异常：

##### IndexOutOfBoundsException：

动态删除了元素导致数组下标越界了，比如：

> 遍历一个大小为 16 的 List 集合时，假如现在已经到了索引|10，然后从集合删除本元素，等访问到了最后一个元素 list[15] 时，发现集合中只有 15 个元素了，最大为 list[14]，此时 list[15] 即产生这个数组越界异常。

##### ConcurrentModificationException：

选代器遍历 fail-fast 集合时，因动态删除元素而导致的并发修改异常，具体见 fail-fast 相关的面试题。

## 54、编程实现删除 List 集合中的元素

用 Java 编程，删除 list 中包含"a"的元素：

```java
List<string> listi = new Arraylist<>();
list1.add("tom");
list1.add("john");
list1.add("david");
list1.add("james");
listl.add("lily");
listl.add("san");
```

---

下面我提供两种常见的删除方法：

```java
public static void main(string[] args) throws Exception {
    List<string> list1 = new Arraylist<>();
    list1.add("tom");
    list1.add(" john");
    list1.add("david");
    list1.add("james");
    lst1.add("lily");
    lst1.add("san");
    System.out.println(list1);

    //用Iterator遍历删除
    List<string> list2 = new Arraylist<>(list1);
    for (Iterator<String> ite = list2.iterator(); ite.hasNext(); ) {
        String str = ite.next();
        if (str.contains("a")) {
            ite.remove();
        }
    }
    System.out.println(list2);
    //使用stream快速筛选功能
    List<string> list3 = new Arraylist<>(list1);
    list3 = list3.stream().filter(e -> le.contains("a").tolist());
    System.out.println(list3);
}
```

输出结果：

> [tom, john, david, james, lily, san]
>
> [tom, john, lily]
>
> [tom, john, lily]

## 55、编程实现删除 List 集合中的重复元素

假设有以下数据：

```java
public List<string> initlist = Arrays.aslist(
    "张三",
    "李四",
    "张三",
    "周一",
    "刘四",
    "李强",
    "李白",
    "张三",
    "李强",
    "王五");
```

> 去除 List<String>中的重复元素。

##### List 去重方案

---

##### 1、for 循环添加去重

```java
@Test
public void removei() {
    List<string> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist<>();
    for (String element : list) {
        if (!list2.contains(element)) {
            list2.add(element);
        }
    }
    System.out.println(list2);
}
```

这个是最基本的实现了，创建一个空的 List，添加前判断一下存在不存在，不存在才添加，这样就保证了元素不重复。

输出结果：

> [张三, 李四, 周一, 刘四,李强,李白, 王五]

##### 2、for 双循环去重

```java
@Test
public void remove2() {
    List<string> list = new Arraylist(initlist);
    for (int i = 0; i < list.size() - 1; i++) {
        for (int j = list.size() - 1; j> i; j--) {
            if (list.get(j).equals(list.get(i))) {
                list.remove(j);
            }
        }
    }
    System.out.println(list);
}
```

利用双循环，判断是否有相等的，再进行移除。

输出结果：

> [张三,李四, 周一, 刘四,李强, 李白,王五]

##### 3、for 循环重复坐标去重

```java
@Test
public void remove3() {
    List<string> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist(initlist);
    for (string element : list2) {
        if (list.indexof(element) I= list.lastindexof(element)) {
            list.remove(list.lastindexof(element));
        }
    }
    System.out.println(list);
}
```

这种方式很新颖吧？

复制一个 list2，再循环 List2，判断 list 中的元素的首尾出现的坐标位置是否一致，如果一致，则说明没有重复的，否则重复，再删除重复的位置的元素。

输出结果：

> [张三, 李四, 周一, 刘四,李强,李白, 王五]

##### 4、Set 去重

```java
@Test
public void remove4() {
    List<string> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist(new Hashset(list));
    System.out.printin(list2);
}
```

这招也太简单了吧，一行代码搞定！

我们知道 Set 是不包含重复元素的，把 List 先装进 HashSet，然后再装回来，这样就保证了元素的不重复。

输出结果：

> [李强,李四,张三, 周一,李白, 王五,刘四]

结果虽然正确，但元素顺序和原始 List 不一致，如果要保证顺序性，可以把 HashSet 换成 LinkedHashSet：

```java
@Test
public void remove4() {
    List<string> list = new Arraylist(initlist);
    List<string> list2 = new Arraylist(new LinkedHashset(list));
    System.out.println(list2);
}
```

输出结果：

> [张三, 李四, 周一, 刘四,李强,李白, 王五]

这下顺序对了吧，LinkedHashSet 可以保证元素的顺序性！

##### 5、Stream 去重

```java
@Test
public void remove5() {
    List<string> list = new Arraylist(initlist);
    list = list.stream().distinct().collect(collectors.tolist());
    System.out.printin(list);
}
```

利用 Stream 的 distinct 方法去重，这个方法也十分简单，一行代码搞定！

## 56、编程实现对 List 集合中的元素进行排序

##### 传统排序

---

现在有一个 List 集合：

```java
public static List<User> LIsT = new ArrayList() {
    add(new User("Lisa", 23));
    add(new User("Tom", 11));
    add(new User("john", 16));
    add(new Uuser("jessie", 26));
    add(new User("Tony", 26));
    add(new User("Messy", 26));
    add(new User("Bob", 19));
    add(new User("yoga", 65));
}
```

jdk8 之前的排序：

```java
private static void sortprejdk8() {
    System.out.printin("=====jdks 之前的排序====");
    List<user> list = new Arraylist<>(LIST);
    Collections.sort(list, new Comparator<User>() {
        @override
        public int compare(user ul, User u2) {
            return u1.getAge().compareTo(u2.getAge());
        }
    });

    for (user user : list) {
        System.out.printin(user);
    }
    System.out.println();
}
```

在 Java 8 出来之前，排序基本上要这么写，可是 Java 8 都出来这么多年了，你还在这么排序那就太 Low 了！

##### Java8 中的排序

---

本篇就直接上干货，看我怎么用 Java 8 排序！

```java
@NoArgsConstructor
@AllArgsConstructore
@Data
static class User {
    private static final User USER = new User();
    private string name;
    private Integer age;

    public static int compareAge(user u1, User u2) {
        return ul.getAge() .compareTo(u2.getAge());
    }

    public static User getinstance() {
        return USER;
    }

    public int compare(User u1, User u2) {
        return u1.getAge().compareTo(u2.getAge());
    }
    @override
    public String tostring() {
      return age + ":" + name;
    }
}
```

##### 1、Lambda 排序(带参数类型)

Java 8 中的 List 接口新增了一个 sort 默认方法：

![](/images/集合/56_1.jpg)

接收 Comparator 接口参数，这个接口在 Java 8 中被修饰为函数式接口：

![](/images/集合/56_2.jpg)

然后我们就可以把 Comparator 接口参数改成了用 Lambda 表达式的形式，用 Lambda 表达式干掉了匿名内部类，让代码更简洁。

使用示例如下：

```java
private static void sortwithjdk8lambda1() {
    System.out.println("====-jdks lambda 排序， 带参数类型==-=");
    List<User> list = new Arraylist<>(LIST);

    list.sort((user u1, User u2) -> u1.getAge().compareTo(u2.getAge()));

    list.forEach(System.out::println);
    System.out.println();
}
```

##### 2、Lambda 排序（不带参数类型）

Lambda 表达式是可以不用带参数类型的，如下示例：

```java
private static void sortwithidk8lambda2() {
    System.out.println("=====jdk8 lambda 排序, 不带参数类型==-");
    List<user> list = new Arraylist<>(LIsT);
    list.sort((u1, u2) -> ul.getAge().compareTo(u2.getAge()));
    list.forEach(System.out::println);
    System.out.printin();
}
```

代码中的 u1, u2 并没有用 User 类修饰，它会自动推断为 User 类型，因为集合本身就是一个 User 泛型。

##### 3、静态方法引用排序

除了 Lambda 表达式，还可以用类的静态方法引用：

```java
private static void sortwithjdksstaticMethodRef() {
    System.out.printin("=====jdks 静态方法引|用排序=====");
    List<user> list = new Arraylist<>(LIST);
    list.sort(user::compareAge);
    list.forEach(System.out::println);
    System.out.printin();
}
```

使用方法引用之后代码是不是更简洁了？

##### 4、实例方法引用排序

不仅可以用类的静态方法，还可以用类的实例普通方法引用：

```java
private static void sortwithjdk8InstanceMethodRef() {
    System.out.printin("====-jdk8 实例方法引|用排序=====");
    List<User> list = new Arraylist<>(LIST);
    list.sort(user.getInstance()::compare);
    list.forEach(system.out::println);
    System.out.println();
}
```

这个 getlnstance 在这里实际上是一个单例，但和单例无关，任何类的实例都可以。

##### 5、Comparator 工具类排序(升序)

Java 8 在 Comparator 接口中新增了 comparing 方法:

![](/images/集合/56_3.jpg)

这个工具方法需要提供一个函数式接口参数，也就是要比较的哪个字段，最后还是返回 Comparator 接口实例。

使用示例如下：

```java
private static void sortwithndkscomparatorAsc() {
    System.out.println("=====jdk8 升序排序=====");
    List<User> list = new Arraylist<>(LIST);
    list.sort(comparator.comparing(User::getAge));
    //List.sort(Comparator.comparing((user) -> user.getAge()));
    list.forEach(System.out::println);
    System.out.println();
}
```

既然是函数式接口，所以又可以用 Lambda、方法引用形式作为参数传入。

##### 6、Comparator 工具类排序（降序)

还可以使用 Comparator.reversed/reversedOrder 方法进行降序：

```java
private static void sortwithndkscomparatorDesc() {
    System.out.printin("=jdks 降序降序===-=");
    List<User> list = new Arraylist<>(LIsT);
    list.sort(comparator.comparing(User::getAge).reversed());
    list.foreach(System.out::println);
    System.out.printin();
}
```

Comparator.reversed 和 reversedOrder 的区别在于，reversedOrder 适用于基本数据类型的集合的自然排序，而 reversed 是对 Comparator 自身的封装，适用于对象的自定义排序。

##### 7、组合排序

如果要先按用户的年龄排序，年龄相同的再按姓名排序，可以使用 Comparator 接口中的 thenComparing 默认方法：

```java
private static void sortGroupwithJdk8() {
    System.out.printin("=====jdks 组合排序=====");
    List<user> list = new Arraylist<>(LIST);
    list.sort(comparator.comparing(User:igetAge) .thencomparing(User::getName));
    list.forEach(System.out::printin);
    System.out.printin();
}
```

输出结果：

> ====jdk8 组合排序=====
>
> 11: Tom
>
> 16: John
>
> 19: Bob
>
> 23: Lisa
>
> 26: Jessie
>
> 26: Messy
>
> 26: Tony
>
> 65: Yoga

注意年龄 26 岁的人又按姓名按自然顺序排序了。

##### 8、Stream 排序

还可以把 List 集合转换为 Stream，然后使用其 sorted 方法：

![](/images/集合/56_4.jpg)

sorted 方法也是接收 Comparator 接口参数，所以我们也可以使用 Lambda、方法引 l 用、Comparator 接口自身提供的工具方法对其调用：

```java
private static void sortwithndk8stream() {
    System.out.printin("=----jdks Stream 排序=----");
    List<User> list = new Arraylist<>(LIsT);
    list = list.stream().sorted(user::compareAge).collect(collectors.tolist());
    // List = List.stream().sorted((ul, u2) -> ul.getAge().compareTo(u2.getAge())).collect(collectors.toList());

    //List = List.stream().sorted(comparator.comparing(User::getAge)).colLect(collectors.toList();
    list.foreach(System.out::println);System.out.println();
}
```

所以使用 Stream 也可以扩展多种排序方法，见注释部分，这里就不展开了。

##### 9、并行 Stream 排序

有 Stream 排序，那就并行 Stream （parallelStream）排序：

```java
private static void sortwithjdk8parallelstream() {
    System.out.println("=====jdk8 Stream 排序=====");
    List<user> list = new Arraylist<>(LIsT);
    list = list.parallelstream().sorted(user::compareAge).collect(collectors.tolist());
    list.forEach(system.out::println);
    System.out.println();
}
```

10、Collections 排序

既然在 Java 8 中，Comparator 接口被定义成了函数式接口，那么我们传统的 Collections 工具类就可以改变了，我们也可以使用 Lambda、方法引 l 用、Comparator 接口自身提供的工具方法对其调用：

```java
private static void sortwithcollections() {
    System.out.printin("=----jdks Collections 排序=---=");
    List<user> list = new Arraylist<>(LIsT);
    Collections.sort(list, User::compareAge);
    // Collections.sort(List, (ui, u2) -> u1.getAge().compareTo(u2.getAge()));
    //Collections.sort(list, Comparator.comparing(User::getAge));
    list.forEach(system.out::println);
    System.out.println();
}
```

## 57、怎么对一个 List 集合进行排序？

##### List 主要有以下几种排序方式：

1）直接调用 List 集合自身的.sort 方法；

2） 使用工具类：Collections.sort()；

3）把 List 转换为流，再调用流的 sort 方法，如：list.stream().sort..

## 58、List 和 Array 之间如何互相转换？

List > Array 使用 list.toArray 方法即可。

Array>List 使用 Arrays.asList(array)方法，此方法构造的是一个固定不能修改的 ArrayList，如果需要可以修改，可以使用 newArrayList(Arrays.asList(array)。

## 59、List 遍历有哪几种方式？

主要是以下三种遍历方式。

##### 1、普通 for 循环

```java
for (int i = o; i < list.size(); i++) {
    System.out.print(list.get(i) + "\t");
}
```

##### 2、增强 for 循环

```java
for(Integer n : list){
    System.out.print(n + "\t");
}
```

##### 3、选代器

```java
Iterator<Integer> iterator = list.iterator();
while(iterator.hasNext()){
    System.out.print(iterator.next() + "\t");
}
```

## 60、ArrayList 默认大小是多少，是如何扩容的？

带大家来看源码：

![](/images/集合/60_1.jpg)

默认初始容量为：10。

![](/images/集合/60_2.jpg)

容量不足时，会扩充为原来的 1.5 倍大小。

## 61、ArrayList 和 LinkedList 的区别？

ArrayList 和 LinkedList 两者都实现了 List 接口，区别如以下所示。

##### 数据结构

ArrayList 底层是基于数组的数据结构，LinkedList 底层是基于双向链表数据结构。

##### 读写性能

对于随机访问，ArrayList 性能要优于 LinkedList，因为 ArrayList 可以根据下标对元素进行随机访问，时间复杂度为 O(1)，而 LinkedList 的每一个元素都连接在一起，不能随机访问，所以查找某个元素的时间复杂度是 O(n)。

对于插入和删除操作，LinkedList 性能要优于 ArrayList，因为当元素被添加到 LinkedList 任意位置的时候，只需要更新前后元素的引 I 用，而不需要像 ArrayList 那样重新挪动元素位置。

##### 内存消耗

LinkedList 比 ArrayList 要消耗更多的内存，因为 LinkedList 中的每个节点除了存储数据，还要存储了前后元素的引 l 用。

## 62、ArrayList 和 LinkedList 哪个更占空间？

这个也是大厂经常问的！

一般情况下，LinkedList 占用的空间肯定更大，因为 LinkedList 是链表构成的，链表的显著特征就是：其每个节点都要维护前后元素的节点地址，所以相对会耗费空间。

但也不是绝对，大家可以回到《ArrayList 默认大小是多少，是如何扩容的？》一题，ArrayList 每次扩容都会是原来的 1.5 倍，所以其占用（浪费）的空间也是不小的。

> 比如一个默认容量 10 万的 ArrayList，扩容之后就是 15 万，如果只用到了 12 万，那剩余的 3 万不是浪费了？

所以，这个题干万不能答哪个绝对的更占空间，要分情况比较。

## 63、什么是 Vector？

Vector 自从 JDK 1.0 就添加了 ：
![](/images/集合/63_1.jpg)

它和 ArrayList 相似，底层也使用了 Object 切 数组，它同样实现了 List 接口，两者的不同点可以参考面试题：ArrayList 和 Vector 的区别？

Vector 是线程安全的，读写方法都是使用 synchronized 关键字硬同步的，如源码所示：

![](/images/集合/63_2.jpg)

![](/images/集合/63_3.jpg)

所以，它性能太差，几乎已被淘汰，不建议使用了。

## 64、ArrayList 和 Vector 的区别？

##### ArrayList 和 Vector 的相同点：

1）两者都是基于索引的，内部由一个数组支持；

2）两者维护插入的顺序，我们可以根据插入顺序来获取元素；

3） ArrayList 和 Vector 的迭代器实现都是 fail-fast 的；

4） ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问；

##### ArrayList 和 Vector 的不同点：

1）Vector 是线程安全的，而 ArrayList 不是，所以 ArrayList 性能要比 Vector 好太多；

2）Vector 扩容原来的两倍，ArrayList 扩容则为原来的 1.5 倍；Vector 还以设置增长的空间大小，而 ArrayList 则不行。

## 65、Arrays.asList 有什么使用限制？

Arrays.asList 返回的是 Arrays 工具类中的一个 ArrayList 内部类：

![](/images/集合/65_1.jpg)

1）不能对集合进行添加移除等操作，它的 add/remove/clear 方法并未实现：

![](/images/集合/65_2.jpg)

所以，add/remove/clear 操作会抛出 UnsupportedOperationException 异常。

2）不能扩容。

3）其他未知限制。

阿里都出规范了：

![](/images/65_3.jpg)

## 66、ArrayList 初始化 1 万条数据，怎么优化？

可以直接初始化 ArrayList 集合的初始容量为 1 万以上，避免频繁扩容导致性能下降。

## 67、ArrayList 为什么不是线程安全的？

这个问题是 Java 程序员面试经常会遇到的吧。

工作一两年的应该都知道 ArrayList 是线程不安全的，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。

为什么 ArrayList 是线程不安全的，来看以下的代码：

```java
public class TestArraylist {
    private static List<Integer> list = new Arraylist<>();
    public static void main(string[] args) throws InterruptedException {
        for (int i = 0; i<10; i++){
            testlist();
            list.clear();
        }
    }

    private static void testlist() throws InterruptedException {
        Runnable runnable = () -> {
            for (int i = 0; i < 100ee; i++) {
                list.add(i);
            }
        };

        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        Thread t3 = new Thread(runnable);
        t1.start();
        t2.start();
        t3.start();
        t1.join();
        t2.join();
        t3.join();
        System.out.println(list.size());
    }
}
```

这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。

> Exception in thread "Thread-1" java.lang.ArrayIndexoutofBoundsException: 15786
>
> at java.base/java.util.Arraylist.add(Arraylist.java:468)
>
> at java.base/java.util.ArrayList.add(ArrayList.java:480)
>
> at com.test.thread.TestArrayList.lambdastestList$o(TestArraylist.java:23)
>
> at java.base/java.1ang.Thread.run(Thread.java:844)
>
> 20332
>
> 16100
>
> 14941
>
> 23749
>
> 15631
>
> 22118
>
> 27417
>
> 30000
>
> 28691
>
> 27843

##### 现象分析

从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。

##### 1、发生 ArraylndexOutOfBoundsException 异常；

```java
private void add(E e, object[] elementData, int s) {
    if (s == elementData.length)
        elementData = grow();
    elementData[s] = e;
    size = 5 + 1;
}
```

定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。

##### 2、程序正常运行，输出了少于实际容量的大小；

这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。

##### 3、程序正常运行，输出了预期容量的大小；

这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。

##### 解决方案

既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。

另外，像 HashMap,HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。

## 68、什么是 CopyOnWriteArrayList？

CopyOnWriteArrayList 是 ArrayList 的线程安全变体，它的实现原理就是在添加元素的时候对方法加锁，先把原 List 列表复制一份，再添加新的元素，这样就实现了线程安全性。

先来看下它的 add 方法源码：

```java
public boolean add(E e) {
    //加锁
    final Reentrantlock lock = this.lock;
    lock.lock();
    try {
        //获取原始集合
        Object[] elements = getArray();
        int len = elements.length;

        //复制一个新集合
        Object[] newElements = Arrays.copyof(elements, len + 1);
        newElements[len] = e;
        //替换原始集合为新集合
        setArray(newElements);
        return true;
    } finally {
        //释放锁
        lock.unlock();
    }
}
```

添加元素时，先加锁，再进行复制替换操作，从而不会影响获取元素的操作，最后再释放锁。

再来看下它的 get 方法源码：

```java
private E get(object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}
```

可以看到，获取元素时并没有加锁，即使正在写入元素，也不会受影响，因为加锁和写入的是复制的对象，所以在读多写少的场景可以提升读写性能。

## 69、什么是 CopyOnWriteArraySet？

CopyOnWriteArraySet 和 CopyOnWriteArrayList 是一样的道理，它是 HashSet 的线程安全版本。

CopyOnWriteArraySet 的实现就更简单了，它使用 CopyOnWriteArrayList 集合类及它的 addlfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合，如以下源码所示：

![](/images/集合/69_1.jpg)

![](/images/集合/69_2.jpg)

## 70、CopyOnWrite\*并发集合有哪些优缺点？应用场景是？

CopyOnWrite（简称：COW）：即**复制一份再写入**，这样做的好处是，写数据时才加锁，读取元素时就不用加锁，在高并发情况下可以大大提升读取性能。

CopyOnWrite 虽然牛逼，但它只适合于 **读多写少**的应用场景，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能和内存开销很大，如果集合较大，很容易造成内存溢出。

## 71、什么是 SynchronizedList？

线程安全的 List 除了 Vector，你还会别的吗？你至少还得说得上 SynchronizedList：

> java.util.Collections.SynchronizedList

SynchronizedList 能把所有 List 接口的实现类转换成线程安全的 List，比 Vector 有更好的扩展性和兼容性，SynchronizedList 的构造方法如下 :

```java
final List<E> list;
Synchronizedlist(List<E> list) {
    super(list);
    this.list = list;
}
```

SynchronizedList 的部分方法源码如下：

```java
public E get(int index) {
    synchronized (mutex) {
        return list.get(index);
    }
}
public E set(int index, E element) {
    synchronized (mutex) {
        return list.set(index, element);
    }
}
public void add(int index, E element) {
    synchronized (mutex) {
        list.add(index, element);
    }
}
public E remove(int index) {
    synchronized (mutex) {
        return list.remove(index);
    }
}
```

很可惜，和 Vector 差不多，它所有方法都是带同步对象锁的，所以它不是性能也并不好，在高并发场景也不建议使用。

> 即使你能说到这里，面试官还会继续往下追问，SynchronizedList 这种集合性能非常差，还有没有更合适的线程安全的 List 并发集合方案？

这个请看 CopyOnWrite*并发集合系列面试题，CopyOnWrite*集合类也就这两个，Java 1.5 开始加入，你要能说得上这下面两个并发集合类才能让面试官信服：

> java.util.concurrent.CopyOnWriteArrayList
>
> java.util.concurrent. CopyOnWriteArraySet

## 72、什么是 fail-safe？

fail-fast 和 fail-safe 是集合中的一种错误处理机制。

##### fail-safe：安全失败

当迭代器正在遍历一个集合时，它不是直接在原有集合上遍历，而是先复制一份再进行遍历，所以对原有集合的结构变更不会影响拷贝份的遍历，所以 fail-safe 选代器不会抛出 ConcurrentModificationException 并发修改异常；

java.util.concurrent 包中的并发集合类都被设计为 fail-safe（安全失败）类型的，比如 CopyOnWrite\*、ConcerrentHashMap 集合，遍历过程中结构发生变更是安全的，不会抛出以上异常。

## 73、什么是 fail-fast？

fail-fast 和 fail-safe 是集合中的一种错误处理机制。

##### fail-fast：快速失败

当迭代器正在遍历一个集合时，如果集合结构发生了变更操作（修改、删除），fail-fast 选代器则会抛出 ConcurrentModificationException 并发修改异常。

java.util 包中的所有集合类都被设计为 fail-fast（快速失败）类型的，比如常用的 ArrayList、HashMap，如果在遍历过程中结构发生变更就会抛出以上异常。

## 74、fail-fast 与 fail-safe 有什么区别？

fail-fast 和 fail-safe 是集合中的一种错误处理机制：

- fail-fast 是快速失败机制，集合迭代器遍历过程中结构发生变更，会抛出 ConcurrentModificationException 并发修改异常；
- -safe 是安全失败机制，集合迭代器遍历过程中结构发生变更，不会抛出 ConcurrentModificationException 并发修改异常

具体介绍请进入对应的 fail-fast 和 fail-safe 子面试题。

## 75、HashSet 是线程安全的么？

HashSet 是线程不安全的集合，如源码所示：

![](/images/集合/75_1.jpg)

![](/images/集合/75_2.jpg)

也就是说所有方法都是非 syncrhonized 的，其底层也是通过 HashMap 来实现去重的，HashMap 本身就不是线程安全的，所以，如果多个线程并发操作同一个 HashSet，就存在线程安全的问题了。

## 76、常用的线程安全的 Set 集合有哪些？

常用的线程安全的 Set 集合有：

- ynchronizedSet
- CopyOnWriteArraySet

和 List 相关并发集合类似，SynchronizedSet 会对所有关键方法加锁，效率较低，CopyOnWriteArraySet 使用的是复制再写入的思想，适合读多写少的应用场景。

## 77、HashSet 中的元素是有顺序的么？

HashSet 中的元素是没有顺序的，因为它是不可重复设计的，底层使用的是 HashMap 实现：

![](/images/集合/77.jpg)

HashMap 是按 key 的 hashCode 值计算出数组的索引进行存储的，所以是没有顺序的。

## 78、HashSet 怎么按插入顺序排序？

HashSet 要按插入顺序排序，可以使用：LinkedHashSet，它是通过继承 HashSet 来实现的，如下面类结构图所示：

![](/images/集合/78_1.jpg)

> 注意，LinkedHashSet 也是线程不安全的。

LinkedHashSet 底层是通过 LinkedHashMap 来实现的：

![](/images/集合/78_2.jpg)

具体见《什么是 LinkedHashMap？》面试题。

## 79、HashSet 怎么按自然顺序排序？

按自然规则排序，使用：TreeSet，它底层是通过组合 TreeMap 实现的，如下面源码所示：

![](/images/集合/79.jpg)

TreeMap 默认按 key 自然顺序，可以通过传入 comparator 比较器实现自定义顺序。

## 80、HashSet 的底层实现原理是什么？

HashSet 是基于 HashMap 实现的，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成,HashSet 不允许重复的值。

![](/images/集合/80.jpg)

## 81、TreeSet 的数据结构是什么？

TreeSet 底层使用的是 TreeMap 来实现的，如源码所示：

![](/images/集合/81.jpg)

所以，TreeSet 内部数据结构的是：红黑树。

## 82、怎么确保一个集合不能被修改？

可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang.UnsupportedOperationException 异常。

示例代码如下：

```java
public static void main(string[] args) throws Exception {
    List<string> list = new Arraylist<>();
    list.add("小程序");
    Collection<string> clist = Collections.urnmodifiablecollection(list);
    //运行时此行报错
    clist.add("Java面试库");
    System.out.println(list.size());
}
```

![](/images/集合/82.jpg)

## 83、为什么不建议使用双括号初始化集合？

比如还有 List 这种：

```java
List<string> list = new Arraylist<string>() {{
    add("item1");
    add("item2");
}};
```

这种双括号定义和初始化方法，简单方便，但是不建议使用，有坑！

> **因为，在 Java 中，双括号初始化会产生匿名内部类，而非静态匿名内部类又会隐式强引用外部类，如果两个类的实例对象的生命周期不一致，从而会导致外部类无法被及时回收，如果同时产生大量匿名内部类，就可能会造成内存泄露。**

##### 替代方案：

```java
List<string> list = Stream.of("java", "Go").collect(collectors.tolist());
Map map = Map.of("key1", "Java", "key2", "Go");
```

## 84、什么是阻塞队列？

阻塞队列（接口：BlockingQueue）它是一个支持两个附加操作的队列，这两个附加操作支持阻塞的插入和移除元素方法：

- **支持阻塞的插入方法**：当队列满了时，队列会阻塞插入元素的线程，直到队列没有塞满可以插入元素为止；

- **支持阻塞的移除方法**：当队列空了时，队列会阻塞获取元素的线程，直到队列变为非空可以获取元素为止；

阻塞队列提供的四种处理方法：

| 处理方法 | 抛出异常  | 返回特殊值 | 一直阻塞 | 超时退出           |
| -------- | --------- | ---------- | -------- | ------------------ |
| 插入元素 | add(e)    | offer(e)   | put(e)   | offer(e,time,unit) |
| 移除元素 | remove()  | poll()     | take()   | pol(time,unit)     |
| 检查元素 | element() | peek()     | 不可用   | 不可用             |

## 85、阻塞队列是线程安全的吗？

阻塞队列（BlockingQueue）是**线程安全**的，如 BlockingQueue 接口注释所示:

![](/images/集合/85.jpg)

BlockingQueue 中的关键操作方法，都使用内部锁或其他形式的并发控制来实现它们的原子效果，所以我们对阻塞队列读取、写入元素操作时无需考虑并发问题。

## 86、阻塞队列有哪些常用的应用场景？

阻塞队列（BlockingQueue）常用于**生产者和消费者场景**，生产者线程往阻塞队列里添加元素，消费者线程从阻塞队列里获取元素进行消费，比如在 Java 自带的各种线程池中就使用阻塞队列作为工作队列来存储待执行的任务，如下面源码所示：

```java
public static Executorservice newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}
```

newFixedThreadPool 使用到的 LinkedBlockingQueue 队列就是一个由链表结构组成的有界阻塞队列：

![](/images/集合/86.jpg)

## 87、Java 中的阻塞的队列有哪些？

常用的阻塞队列有以下几个：

| 阻塞队列              | 说明                       |
| --------------------- | -------------------------- |
| ArrayBlockingQueue    | 数组结构组成的有界阻塞队列 |
| LinkedBlockingQueue   | 链表结构组成的有界阻塞队列 |
| PriorityBlockingQueue | 支持优先级排序无界阻塞队列 |
| DelayQueue            | 优先级队列实现无界阻塞队列 |
| SynchronousQueue      | 不存储元素的阻塞队列       |
| LinkedTransferQueue   | 链表结构组成的无界阻塞队列 |
| LinkedBlockingDeque   | 链表结构组成的双向阻塞队列 |
