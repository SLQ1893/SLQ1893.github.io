## 1、进程和线程的区别？

##### 进程

进程是系统中正在运行的一个应用程序，应用程序启动运行就会形成一个进程。

**进程是系统分配资源的最小单位**，每个进程都拥有独立的地址空间。

##### 线程

线程运行于进程之中，一个进程可以有多个线程同时并发运行。

**线程是操作系统调度的最小单位**，每个线程都有独立的虚拟机栈，线程之间运行互相不影响。

---

下面是进程和线程的详细对比表格：

| 特点         | 进程                                     | 线程                                           |
| ------------ | ---------------------------------------- | ---------------------------------------------- |
| 定义         | 是操作系统资源分配的基本单位             | 是进程内的执行单位                             |
| 独立性       | 相互独立，各进程有自己的地址空间和数据栈 | 依赖于所属进程，共享进程的地址空间和数据栈     |
| 资源开销     | 较大，每个进程有独立的内存和系统资源     | 较小，多个线程共享相同的进程资源               |
| 切换开销     | 较大，进程切换需要保存和加载整个上下文   | 较小，线程切换只需保存和加载部分上下文         |
| 通信机制     | 通信复杂，进程间通信需要使用 IPC 机制    | 通信简单，线程间共享进程内存，直接读写变量即可 |
| 创建销毁开销 | 较大，进程创建销毁需要较多的时间和资源   | 较小，线程的创建销毁相对快速                   |
| 同步与互斥   | 同步与互斥较为复杂，需要使用信号量等机制 | 同步与互斥较为简单，可以使用锁等同步机制       |
| 适用场景     | 适用于需要高度隔离和安全性的任务         | 适用于需要高效利用资源和提高响应速度的任务     |

## 2、进程之间怎么进行通信？

在 Java 中，进程之间可以通过不同的通信方式来进行交互和数据传递，下面是一些常用的 Java 进程间通信方案：

##### 1、网络通信

利用 Socket 编程进行进程间的网络通信,;a 可以使用 TCP 或 UDPa 协议。一个进程作为服务器，监听指定端口，另一个进程作为客户端连接该端口，通过 Socket 进行数据交换。

##### 2、进程间共享文件

可以使用文件作为通信的媒介，在一个进程将数据写入文件后，另一个进程读取文件中的数据。这种方式相对简单，但效率较低，适用于数据量不大的情况。

##### 3、管道(Pipe)

在 Java 中，可以使用 PipedlnputStream 和 PipedOutputStream 或者 PipedReader 和 PipedWriter 来实现进程间的管道通信。一个进程的输出流连接到另一个进程的输入流，数据从输出流流向输入流。

##### 4、共享内存

可以使用共享内存来实现进程间的通信，Java 中可以使用`Java Native Interface（JNI）`来调用 C/C++的共享内存库，实现共享内存的读写。

##### 5、消息队列

Java 中可以使用消息队列实现进程间的异步通信，常用的消息队列工具有 Apache Kafka、RabbitMQ 等。进程可以将消息发送到队列中另一个进程从队列中接收消息。

##### 6、JavaRMl（远程方法调用）

Java RMl 允许一个 Java 进程调用另一个 Java 进程中的方法，实现远程通信。这需要定义共享接口和服务，以允许远程访问方法。

##### 7、Java NIO(非阻塞 I/O)

使用 Java NlO 的 Channel 和 Selector，可以实现非阻塞的进程间通信，可以在同一个线程中处理多个通道的数据。

##### 8、分布式框架

使用分布式框架，如：Dubbo、Spring Cloud 或者其他 RPC 框架，可以在不同的机器上运行多个 Java 进程，并通过框架提供的接口进行通信和数据处理。

> 选择哪种通信方案取决于具体的场景和需求。

### 3、线程之间怎么进行通信？

##### 有以下几种方式：

1、 synchronized + wait, notify, notifyAll

2、ReentrantLock + Condition

3、CountDownLatch

4、CyclicBarrier

5、Semaphore

6、join/ yield

7、BlockingQueue

8、LockSupport

9、Exchange

...

### 4、什么是原子性？

原子性指的是一个或者多个操作，要么全部执行，要么就全部都不执行，在执行的过程中不被其他操作中断或干扰。

在并发编程中，原子性是一个非常重要的概念因为多线程或并发环境下，多个线程可能同时访问和修改同一个变量，如果操作不是原子性的，可能会导致数据不一致或竞态条件。

### 5、Java 中的基本数据类型的读取和赋值是原子性的吗？

除了 long 和 double，其他的基本数据类型的读取和赋值操作都是原子性的。

如下面的代码：

```java
int x = 100; // 原子性
inty = x; // 非原子性
x++; // 非原子性
x = x + 1; // 非原子性
```

只有语句 1 是原子性的，其他的 3 个语句都不是原子性操作，因为它们都包含两个及以上的操作它们都先要去读取 × 变量的值再将计算后 × 的新值写入到主内存中，几个操作合起来就不是原子性操作了。

### 6、long、double 读写是原子性的吗？

long/double 的读写操作不是原子性的，但可以通过 volatile 修饰实现原子性。

![](/images/多线程/6.jpg)

> 注意：volatile 修饰的 i++，i--操作不具有原子性。

### 7、++、i--操作是原子性的吗？

i++、i--操作不是原子性的，i++和 i-操作是自增和自减操作符，用于增加或减少变量的值。

这些操作分为两个步骤：

1、读取当前变量的值。

2、将变量的值增加或减少 1。

在多线程环境中，如果多个线程同时对同一个变量进行自增或自减操作，可能会导致竞态条件。

如下图所示:

![](/images/多线程/7.jpg)

假设变量 i 的初始值为 0，有两个线程同时执行 i++操作，那么可能会发生以下情况：

- 线程 1：读取的值为 0；
- 线程 2：读取的值为 0；
- 线程 1：将 i 增加 1，i 现在的值为 1；
- 线程 2：将 i 增加 1，i 现在的值为 1（原本期望的是 2）

这种情况下，虽然有两个线程对 i 进行了自增操作，但最终 i 的值只增加了 1，而不是期望的 2。

这就是因为 i++操作并不是原子性的，它分成了两个独立的步骤，这些操作可能被其他线程干扰，从而导致结果不正确。

### 8、什么是可见性？

在 Java 并发编程中，如果多个线程对成员变量进行修改，默认在没有 volatile 关键字的修饰的情况下，乡线程之间修改的结果是互不相见的，如下图所示：

![](/images/多线程/8.jpg)

线程 B 修改的 inflag 最新的结果值对线程 A 是不可见的，所以，可见性指的是多个线程操作一个共享变量时，其中一个线程对变量进行修改后其他线程可以立即看到最新修改的结果。

### 9、怎么保证可见性？

保证可见性有两种方法：

1）使用 volatile 关键字修饰成员变量；

2）使用 synchronized 关键字或者锁（Lock）修饰的代码；

3）将变量声明为 final

> final 可以确保变量在初始化后不会再被修改保证了可见性。但是，它是有条件的可见性，如果使用不当，会出现 this 引 l 用逃逸的情况，导致访问了未正确初始化的值，更多细节参考《final 可以保证可见性吗？》面试题。

4）使用其他并发工具类，如:CountDownLatch、CyclicBarrier、Semaphore 等，它们都能实现线程间的可见性。

## 10、final 可以保证可见性吗？

是的，`final`关键字可以保证可见性 a（**有条件**）。

当一个变量被声明为`final`时，可以确保该变量在初始化之后不会被再次修改，所以其他线程读取该变量时，一定能够看到最终的值，保证了可见性。

> ##### 需要注意的是：
>
> final 变量的可见性仅在初始化完成之后，如果是一个引 l 用类型的 final 变量，当「this 引用在构造函数中通过某种方式逃逸并被其他线程访问，可能会导致`final`字段的不可见性。这种情况下一其他线程可能在构造函数没有完全执行结束之前就访问了对象的状态，因此不能保证`final`字段的初始化对其他线程是可见的。

如下面的示例：

```java
public class EscapeExample {
    private final int value;
    public EscapeExample() {
        // 在构造函数中，this引用逃逸到了其他线程
        new Thread(() -> {
            // 这里可能在EscapeExampLe对象的构造函数还没有执行完毕之前就被调用
            int tempValue = getValue();
            System.out.println("Value:" + tempValue);
                               }).start();
            // 模拟构造函数执行耗时
        try {
            Thread.sleep(100);
        } catch (InterruptedException e){
            e.printstackTrace();
        }
        value= 42；//此时对final字段进行赋值
    }

    public int getvalue() {
        return value;
    }

    public static void main(String[] args) {
        EscapeExample example = new EscapeExample();
        System.out.println("Final Value: " + example.getValue());
    }
}
```

输出结果：

> Value: 0
>
> Final Value: 42

在这个示例中，`EscapeExample`类包含一个`final`字段`value`，它可以在被其他线程访问。然后在构造函数中，启动了一个新线程，该线程将尝试在`EscapeExample`对象的构造函数还没有执行完毕之前获取`value`字段的值。

由于线程调度的不确定性，新线程可能在构造函数执行之前就开始执行，导致它读取到`value`字段的默认值（0），而不是构造函数中赋予的值（42），这就是是 final 字段的不可见性问题。

为了避免这种问题，应该避免在构造函数中将`this`引用逃逸到其他线程，或者采取其他线程安全的构造对象的方式。在多线程环境下，需要谨慎处理对象的构造和初始化，以确保对象的状态对其他线程是可见的。

## 11、编程实现成员变量可见性的例子

##### 示例 1：

```java
public class Test {
    private static volatile int n1 = 0;
    public static void main(String[] args) throws InterruptedException {
        test1();
    }
    private static void test1() {
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }n1:1;
        }).start();
        while (n1 == 0) {
        }
        System.out.println("stop");
    }
}
```

这个例子加了 volatile，所以程序正确退出输出 stop。

##### 示例 2：

```java
public class Test {
    private static int n2 = 0;
    public static void main(String[] args) throws InterruptedException {
        test2();
    }
    private static void test2() {
        new Thread(() -> {
            try {
                Thread.sleep(100e);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            n2 = 1;
        }).start();
        while (n2 == θ) {
            System.out.println(n2);
        }
        System.out.println("stop");
    }
}
```

这个例子没有加 volatile，程序也正常退出，输出一堆 O 并也正常输出了 stop，这是为什么呢？

##### 没有加 volatile 为什么也有可见性？

看起来是很诡异的问题，问题是在 while 里面加了一行 System.输出问题，打开 println 方法源码看一下：

![](/images/多线程/11.jpg)

这个 println 方法里面加了 synchronized 同步块，正是因为这个 synchronized 同步块，因为它具有可见性，所以保证了里面变量 × 的可见性，这个诡异的问题也就解开了。

> 而如果去掉 while 循环里面加 System..输出语句，线程对变量 n2 的修改对主线程就不可见了，程序普会一直循环，不会输出任何结果。

## 12、什么是有序性？

比如以下示例代码：

```java
public void clear(){
    Node<K,V>[] tab;
    modcount++;
    if ((tab = table) != null && size > 0) {
        size = 0;
        for (int i = 0; i < tab.length; ++i)
            tab[i] = null;
    }
}
```

程序的执行顺序必须**按照代码的先后顺序一行一行来执行**，执行过程中不会发生代码指令重排序，这就是指有序性。

## 13、为什么要使用多线程？

##### 因为多线程有以下几个优势：

---

（1）充分利用多核 CPU

多线程可以真正充分利用和发挥多核 CPU 的优势，同时独立完成 N 个任务而不互相干扰。

（2）提高运行效率

可以把一个任务拆分成多个子线程去运行，从而提高程序的运行效率。

（3）防止阻塞

多线程同时处理一个任务，就算一个线程处理阻塞了，也不会影响整个任务。

## 14、创建线程有哪几种方式？

##### 1、继承 Thread 类

```java
public class MyThread extends Thread {
    @override
    public void run()  {
        System.out.println(Thread.currentThread().getName());
        for (intt i =0; i< 100; i++) {
            System.out.println(i);
        }
    }
}
```

##### 2、实现 Runnable 接口

```java
public class MyRunnable implements Runnable {
    @Override
    pubiic void run() {
        for (int i = 0; i< 10; i++) {
            System.out.println(i);
        }
    }
}
```

或者也可以是：

```java
public static void main(String[] args） {
    Thread thread=new Thread(new Runnable() {
        @Override
        public void run() {
            for（int i = 0; i < 10; i++）{
                System.out.println(i);
            }
        }
    });
    thread.start();
}
```

或者也可以是：

```java
public static void main(String[] args） {
    Thread thread=newThread(()->{
        for （int i = 0; i< 10; i++）{
            System.out.println(i);
        }
    });
  thread.start();
}
```

##### 3、实现 Callable 接口

```java
classMyCallable implements Callable {
    @0verride
    public String call() throws Exception {
        System.out.println("Mycallable.call");
        return "abc";
    }
}

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable myCallable = new MyCallable();
        FutureTask<String> futureTask = new FutureTask<>(myCallable);
        Thread thread - new Thread(futureTask, "callableThread");
        thread.start();
        String str = futureTask.get();
        System.out.println(str);
    }
}
```

这种方式是异步的、可返回结果。

---

底层的创建线程的方法就以上 3 种，其他至于匿名内部类、线程池、Future、Lambda 表达式等创建线程的方式的底层都是基于以上 3 种方式。

比如通过线程池创建：

```java
public static void main(String[] args) {
    ExecutorService es = Executors.newFixedThreadPool(5);
    for (int i = 0; i< 5; i++) {
        es.submit(() ->{
            for (int j = 0; j < 10; j++) {
                System.out.println(Thread.currentThread().getName() + j);
            }
        });
    }
    es.shutdown();
}
```

## 15、什么是守护线程？

与用户线程对应的就是守护线程，守护线程就是守护用户的线程，当用户线程全部执行完结束之后，守护线程才会跟着结束。也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线程自然会退出。

如下图所示：

![](/images/多线程/15_1.jpg)

![](/images/多线程/15_2.jpg)

在 Thread 线程类中有一个 daemon 成员变量，代表线程是否守护线程，默认为 false 用户线程，通过 setDaemon 方法可以将线程设置为守护线程。

## 16、程实现一个守护线程的例子

如下面的示例：

```java
public class Test {
    public static void execute() {
        for (int i = θ; ; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
            }
            System.out.println(i);
        }
    }
  public static void main(String[] args) throws IoException {
        Thread thread = new Thread(() -> execute());
        thread.setDaemon(true);
        thread.start();

        System.in.read();
    }
}
```

##### 代码说明：

（1）这里的用户线程是指 main 方法当前的主线程，主线程通过 System.in.read 来阻塞程序，只有在用户输入任何一个字符回车后，主线程才会退出；

（2）创建一个简单的线程，把一个线程设置 daemon 为 true 即表示守护线程，守护线程每隔一秒打印 i 的值，守护线程守护的是用户主线程，直到主线程输入任何一个字符退出后，守护线程也就会跟就退出不再打印。

运行上面的程序，随便输入一个字符回车，因为用户线程退出了，所以守护线程也就跟着退出了，守护线程停止打印，如下图所示：

![](/images/多线程/16.jpg)

> ##### 需要注意的是：
>
> setDaemon 方法必须设置在线程 start 方法启动之前，不然会抛出异常。

## 17、线程的状态有哪几种？怎么流转的？、

下图是一个线程的生命周期状态流转图，很清楚的描绘了一个线程从创建到终止的过程：

![](/images/多线程/17.jpg)

**NEW**：毫无疑问表示的是刚创建的线程，还没有开始启动。

**RUNNABLE**：表示线程已经触发 startO 方式调用，线程处于就绪（ready）状态，等 CPU 正式调度时才会处于运行中（running）状态，RUNNABLE 状态它是这两种状态笼统。

**BLOCKED**：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。

**WAITING**：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如通过 WaitO 方法进行等待的线程等待一个 notifyO 或者 notifyAllO 方法，通过 join( 方法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线程就进入了 RUNNABLE 状态继续运行。

**TIMED_WAITING**：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒后线程重新进行 RUNNABLE 状态继续运行。

**TERMINATED**：表示线程执行完毕后，进行终止状态。

> ##### 需要注意的是：
>
> 线程一旦通过 start 方法启动后，它就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态。

## 18、线程的优先级有什么用？

在操作系统中，线程可以划分优先级，优先级较高的线程得到 CPU 资源比较多，也就是 CPU 优先执行优先级较高的线程对象中的任务，但是不能保证一定优先级高就会先执行。

Java 线程优先级分为 1 ～ 10 个等级，数字越大优先级越高，默认优先级大小为 5，超出范围则抛出`java.lang.IllegalArgumentException`异常。

## 19、我们常说的 JUC 是指什么？

JUC 是**java.util.concurrent**并发线程包的简称：

![](/images/多线程/17.jpg)

这是 JDK 1.5 新增的处理 Java 多线程并发编程的工具包，其中包含了许多线程安全的并发类。

## 20、++是线程安全的吗？

i++不是线程安全的，来看下面的示例，验证下 i++到底是不是线程安全的。

##### 1000 个线程，每个线程对共享变量 count 进行 1000 次++操作。

```java
static int count = 0;
static CountDownlatch cdl = new CountDownLatch(100e);

public static void main(String[] args) throws Exception {
    CountRunnable countRunnable = new CountRunnable();
    for (int i = 0; i < 1000; i++) {
        new Thread(countRunnable).start();
    }
    cdl.await();
    System.out.println(count);
}

static class CountRunnable implements Runnable {
    private void count() {
        for (int i = 0; i < 1000; i++) {
            count++;
        }
    }

    @Override
    public void run() {
        count();
        cdl.countDown();
    }
}
```

上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++操作它不是线程安全的了。

先来看 JIMM 模型中对共享变量的读写原理吧。

![](/images/多线程/20.jpg)

每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。

问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。

**这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？**答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。

##### 解决方案

说了这么多，对于 i++这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。

1、对 i++操作的方法加同步锁，同时只能有一个线程执行 i++操作；

2、使用支持原子性操作的类，如`java.util.concurrent.atomic.AtomicInteger`它使用的是 CAS 算法，效率优于第 1 种；

## 21、怎么让 3 个线程按顺序执行？

比如说有 T1、T2、T3 三个线程，怎么让 3 个线程按顺序执行，T2 在 T1 执行完后执行，T3 在 T2 执行完后执行。

---

##### 有以下几种常用的解决方案：

（1）使用线程的 join 方法；

（2）使用对象的 wait 方法；

（3）使用重入锁 Condition 的 await 方法；

（4）使用 Executors.newSingleThreadExecutorO 创建一个单线程的线程池；

等等...

## 22、编程实现让 3 个线程按顺序执行

用 Java 编程实现让 3 个线程按顺序执行。

> 创建 T1、T2、T3 三个线程，让 3 个线程按顺序执行，T2 在 T1 执行完后执行，T3 在 T2 执行完后执行。

---

示例代码：

```java
public class ExecuteOrderly {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(2000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println("T1 执行完成...");
        });

        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
            System.out.println("T2 执行完成...");
        });

        Thread t3 = new Thread(() -> {
            System.out.println("T3 执行完成...")；
        });

        t1.start();
        t1.join();

        t2.start();
        t2.join();

        t3.start();
    }
}
```

##### 输出结果：

![](/images/多线程/22.jpg)

原理就是使用线程的 join() 方法进行阻塞，具体原理请看并发编程中的《join 方法有什么用？什么原理？》面试题。

## 23、join 方法有什么用？什么原理？

##### join

---

join 是线程 Thread 类的方法，官方的说明是：

> Waits for this thread to die.

等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。

##### join 原理

---

下面是 join 方法的源码：

```java
public final synchronized void join(long millis)throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;
    if (millis <0) {
        throw new IllegalArgumentException("timeout value is negative");
    }
    if (millis == 0) {
        while (isAlive()){
            wait(0);
        }
  }else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= θ) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

可以看出它是利用 wait 方法来实现的，上面的例子当 main 方法主线程调用线程的时候，main 方法获取到了 t 的对象锁，而 t 调用自身 wait 方法进行阻塞，只要当结束或者到时间后才会退出，接着唤醒主线程继续执行。milis 为主线程等待线程最长执行多久，0 为永久直到线程执行结束。

## 24、编程实现一个线程 join 等待的例子

如以下示例代码：

```java
public static void main(String[] args) throws Exception {
    System.out.println("start");
    Thread t = new Thread(() -> {
        for (int i = 0; i < 5; i++) {
            System.out.println(i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
        }
    });
    t.start();
    t.join();

    System.out.println("end");
}
```

结果输出：

> start
>
> 0
>
> 1
>
> 2
>
> 3
>
> 4
>
> end

线程 t 开始后，接着加入 t.join() 方法，t 线程里面程序在主线程 end 输出之前全部执行完了，说明 t,join( 阻塞了主线程直到 t 线程执行完毕，如果没有 t.join0，end 可能会在 0 ～ 5 之间输出。

## 25、如何让一个线程休眠？

线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。

##### 来看下面的休眠程序：

```java
Thread.sleep(87000000);
```

你知道休眠多久吗？

再把上面的稍微改装下：

```java
Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);
```

现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。

其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？

##### 优雅又简单的方式来了：

```java
TimeUnit.DAYs.sleep(1);
TimeUnit.MINUTES.sleep(10);
或者
TimeUnit.HOURS.sleep(24);
TimeUnit.MINUTES.sleep(10);
```

使用`java.util.concurrent.TimeUnit`类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？

上面演示了 HOURS、MINUTES，还有更多的枚举可以用。

##### 来看下 TimeUnit 的详细方法和枚举值：

![](/images/多线程/25.jpg)

其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。

我们随便来看一个枚举值：

```java
MINUTES {
    public long toNanos(long d){
        return x(d, C4/co, MAx/(C4/ce));
    }
    public long toMicros(long d) {
        return x(d, C4/C1, MAx/(C4/C1));
    }
    public long toMillis(long d) {
        return x(d, C4/C2, MAx/(C4/c2));
    }
    public long toseconds(long d) {
        return x(d, C4/C3, MAX/(C4/c3));
    }
    public long toMinutes(long d) {
        return d; }
    public long toHours(long d){
        return d/(c5/C4);
    }
    public long toDays(long d){
        return d/(c6/C4);
    }
    public long convert(long d, TimeUnit u) {
        return u.toMinutes(d);
    }
    int excessNanos(long d, long m) {
        return 0;
    }
}
```

可以很方便的把分钟转换成各种单位的值。

##### 再来看一下 TimeUnit 休眠的原理：

```java
public void sleep(long timeout) throws InterruptedException {
    if (timeout >0){
        long ms = toMillis(timeout);
        int ns = excessNanos(timeout, ms);
        Thread.sleep(ms, ns);
    }
}
```

其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。

## 26、启动一个线程是用 start 还是 run 方法？

##### 答：使用 start 方法。

因为当用 startO 开始一个线程后，线程就进入就绪状态，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行。如果调用 run(方法，表示在当前线程同步执行的逻辑，并不是启动该线程异步执行。

## 27、一个线程多次调用 start 会发生什么？

如以下示例代码：

![](/images/多线程/27_1.jpg)

输出结果：

![](/images/多线程/27_2.jpg)

很显明，多次调用 start 方法会抛出异常：

> java.lang.llegalThreadStateException

因为第一次 start 后，线程的状态就从 New 变成其他状态了，就不能再次启动了。

## 28、start 和 run 方法有什么区别？

首先要知道实现多线程最基本的两种方式：

1、继承`java.lang.Thread`类；

2、实现`java.lang.Runnable`接口；

其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 runO 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run0 方法，是多线程真正运行的主方法。

```java
@FunctionalInterface
 public interface Runnable {
     public abstract void run();
 }
```

而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。

所以 start()方法只是标识线程为就绪状态的一个附加方法，以下 start()方法的源码，其中 start()是一个本地 native 方法。

```java
public synchronized void start() {
    if (threadstatus i = 0)
        throw new IllegalThreadstateException();
    group.add(this);

    boolean started = false;
    try {
        starte();
        started = true;
    }finally {
        try {
            if (!started) {
                group.threadstartFailed(this);
            }
        }catch (Throwable ignore){
            /* do nothing. If starto threw a Throwable then
            it will be passed up the call stack */
        }
    }
}
```

请注意，start0 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。

**那么你会问了，为什么要有两个方法，直接用一个 runO 方法不就行了吗！？**还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。

```java
public static void main(string[] args) {
    Thread thread = new Thread(() -> {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
        System.out.println("Java面试题");
    });

    long start = System.currentTimemillis();
    thread.start();
    System.out.printin(system.currentTimeMillis() - start);

    start = System.currentTimeMillis();
    thread.run();
    System.out.println(system.currentTimeMillis() - start);
}
```

程序输出：

> 0
>
> Java 面试题
>
> 3000
>
> Java 面试题

从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。

## 29、sleep 和 wait 方法有什么区别？

sleep(休眠)和 wait(等待)方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。

##### 区别 1：使用限制

使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。

```java
try {
    Thread.sleep(3000L);
} catch (Interruptedexception e) {
    e.printStackTrace();
}
```

而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。

```java
synchronized (lock) {
    try flock.wait();
} catch (InterruptedException e) {
    e.printstackTrace();
}
```

而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。

```java
synchronized (lock) {
    // 随机唤醒
    lock.notify();

    //唤醒全部
    lock.notifyAll();
}
```

当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。

##### 区别 2：使用场景

sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。

##### 区别 3：所属类

sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。

> java.lang.Thread#sleep

```java
public static native void sleep(long millis) throws InterruptedException;
```

> java.lang.Object#wait

```java
ublic final native void wait(long timeout) throws InterruptedException;
```

##### 为什么要这样设计呢？

因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待,前提是要获得对象的锁，所以是类的方法。

##### 区别 4：释放锁

```java
bject lock = new object();
synchronized (lock) {
    try {
        lock.wait(3000L);
        Thread.sleep(2000L);
    } catch (Interruptedexception e) {
        e.printstackTrace();
    }
}
```

如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。

##### 区别 5：线程切换

sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不会强制进行上下文切换。

相反，wait 会使当前线程进入等待状态，释放对象的监视器锁，并允许其他线程获得该锁并继续执行。等待状态的线程只有在其他线程调用相同对象上的 notify 或 notifyAll 方法时才会被唤醒，然后才能继续执行。

## 30、Thread.yield 方法有什么用？

我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。

那 yield()方法是干什么用的呢？来看下源码。

```java
public static native void yield();
```

yield 即“谦让"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。

yield 一般很少使用，如果一定要用它的话，一句话解释就是：

> yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。

## 31、yield 和 sleep 有什么区别？

##### yield 和 sleep 的相同点：

1） yield 和 sleep 都能暂停当前线程；

2）yield 和 sleep 在暂停过程中，如已经持有锁，则都不会释放锁资源；

##### yield 和 sleep 的不同点：

1）sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分；

2）yield 不能被中断，而 sleep 则可以接受中断；

## 32、编程实现一个线程谦让（yield）的例子

下面是一个线程谦让（yield）的使用示例：

```java
public static void main(string[] args) {
    Runnable runnable = () -> {
        for (int i = 0; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() ++1);;
            if (i % 20 == 0) {
                Thread.yield();
            }
        }
    };

    new Thread(runnable, "强哥").start();
    new Thread(runnable, "小蜜").start();
}
```

这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。

##### 运行以上程序，可以有以下两种结果。

结果 1：强哥让出了 CPU 资源，小蜜成功上位。

> 强哥-----29
>
> 强哥-----30
>
> 小蜜-----26
>
> 强哥-----31

结果 2：强哥让出了 CPU 资源，强哥继续运行。

> 强哥-----28
>
> 强哥-----29
>
> 强哥-----30
>
> 强哥-----31

而如果我们把两个线程加上线程优先级，那输出的结果又不一样。

```java
thread1.setPriority(Thread.MIN_PRIoRITY);
thread2.setPriority(Thread.MAX_PRIORITY);
```

因为给小蜜加了最高优先权，强哥加了最低优先权，即使强哥先启动，那小蜜还是有很大的概率比强哥先会输出完的，大家可以试一下。

## 33、怎么理解 Java 中的线程中断？

在之前的《如何优雅地终止一个线程？》面试题中，我详细说明了 stop 终止线程的坏处及如何优雅地终止线程，那么还有别的可以终止线程的方法吗？

答案是肯定的，它就是我们今天要分享的---**线程中断**。

下面的这断代码大家应该再熟悉不过了：

```java
try {
    Thread.sleep(1000);
} catch (Interruptedexception e) {
    e.printstackTrace();
}
```

线程休眠需要捕获或者抛出线程中断异常，也就是你在睡觉的时候突然有个人冲进来把你吵醒了，此时线程被打断后，代码会继续运行或者抛出异常结束运行，但这并不是我们需要的中断线程的作用。

线程中断即线程运行过程中被其他线程给打断了，我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！

##### 1、 java.lang.Thread#interrupt

中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。

##### 2、 java.lang.Thread#islnterrupted()

判断目标线程是否被中断，不会清除中断标记。

##### 3、 java.lang.Thread#interrupted

判断目标线程是否被中断，会清除中断标记。

> 具体使用可以参考线程中断的编程实战面试题。

## 34、编程实现一个线程中断的例子

我们来实例演示下线程中断如何用！

##### 示例 1 (中断失败)

```java
private static void test1() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();
        }
    });
    thread.start();
    thread.interrupt();
}
```

请问示例 1 中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。

##### 示例 2:(中断成功)

```java
private static void test2() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();

            //购应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Java技术栈线程被中断，程序退出。 ");
                return;
            }
        }
    });
    thread.start();
    thread.interrupt();
}
```

我们给示例 2 加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。

##### 示例 3 (中断失败)

```java
private static void test3() throws InterruptedException {
    Thread thread = new Thread(() -> {
        while (true) {
            //购应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.printin("Java技术栈线程被中断，程序退出。");
                return;
            }

            try {
                Thread.sleep(300e);
            } catch (InterruptedException e) {
                System.out.println("Java技术栈线程休眠被中断，程序退出。");
            }
        }
    });
    thread.start();
    Thread.sleep(2000);
    thread.interrupt();
}
```

示例 3 sleep() 方法被中断，并输出了 Java 技术栈线程休眠被中断，程序退出。程序继续运行...为什么呢？

来看 sleep 的源码：

![](/images/多线程/34.jpg)

可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。

##### 示例 4 (中断成功)

```java
private static void test4() throws InterruptedException {
    Thread thread = new Thread(() -> {
        while (true) {
            //购应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Java技术栈线程被中断，程序退出。");
                return;
            }


            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                System.out.println("Java技术栈线程休眠被中断，程序退出。");
                Thread.currentThread().interrupt();
            }
        }
    });
  thread.start();
    Thread.sleep(2000);
    thread.interrupt();
}
```

示例 4 全部信息输出并正常退出，只是在 sleep()方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。

## 35、线程中断与 stop 的区别？

线程的 stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号：

- 如果目标线程没有接收中断信号，则线程不会有任何反应；

- 如果目标线程接收了中断信号，则是否结束线程或者执行其他逻辑则由目标线程决定；

## 36、你怎么理解多线程分组？

和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组，来看下线程类 Thread 的所有构造方法，如下图所示：

![](/images/多线程/36_1.jpg)

如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。

线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。

```java
java.lang.ThreadGroup#ThreadGroup(java.lang.String) java.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)
```

![](/images/多线程/36_2.jpg)

线程组中比较有用的几个方法：

> //获取当前线程组内的运行线程数
>
> java.lang.ThreadGroup#activeCount
>
> //中断线程组内的所有线程
>
> java.lang.ThreadGroup#interrupt
>
> //使用 System.out 打印出所有线程信息
>
> java.lang.ThreadGroup#list()

线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。

另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。

## 37、编程实现一个线程分组的例子

如下面的示例代码：

```java
public static void main(string[] args) {
    Runnable runnable =() -> {
        System.out.println("Java技术栈线程线程组名称：" + Thread.currentThread()·getThreadGroup());
        System.out.println("Java技术栈线程线程名称："+Thread.currentThread()·getName());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    };

    ThreadGroup userGroup = new ThreadGroup("user");
    userGroup.SetMaxPriority(Thread.MIN_PRIoRITY);

    Thread userTask1 = new Thread(userGroup, runnable,,"user-taski");
    Thread userTask2 = new Thread(userGroup, runnable,,"user-task2");

    userTaski.start();
    userTask2.start();

    System.out.println("Java技术栈线程线程组活跃线程数："+userGroup.activeCount());
    userGroup.list();
}
```

程序输出以下结果：

> Java 技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
>
> Java 技术栈线程线程名称：user-task1
>
> Java 技术栈线程线程组活跃线程数：2
>
> Java 技术栈线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]
>
> Java 技术栈线程线程名称：user-task2
>
> java.lang.ThreadGroup[name=user,maxpri=1]
>
> Thread[user-task1,1,user]
>
> Thread[user-task2,1,user]

## 38、你怎么理解 wait、notify、notifyAll？

wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法：

- **wait**：让持有该对象锁的线程等待；
- **notify**：唤醒任何一个处于 waiting 状态的线程；
- **notifyAll**：唤醒所有处于 waiting 状态的线程；

它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify/ notifyAll 方法唤醒调用 wait 暂时的线程，这样就实现了线程之间的通信。

## 39、wait、notify、notifyAll 它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢？

因为每个对象都有监视锁，每个线程要操作某个对象，当然是要获取某个对象的锁了，而不是线程的锁，所以 wait/notify/notifyAll 它们都是 Object 类的方法：

![](/images/多线程/39.jpg)

如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。

## 40、使用 wait,notify,notifyAll 有什么要注意的吗？

下面我总结了几个重要的注意事项：

（1）调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；

（2）调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；

（3）多线程使用 notify 容易发生死锁，一般使用 notifyAll；

## 41、编程实现一个线程 wait 等待的例子

如下面的使用示例：

```java
public static void main(string[] args) {
    object lock = new object();
    Thread t1 = new Thread(() -> {
        synchronized (lock) {
          for (int i = 0; i < 20; i++) {
                System.out.print(1);
                if (i == 10) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printstackTrace();
                    }
                }
            }
        }
    });
    Thread t2 = new Thread(() -> {
        synchronized (lock) {
            try {
                Thread.sleep(500e);
            } catch (Interruptedexception e) {
                e.printstackTrace();
            }
            System.out.print("Java技术栈");
            lock.notifyAll();
        }
    })；

  t1.start();
  t2.start();
}
```

上面的例子结合 wait/ notifyAll 来演示了它们的相互作用，线程 t1 首先输出`012345678910`，5 秒后继续输出`Java技术栈111213141516171819`。

## 42、线程池中的线程抛出了异常，如何处理？

在实际开发中，我们常常会用到线程池，但任务一旦提交到线程池之后，如果发生异常之后，怎么处理？怎么获取到异常信息？

##### 方案 1：

---

在线程具体的处理逻辑中使用 try-catch 异常块包装一下，然后使用 log.error 输出即可，有需要还可以做对应的异常处理。

##### 方案 2：

---

如果嫌 try-catch 太麻烦的话，可以构建一个自定义的 ThreadFactory 线程工厂，然后设置 Thread 线程的`Thread.setDefaultUncaughtExceptionHandler`方法捕获异常。

示例代码如下：

```java
@Restcontroller
@slf4j
public class Test fpublic static void main(string[] args) throws InterruptedException {
    ThreadFactory factory = (Runnable r) -> {
        Thread t = new Thread(r);
        t.setDefaultuncaughtExceptionHandler((Thread thread1, Throwable e) -> {
            System.out.println("error..." + e.getMessage());
        });
        return t;
    };

    ExecutorService executorservice = new ThreadPoolexecutor(10,10,0,TimeUnit.MILLISECONDS,new LinkedBlockingQueue(100),factory);
    executorservice.execute(new task());
}

class task implements Runnable {
    @override
    public void run() {
        int i =1 / 0;
    }
}
```

## 43、同步和异步的区别？

![](/images/多线程/43.jpg)

##### 同步：Synchronous

同步是阻塞执行的，即从程序调用方法开始，一旦调用就必须等待方法执行完返回，程序才能继续执行下面的代码。

一般正常的程序都是同步执行的，即程序后面的逻辑必须等前面所有的逻辑执行完才能被执行，比如，付款时必须先判断余额够不够，账户是否正常等。

> ##### 举个同步例子：
>
> 你去银行 ATM 取钱，你必须等到 ATM 吐完钱，你拿到钱，取完卡后你才能离开。

##### 异步：Asynchronous

异步是非阻塞执行的，则不会关心方法执行的过程，触发要调用的方法就继续执行下面的操作，不会像同步那样阻塞直要到方法完成才继续，比如账号注册成功发邮件、消息推送等，不需要阻塞就能继续去执行别的逻辑。

> ##### 举个异步例子：
>
> 你这次要取钱，数量较大，你直接电话或者 APP 预约银行说你要取多少万现金，这段时间银行会为你准备钱，而这与你都没什么关系，然后你只要按预定的时候去取就行了，对你于而言，你们是触发了一个异步动作而已。

## 44、什么是死锁？

死锁如下图所示：

![](/images/多线程/44.jpg)

死锁指多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。

## 45、怎么避免死锁？

##### （1）按顺序加锁

上个例子线程间加锁的顺序各不一致，导致死锁，如果每个线程都按同一个的加锁顺序这样就不会出现死锁。

##### （2）获取锁时限

每个获取锁的时候加上个时限，如果超过某个时间就放弃获取锁之类的。

##### （3）死锁检测

按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。

## 46、什么是活锁？

活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。

活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。

## 47、什么是无锁？

**无锁**，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过 JDK 的 CAS 原理及应用即是无锁的实现。

可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合下是非常高效的。

## 48、什么是线程饥饿？

我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，**这就是饥饿**。

当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。

## 49、编程实现一个多线程死锁的例子

用 Java 编程实现一个多线程死锁的例子。

---

下面是一个多线程死锁的例子：

```java
public class Test {
    private static object lock1 = new object();
    private static object lock2 = new object();

    public static void main(string[] args) {
        new Thread(() -> {
            synchronized (lock1) {
              System.out.println("thread1 get lockl");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printstackTrace();
                }
                synchronized (lock2) {
                    System.out.println("thread1 get lock2");
                }
                System.out.println("thread1 end");
            }
        }).start();

        new Thread(() -> {
            synchronized (lock2) {
                System.out.println("thread2 get lock2");
                try {
                    Thread.sleep(1000);
                } catch (Interruptedexception e) {
                    e.printstacktrace();
                }
                synchronized (lock1) {
                    System.out.println("thread2 get lock1");
                }
                System.out.printin("thread2 end");
            }
        }).start();
    }
}
```

##### 输出结果：

thread1 get lock1

thread2 get lock2

两个线程相互得到锁 1，锁 2，然后线程 1 等待线程 2 释放锁 2，线程 2 等待线程 1 释放锁 1，两个线程互相等待对方释放锁，这样形成死锁。

## 50、Atomiclnteger 的底层实现是怎样的？

Atomiclnteger 它是 int 类型的原子性操作类，它的底层实现就是 CAS 算法，CAS 算法的底层实现就是 sun.misc.Unsafe 这个类。

> 具体可以看 CAS 相关的面试题。

## 51、什么是 CAS？

##### CAS：Compare and Swap，即比较再交换。

CAS 它是一种乐观锁算法，CAS 有 3 个操作数：

- 旧的预期值 A
- 内存值 V
- 要修改的新结果值 B

当预期值 A 和内存值 V 相同时，将内存值 V 修改为结果值 B，否则什么也不做，继续循环直到匹配成功为止，具体如下图所示：

![](/images/多线程/51.jpg)

> JDK 5 之前，Java 语言是靠 synchronized 关键字保证同步的，这是一种独占锁，也是悲观锁。
>
> JDK 5 增加了并发包 java.util.concurrent.\*，其下面的类使用 CAS 算法实现了区别于 synchronouse 同步锁的一种乐观锁。

## 52、CAS 有什么缺点？

##### CAS 有以下几个缺点：

（1）CAS 是基于比较再交换，如果失败循环次数过多，导致 CPU 的消耗就比较大；

（2）只能保证一个变量的原子操作，无法同时多个变量的原子操作，比如：一次修改 3 个变量的值，要么全部成功，要么全部失败；

（3）会出现 ABA 问题。

## 53、CAS 底层使用了哪个操作类？

CAS 都会调用 sun.misc.Unsafe 这个类进行操作，我们随便看个 CAS 所调用到的 Unsafe 类的方法，如

`java.util.concurrent.atomic.Atomiclnteger`类的一个方法：

![](/images/多线程/53_1.jpg)

![](/images/多线程/53_2.jpg)

所以，底层操作就是 Unsafe 类，它是不安全的，在应用程序中不建议开发者自行使用。

## 54、CAS 在 JDK 中有哪些应用？

CAS 在 JDK 原子类中有大量应用， 如： java.util.concurrent.atomic 中的 AtomicXXX：

![](/images/多线程/54.jpg)

它们都是 CAS 乐观锁的实现和应用。

## 55、用伪代码写一个 CAS 算法的核心

假如有变量 ×，内存值 V，I 旧的预期值 A，要修改的新值 B，用伪代码写了 CAS 算法的核心

---

CAS 的核心就是循环比较内存值与预期 I 旧值是否相等，相等再更新为新值，不相等则继续自循环。CAS 它是一种乐观锁算法，CAS 有 3 个操作数：

- 旧的预期值 A
- 内存值 V
- 修改的新结果值 B

##### 下面是伪代码，仅供参考：

```java
X = 0
while (true) {
    if (A = V) {
        X = B;
        break;
    }
}
```

## 56、多线程情况下，进行数字累加（count++）要注意什么？

要注意给累加方法加同步锁，不然会出现变量可见性问题，变量值被其他线程覆盖出现不一致的情况。

有以下几个解决方案：

（1）累加方法加 synchronized/ Lock 同步锁；

（2）使用 Atomiclnteger/ AtomicLong 原子类；

##### （3）使用 LongAdder 原子类（推荐使用）；

## 57、有了 Atomiclnteger，为什么 JDK 又搞出了 LongAdder？

我们都知道在 JDK 5 中搞出了 Atomiclnteger、AtomicLong 等原子类，这也是在 JDK 8 之前普遍用的原子性操作类，来看下 AtomicLong 的累加源码：

![](/images/多线程/57_1.jpg)

大家都知道这些原子类都是通过 CAS 算法实现的乐观锁，通过旧值和现有的值不断循环比对，直到比对成功才修改成功结束循环。

这样就会有一个问题，如果并发数很高的话，就会造成过多的没有必要的“**循环**”，这势必会影响 CPU 的性能。

所以，JDK 8 又搞出来了一个 **LongAdder**，它也在 Atomic 原子包下：

![](/images/多线程/57_2.jpg)

## 58、AtomicXXX 和 LongAdder，推荐用哪个？

除了 Atomiclnteger、AtomicLong，其实在 JDK 8 中更建议使用 **LongAdder** 进行原子性操作，性能更好，如果你使用的还是 JDK 7-，那当我没说，即使如此，也不能找借口不知道，毕竟 JDK8 是现在的主流应用版本了。

##### 阿里巴巴最新的 Java 开发手册是这么定义的：

![](/images/多线程/58.jpg)

## 59、LongAdder 为什么性能更好？原理是什么？

来分析下 LongAdder 类的源码：

![](/images/多线程/59_1.jpg)

在 LongAdder 中维护了一个 Cell 数组，当 Cell 它不为空时，size 是 2 的次幂大小，每个 Cell 数组里面都有一个初始值为 0 的 long 变量，用来存储每个 Cell 的值：

![](/images/多线程/59_2.jpg)

然后其中的 sum 方法用来对 Cell 数组进行求和再加上 base 基础值进行返回：

![](/images/多线程/59_3.jpg)

##### 关于 base 基础值：

LongAdder 并不会一开始就创建 Cell 数组，其本身也会维护一个 base 基础值，当 CAS 更新失败时才进行创建或者扩容。

##### 来看下 AtomicXXX 和 LongAdder 更新对比图：

![](/images/多线程/59_4.jpg)

Cell 数组相当于一个分段的概念，把 AtomicXXX 中的一个值分成了多个值来进行管理，当 CAS 更新失败时不再当前循环重试，而是尝试获取其他的资源锁，这样就降低了对于 AtomicXxX 中的单个资源的竞争，所以 LongAdder 的性能更高。

## 60、LongAdder 性能那么好，那有没有什么缺点呢？

LongAdder 虽然带来了良好的性能，但代价肯定也是有的，**它既然维护了 Cell 数组，也就意味着要占用更多的内存空间。**

> 以空间换时间，也是值得的。

## 61、LongAccumulator 是什么？

LongAccumulator 类在 JDK 8+ 中的 atomic 包中：

![](/images/多线程/61_1.jpg)

LongAccumulator 可以理解为 LongAdder 的增强版，它的功能要比 LongAdder 要更强大，或者说，LongAdder 只是 LongAccumulator 的一个实现而已。

比如：LongAdder 只能进行数字的简单加减（只能是 1），而 LongAccumulator 提供了自定义的函数式接口，可以根据规则进行累加，不管是加减多少，或者是乘除多少，或者取最大值，想怎么弄，规则自己定。

如源码所示：

![](/images/多线程/61_2.jpg)

这个类也是 JDK 1.8 中新加的，与 LongAdder 不同的是，它的构造器提供了两个参数：

- LongBinaryOperator：函数式接口参数；
- identity：初始值；

![](/images/多线程/61_3.jpg)

LongBinaryOperator 函数式接口方法需要两个 long 值（左值+右值），并最终返回一个 long 值。

## 62、LongAccumulator 和 LongAdder 怎么选？

LongAccumulator 有一个初始值，并且提供了一个自定义规则的函数式接口参数，功能要比 LongAdder 更强大，可以理解为 LongAdder 是 LongAccumulator 的一个实现，或者是 LongAccumulator 是 LongAdder 的增加版。

##### 一句话总结就是：

在低更新争用下，这两个类具有相似的特征，但是在高争用情况下，该类的预期吞吐量显著提高，代价是空间消耗增加。简单递增、递减 1 用 LongAdder 就够了，复杂的累积运算用 LongAccumulator。

## 63、编程：使用 LongAccumulator 实现一个 LongAdder

> 用 LongAccumulator 来实现 LongAdder 同样的功能。

##### 定义一个累加规则的 LongAccumulator：

```java
private static LongAccumulator longAccumulatorAdd = new LongAcumulator((left, right) -> left + right, 0);
```

##### 使用 LongAccumulator 进行累加：

```java
private static final int MAX_PooL_SIZE = 10;

private static void add(LongAccumulator longAccumulator, long number) throws InterruptedException {
    long start = System.currentTimeMillis();Executorservice es = Executors.newFixedThreadPool(MAx_PooL_SIzE);
    for (int i = 0; i < MAX_POOL_SIzE; i++) {
        es.execute(() -> {
            for (int j = 0; j < MAX_LOOP_SIzE; j++) {
                longAccumulator.accumulate(number);
            }
        });
    }
    es.shutdown();
    es.aWaitTermination(5, TimeUnit.MINUTES);
    System.out.printf("LongAccumulator %s*%s +%s 结果：%s，耗时：%sms.\n",
                      MAX_POOL_SIZE,
                      MAX_LOOP_SIZE,
                      number,
                      longAccumulator.get(),
                      (System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

##### 测试一下：

```java
public static void main(string[] args) throws InterruptedException {
    // 和LongAdder一致
    add(longAccumulatorAdd, 1);

    // 每次累加2
    add(longAccumulatorAdd, 2);
}
```

第一次调用方法实现了和 LongAdder 一样的功能，第二次调用方法是每次累加 2，这个是 LongAdder 所办不到的。

##### 输出结果：

![](/images/多线程/63.jpg)

## 64、编程：使用 LongAccumulator 实现求最大值

> 实现一个自定义规则的运算，求所有值的最大值。

定义一个取最大值规则的 LongAccumulator：

```java
ivate static LongAccumulator longAccumulatorMax = new LongAccumulator(Long::max, 50);
```

这里使用了方法引用，这也是 Java 8 引进的新语法。

##### 使用 LongAccumulator 进行取最大值：

```java
private static final int MAx_PoOL_sIZE = 10;

private static void max(LongAccumulator longAccumulator) throws Interruptedexception {
    long start = System.currentTimeMillis();
    ExecutorService es = Executors.newFixedThreadPool(MAx_PooL_SIZE);
    for (int i = 0; i < MAx_POOL_SIzE; i++) {
        int finall = i;
        es.execute(() ->{
            longAccumulator.accumulate(finall * 10);
        });
    }
    es.shutdown();
    es.awaitTermination(5, TimeUnit.MINUTES);
    System.out.printf("LongAccumulator 求最大值结果：%s， 耗时：%sms.\n",
                      longAccumulator.get(),(System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

##### 测试一下：

```java
public static void main(string[] args) throws Interruptedexception {
    // 和LongAdder一致
    add(longAccumulatorAdd, 1);
    // 每次累加2
    10add(longAccumulatorAdd, 2);
    // 求最大值
    max(longAccumulatorMax);
}
```

初始值为 50，循环中的最大值应该是 9＊10=90，来看下测试结果：

![](/images/多线程/64.jpg)

没毛病，结果输出正常。

当然，求最大值远远不会用到这个类，这里只是演示下这个自定义规则而已，你可以求乘积，更复杂的判断运算等其他自定义规则的运算，有了自定义规则，那它所能实现的功能远比 LongAdder 要强大，并且其性能也是旗鼓相当的。

## 65、阻塞和非阻塞的区别？

**阻塞**：Blocking，如果一个线程占用了一个对象的锁而没有释放，其他的线程想要继续执行就只能等它释放锁，这时候就造成阻塞了，比如用 synchronized 修饰的方法就是阻塞的。

**非阻塞**：Non-Blocking，就是没有阻塞，所有线程都没有锁定任何对象，都可以自由运行，不相互阻塞运行，比如 CAS 乐观锁就是非阻塞的。

## 66、并发和并行的区别？

**并发**：Concurrency，即一段时间内多个任务在执行，但它们不一定同时在被 CPU 在调度执行，它们可能是交替在运行，也有可能是串行运行的。

**并行**：Parallelism，这个就是多个任务在被 CPU 同时调度执行，可以理解为并发里面有一部分任务真正在并行执行。

> 单核 CPU 不会有并行操作，因为一个 CPU 一次只能执行一条指令，并行操作只存在于多核 CPU 中。

## 67、为什么不推荐使用 stop 停止线程？

我们的系统肯定有些线程为了保证业务需要是要常驻后台的，一般它们不会自己终止，需要我们通过手动来终止它们。

我们知道启动一个线程是 start 方法，自然有一个对应的终止线程的 stop 方法，通过 stop 方法可以很快速、方便地终止一个线程，我们来看看 stop 的源代码：

![](/images/多线程/67.jpg)

通过注解 @Deprecated 看出 stop 方法被标为废弃的方法，JDK 在以后的版本中可能被移除，不建议大家使用这种 APl。

##### 那为什么这么好的一个方法怎么不推荐使用，还要标注为废弃呢？

假设有这样的一个业务场景，一个线程正在处理一个复杂的业务流程，突然间线程被调用 stop 而意外终止，这个业务数据还有可能是一致的吗？这样是肯定会出问题的，stop 会释放锁并强制终止线程，造成执行一半的线程终止，带来的后果也是可想而知的，这就是为什么 JDK 不推荐使用 stop 终止线程的方法的原因，因为它很暴力会带来数据不一致性的问题。

正因为 stop 方法太过暴力，所以一般不推荐使用，除非你非常清楚你自己的业务场景，用 stop 终止不会给你的业务带来影响。

## 68、如何优雅地终止一个线程？

##### 如何优雅地终止一个线程呢？看看下面的程序：

```java
public class TaskThread extends Thread {

    private static volatile boolean stop = false;
    @override
    public void run() {
        while (lstop) {
            // ...
        }
    }

    public static void main(string[] args) throws InterruptedException {
        TaskThread thread = new TaskThread();
        thread.start();
        TimeUnit.SECONDS.sleep(3);
        stop = true;
    }
}
```

其实也不难，只需要添加一个 volatile 变量，判断这个变量在某个值的时候就退出循环，这时候每个循环为一个整合不被强行终止就不会影响单个业务的执行结果。

##### 另外，使用线程中断功能也能优雅的终止一个线程，具体请查看线程中断相关面试题。

怎么理解 Java 中的线程中断？

## 69、什么是重入锁（ReentrantLock)？

重入锁（ReentrantLock）是一种高级的同步机制，用于控制多个线程对共享资源的访问，它允许同一个线程多次获得同一个锁,从而实现锁的重入特性，所以叫做重入锁。

在 Java 中，重入锁的实现由`java.util.concurrent.locks.ReentrantLock`类提供的，它是 JDK 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。

![](/images/多线程/69.jpg)

从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。

> java.util.concurrent.locks.Lock

它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。

## 70、重入锁有哪些重要的方法？

下面这几个方法都是 Lock 接口中定义的：

![](/images/多线程/70.jpg)

##### （1）lock()

获取锁，有以下三种情况：

- 空闲：直接获取锁并返回，同时设置锁持有者数量为：1；

- 前线程持有锁：直接获取锁并返回，同时锁持有者数量递增 1；
- 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；

##### （2）locklnterruptibly()

获取锁，逻辑和 lock()方法一样，但这个方法在获取锁过程中能响应中断。

##### （3) tryLock()

从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false,这个方法不会等待，有以下三种情况：

- 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；
- 前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增 1；
- 其他线程持有锁：获取锁失败，返回：false；

##### （4）tryLock(long timeout, TimeUnit unit)

逻辑和 tryLock() 差不多，只是这个方法是带时间的。

##### （5）unlock()

释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。

##### （6）newCondition

返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/notify 要更灵活，更强大！

## 71、重入锁怎么用？

重入锁一般指的是 ReentrantLock，其大概的用法如下：

```java
class x {
    private final Reentrantlock lock = new Reentrantlock();

    public void m() {
        lock.lock();
        // block until condition holds
        try {
            // ... method body
        }finally {
            lock.unlock()
        }
    }
}
```

加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。

## 72、重入锁你怎么理解“重入"？

##### 为什么叫重入锁呢？

ReentrantLock，我们把它拆开来看就明了了。

Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；

```java
public void m() {
    lock.lock();
    lock.lock();
    try {
        // ... method body
    } finally {
        lock.unlock();
        lock.unlock();
    }
}
```

如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。

试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？

## 73、重入锁最多可重入多少次？

如 ReentrantLock 类注释所示：

![](/images/多线程/73.jpg)

该锁支持同一线程最多 2147483647 个递归锁，也就是最大的可重入次数，超过此限制将导致锁定方法抛出 Error 错误。

## 74、重入锁使用需要注意什么？

##### 需要注意以下事项，否则导致死锁：

（1）释放锁的操作必须在 finally 块里面，不然如果程序发生异常，就会导致锁不能被释放；

（2）取多少次锁，就必须释放多少次锁，每 lock 一次就需要 unlock 一次；

## 75、synchronized 是重入锁吗？怎么实现的？

##### synchronized 是重入锁吗？

---

你可能会说，不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，如果你这样以为，那你就完全错了。

##### 答案是：yes。

为什么？

来看下面的例子：

```java
public synchronized void operation() {
    add();
}

public synchronized void add() {
}
```

operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，synchronized 锁的只是该对象，而不是方法，所以，add(方法可以成功获取当前线程 operation(方法已经获取到的锁。

##### 如果 synchronized 不设计成为重入锁，operation 不就永远不能调用 add 方法了吗！！

##### synchronized 是怎么实现可重入的呢？

---

每个 synchronized 锁都与一个监视器（Monitor）关联，该监视器包含一个计数器和一个所有者线程的引 l 用：

- 线程第一次获取锁时，计数器+1
- 同一个线程再次获取同一个锁，计数器再次+1
- 当线程释放锁时，计数器-1

计数器记录了该线程获取锁的总次数，只有当计数器清 0 时，锁才被该线程完全释放。

## 76、synchronized 与 ReentrantLock 的区别？

synchronized 与 ReentrantLock 的区别如下：

（1） synchronized 是依赖于 JVM 实现的， ReentrantLock 是 JDK 自身实现的；

（2）synchronized 的使用简单，可以自动释放锁，而 ReentrantLock 需要手动释放锁；

（3）ReentrantLock 锁的细粒度要比 synchronized 小；

（4）ReentrantLock 支持公平锁，synchronized 只能是非公平锁；

（5）ReentrantLock 提供了一个 Condition（条件）类，锁要更灵活；

## 77、synchronized 同步锁有哪几种用法？

我们都知道 synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 synchronized 可以用到更多的场合，R 哥列举了以下几个用法。

##### 1、同步普通方法

---

这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。

```java
private synchronized void synchronizedMethod() {
    System.out.printin("synchronizedMethod");
    try {
        Thread.sleep(2000);
    } catch (Interruptedexception e) {
        e.printstackTrace();
    }
}
```

此时，同一个实例只有一个线程能获取锁进入这个方法。

##### 2、同步静态方法

---

同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。

```java
private synchronized static void synchronizedstaticMethod() {
    System.out.println("synchronizedstaticMethod");
    try {
        Thread.sleep(2000);
    }catch (Interruptedexception e) {
        e.printstackTrace();
    }
}
```

同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。

##### 3、同步类

---

下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。

```java
private void synchronizedclass() {
    synchronized (Testsynchronized.class) {
        System.out.printin("synchronizedclass");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    }
}

private void synchronizedGetclass() {
    synchronized (this.getclass()) {
        System.out.println("synchronizedGetclass");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printstackTrace()；
        }
    }
}
```

这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。

##### 4、同步 this 实例

---

这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。

```java
private void synchronizedthis() {
    synchronized (this) {
        System.out.println("synchronizedthis");
        try {
            Thread.sleep(2000);
        } catch (Interruptedexception e) {
            e.printstackTrace();
        }
    }
}
```

用法和同步普通方法锁一样，都是锁住整个当前实例。

##### 5、同步对象实例

---

这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。

```java
private void synchronizedinstance() {
    synchronized (LocK) {
        System.out.println("synchronizedInstance");
        try {
            Thread.sleep(2000);
        } catch (Interruptedexception e) {
            e.printstackTrace();
        }
    }
}
```

另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。

## 78、synchronized 锁的是什么？

synchronized 锁的是什么，这要看它修饰的对象是什么。

##### 1、修饰普通方法

锁的是当前实例对象，只能有一个线程能进入含有该对象锁的方法。

##### 2、修饰静态方法

锁的是当前类的 Class 对象，只能有一个线程能进入含有该 Class 对象锁的方法。

##### 3、修饰代码块

锁的是针对 synchonized 括号里配置的对象，可以是实例对象，也可以是 Class 对象。

---

具体用法可以参考《 synchronized 同步锁有哪几种用法？》面试题。

## 79、synchronized 关键字的底层实现原理？

synchronized 关键字是通过一个 monitor 监视器锁对象来实现的，每个对象都会关联一个 monitor 对象，monitor 对象里面有一个从 0 开始的计数器和一个指定持有锁线程的 owner 指针，线程要对某个对象加锁，则必须获得这个对象关联的 monitor 对象锁。

如线程 A 加锁具体流程如下：

- 如果 synchronized 代码块对象中的 monitor 计数器为 0，则加锁成功，monitor 对象的 owner 变量指向该对象，并把计数器+1，如果同一个线程反复使用 synchronized 获取同一个对象的锁（重入），对应的 monitor 对象计数器会累加；
- 果 synchronized 代码块对象中的 monitor 计数器>= 1，则加锁失败，线程阻塞并等待直到 monitor 对象的计数器为 0，再重新获取锁；
- 退出一个 synchronized 块，对应对象的 monitor 对象的计数器会-1，直到为 0，monitor 对象的 owner 变量值为 null，释放了所有持有的对象锁。

具体是通过**monitorenter**和 **monitorexit** 这两个字节码指令来实现的，它们位于同步块的开始和结束处：

- 当线程执行到每个**monitorenter**指令时，先要获得对应 monitor 对象锁，才能继续执行后面的代码，计数器+1，其他线程无法获取锁，除非锁被释放；
- 线程执行到每个 **monitorexit** 指令时，计数器-1，当计数器为 0 时，则释放了 monitor 对象锁，其他线程才能获得锁。

比如我们有这个测试类：

```java
public class Test {
    private static final object LocK = new object();
    public static void main(string[] args) throws Exception {
        synchronized (LocK) {
            System.out.println("test");
        }
    }
}
```

来看下字节码：

![](/images/多线程/79.jpg)

我们可以看到在 synchronized 关键字开始和结束有 MONITORENTER 和 MONITOREXIT 指令。

## 80、synchronized 可以保证原子性吗？怎么实现的？

可以的，synchronized 关键字可以保证一段代码在同一时刻只能被一个线程执行，在未释放锁之前，其他线程无法再次获取锁，那么这个操作就不会被打断，所以能保证原子性。

## 81、synchronized 可以保证可见性吗？怎么实现的？

可以的，`synchronized`可以保证多线程环境下的可见性，当一个线程获取了某个对象的锁，进入了`synchronized`代码块中，它不仅会获得对共享资源的访问权，还会将本地线程工作内存中的变量刷新到主内存中，从而使得其他线程能够看到最新的值。

当一个线程进入`synchronized`代码块时，它会执行以下操作：

1、**清空工作内存（加锁前）**：清空工作内存中的共享变量值，确保共享变量可以读取主内存中最新的值。

2、**从主内存中读取值（加锁前）**：从主内存中读取共享变量的最新值，将其加载到线程的工作内存中。

3、**执行代码块（加锁后）**：在线程获取锁成功后，线程可以安全地执行 synchronized 代码块内的操作，其它线程无法获取主内存中的共享变量的值。

4、**刷新主内存（解锁前）**：在线程退出`synchronized`代码块前，会将工作内存中修改过的变量值刷新回主内存，确保其他线程能够看到更新后的值。

所以，`synchronized`不仅保证了互斥性，还保证了进入和退出`synchronized`代码块时的内存可见性，这使得多线程环境下的共享变量能够正确地被读取和更新。

## 82、synchronized 可以保证有序性吗？怎么实现的？

是的，synchronized 可以保证一定程度的有序性，当一个线程进入一个 synchronized 块时，它会先获得锁，然后执行块内的操作，在线程释放锁之前，其他线程无法获取相同的锁，这就让多线程并发执行变成了单线程顺序执行，从而确保了代码执行的有序性。

> ##### 需要注意的是：
>
> 这里说的`synchronized`保证有序性是指代码按单线程顺序执行，而不是指执行指令的有序性，`synchronized`并不能禁止指令重排序。

## 83、Java 对 synchronized 锁进行了哪些优化？

JDK 1.6 对 synchronized 关键字做了各种的优化，包括不限于以下优化：

- 锁粗化
- 锁消除
- 锁升级

经过这些锁优化后，synchronized 关键字实现同步也已经不像以前那么慢了。

## 84、什么是读写锁？

读写锁，即：锁分离，读操作和写操作分离。

读写锁接口：ReadWriteLock，读写锁实现类：ReentrantReadWriteLock。

![](/images/多线程/84.jpg)

读写锁维护一个读锁（readLock）和一个写锁（writeLock），它是一个读写分离锁，一个资源它可以同时允许多个线程的读操作（共享锁），或者只能有一个线程的写操作（独占锁），但是不能同时读写，读线程和写线程互斥。

> 读写锁保证线程安全性，读多写少的场景并发性也得到了提升。

| 锁   | 读锁     | 写锁     |
| ---- | -------- | -------- |
| 读锁 | 可访问   | 不可访问 |
| 写锁 | 不可访问 | 不可访问 |

## 85、有没有比 ReadWriteLock 读写锁更快的锁？

有的，在 JDK 8 中可以使用：StampedLock，它还支持乐观读，即可以支持同时有多个读线程和一个写线程，读多写少的场景性能要更好，但它不能够完全代替 ReadWriteLock，功能上它只是 ReadWriteLock 的一个子集而已。

##### 需要注意的是：

（1）StampedLock 不是重入锁；

（2）StampedLock 不支持条件变量；

（3）使用 StampedLock 不要中断线程，否则会导致 CPU 升到 100 %；

## 86、公平锁和非公平锁的区别？

JDK 1.5 并发包中 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁或非公平锁，关于两者区别，Java 并发编程实践里面有解释：

**公平锁**：Threads acquire a fair lock in the order in which they requested it

**非公平锁**：a nonfair lock permits barging: threads requesting a lock can jump ahead of the queue of waiting threads if the lock happens to be available when it is requested.

**公平锁**就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己

**非公平锁**比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式

## 87、有哪些锁优化的方式？

##### 锁优化的方法有以下几种：

##### 1、减少锁持有时间

能锁代码块，就不锁方法，能锁小方法，就不锁大方法，把不用加锁的代码尽量提出去，避免长时间占用锁。

##### 2、减小锁粒度

将一个大锁变为多个小锁，从而降低锁竞争，大大增加并行度。

比如，ConcurrentHashMap 之前的设计，就拆分了 **16** 个 Segment，每次线程只对其一个 Segment 加锁。

##### 3、锁分离

参考：什么是读写锁？

##### 4、锁粗化

参考：1 什么是锁粗化？

##### 5、锁消除

参考：什么是锁消除？

## 88、什么是自旋锁？

锁膨胀后，为了避免线程真实地在操作系统层面挂起，虚拟机还会做最后的努力一一自旋锁。

当前线程暂时获取不到锁，但是如果简单粗暴地将这个线程挂起是一种得不偿失的操作，因此虚拟机会让当前线程**做几个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。**

## 89、什么是锁消除？

锁消除是一种更彻底的锁优化方式，它涉及的一项关键技术：**逃逸分析**，JVM 在 JIT 编译时，通过检测并去除不可能存在共享资源竞争的锁，即去除没有意义的锁，如下面的示例：

```java
public String[] createvectorstrings() {
    Vector<string> vector = new Vector<>();
    for (int i = 0; i< 100; i++) {
        vector.add(Integer.tostring(i));
  }
    return vector.toArray(new String[]{});
}
```

由于 vector 只在方法 createVectorStrings 中使用，所以它只是一个局部变量，局部变量是在线程栈上分配的，属于线程私有变量，因此不可能被其他线程访问。所以，在这种情况下，Vector 内部所有加锁同步都是没有必要的，虚拟机检测到这种情况就会将这些无用的锁操作去除。

> 通过锁消除，可以节省毫无意义的请求锁时间。

## 90、什么是锁粗化？

我们都知道，为了保证多线程的并发性能，每个线程持有锁的时间要尽可能短，虽然单次的同步操作的时间可能很短，但是，如果短时间内进行高频次的加锁与解锁操作，就可能会占用不少系统资源。

JVM 优化了 synchronized 的性能，锁粗化就是其中一种优化方式。**如果 JVM 检测到多次连续的加锁、解锁操作，就会进行锁粗化，把它们合并成一个更大范围的锁操作，以降低短时间内大量锁操作带来的性能损耗。**

##### 比如下面的一个示例：

```java
for (int i = 0; ik 1000; i++) {
    synchronized (LocK){
  // ...
    }
}
```

在一个 for 循环里面，如果使用 synchronized 循环加锁，锁粗化就会把 synchronized 移到循环外面：

```java
synchronized (Lock) {
    for (int i = 0; i < 100e; i++) {
  // ...
    }
}
```

这样就只要加一次锁即可，也不会影响程序的正常运行。

## 91、什么是锁升级？锁升级的过程是怎样的？

在 JDK 1.6 之前，synchronized 还是一个重量级锁，效率比较低下，JDK 1.6 之后，JVM 对 synchronized 锁进行了优化，引 I 入了偏向锁和轻量级锁，自此锁的状态就有了以下四种，锁级别从低到高分别是：

- 无锁
- 偏向锁(JDK 1.6+)
- 轻量级锁(JDK1.6+)
- 重量级锁

初始为无锁状态，然后随着锁竞争情况逐渐对锁进行升级，锁升级过程如下所示：

![](/images/多线程/91.jpg)

锁升级的过程是不可逆的，即不能对锁进行降级。

## 92、什么是偏向锁？

**偏向锁**是一种针对加锁操作的优化手段。

从锁升级的过程可以知道，对象默认为无锁状态，如果一个线程获得了对象锁，那么就进入偏向锁模式，并且执行完同步块之后也不会自动释放偏向锁（当其他线程尝试获取锁，持有偏向锁的线程才会释放偏向锁），当这个线程再次请求锁时，无须再做重复加锁、释放锁操作，这样就节省了大量锁操作，提高了锁性能。

对于没有锁竞争的场合，偏向锁有比较好的性能，因为多次加锁操作极有可能是同一个线程；而对于锁竞争比较激烈的场合，偏向锁效果就不行了，因为每次都可能是不同的线程来加锁。

## 93、什么是轻量级锁？

**轻量级锁**是一种针对加锁操作的优化手段。

升级轻量级锁的两种情况：

- VM 关闭了偏向锁模式；
- 个线程竞争偏向锁，导致偏向锁升级为轻量级锁；

主要说下第二种情况，如果线程获取偏向锁失败，那么虚拟机并不会立即挂起线程，即不会阻塞线程，而是将偏向锁升级为轻量级锁，为什么称为轻量级锁，因为它不会阻塞线程，其他线程会通过自旋的形式尝试获取锁，从而提高了锁性能。

## 94、什么是重量级锁？

如果锁竞争十分严重，在获取轻量级锁时，当某个线程达到了最大自旋次数（默认为 10 次），为了避免带来过多无效的自旋，JVM 就会将轻量级锁升级为**重量级锁**，其他的线程尝试获取锁时，就会真的将自己在操作系统层面挂起，等待被唤醒。

重量级锁完全是由操作系统进行控制的，是依赖操作系统的 MutexLock（互斥锁）实现的，由操作系统来负责线程间的调度和状态变换，比如，操作系统可能会频繁地切换线程运行状态，挂起和唤醒线程等，这都会消耗大量的系统资源。

> JDK 1.6 之前， synchronized 只有重量级锁，这也是为什么 JDK 1.6 之前 synchronized 锁性能差的原因。

## 95、谈谈多线程中的 ExecutorService 接口？

ExecutorService 即 Java 线程池接口：

> java.util.concurrent.ExecutorService

![](/images/多线程/95.jpg)

## 96、谈谈多线程中的 ThreadPoolExecutor 类？

ThreadPoolExecutor 是线程池接口的一个实现类，核心构造器如下：

![](/images/多线程/96.jpg)

具体参数含义可以参考面试题：创建一个线程池有哪些核心参数？

## 97、什么是线程池？

很简单，简单看名字就知道，和连接池的概念一样，线程池它是一个装有线程的池子，我们可以把要执行的多个线程交给线程池来处理，通过维护一定数量的线程池来达到多个线程的复用，而不用反复创建线程，节省系统资源。

## 98、使用线程池有什么好处？

我们知道不用线程池的话，可以通过 new Thread(xxRunnable).start(）的方式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统达到最高效率，然而，当线程数达到一定数量就可能会造成以下问题：

- 耗尽系统的 CPU 和内存资源；
- 造成 GC 频繁收集和停顿；

因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，有了线程池，线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。

## 99、创建一个线程池有哪些核心参数？

线程池构造的所有参数如下面所示：

![](/images/多线程/99.jpg)

参考解释：

| 参数名          | 说明                                                               |
| --------------- | ------------------------------------------------------------------ |
| corePoolSize    | 核心线程数大小，即最小的线程池大小                                 |
| maximumPoolSize | 最大线程池大小                                                     |
| keepAliveTime   | 空余线程存活时间，超过 corePoolSize 的空余线程超过存活时间后才销毁 |
| unit            | 销毁时间单位                                                       |
| workQueue       | 工作队列，存储等待执行的线程                                       |
| threadFactory   | 创建线程的工厂                                                     |
| handler         | 拒绝策略                                                           |

## 100、线程池的工作流程是怎样的？

线程池工作流程如下图所示：

![](/images/多线程/100.jpg)

（1）如果线程池中的线程小于核心线程数**corePoolSize**时，则创建新线程直接执行任务。

（2）如果线程池中的线程大于核心线程数**corePoolSize** 时，则暂时把任务存储到工作队列 **workQueue** 中等待执行。

（3）如果工作队列 **workQueue** 也满时：

- 当线程数小于最大线程池数**maximumPoolSize**时，由创建新线程来处理；
- 线程数大于等于最大线程池数**maximumPoolSize**时，则执行拒绝策略；

## 101、如果把线程池 corePoolSize 设置为 0，会出现什么情况？

> 如果把线程池 corePoolSize 设置为 O，会出现什么情况？

我们来从源码来分析下，看看究竟！

以下是 JDK21 线程池类**ThreadPoolExecutor#execute**方法源码：

```java
ublic void execute(Runnable command) {
    //检查传入的任务是否为空，如果为空则抛出NuLLPointerException
    if (command == null)
        throw new NullpointerException();

    //获取当前线程池的控制状态
    int c = ctl.get();
    //步骤1：如果当前运行的线程数少于核心线程数
    if (workercountof(c) < corePoolsize) {
        //尝试添加一个新的工作线程来执行提交的任务
        //如果添加成功，则直接返回
        if (addworker(command, true))
            return;
        //再次获取线程池的控制状态，以应对并发变化
        C = ctl.get();
    }

    //步骤2
    //步骤2.1：如果线程池处于运行状态并且任务能够成功加入队列
    if (isRunning(c) && workqueue.offer(command)) {
        //再次检查线程池的状态，确认线程池仍然处于运行状态
        int recheck = ctl.get();

        //2.2如果线程池不再运行，并且任务能够从队列中移除，则拒绝任务
        if (lisRunning(recheck) && remove(command))
            reject(command);

        //2.3如果当前线程池没有运行的线程
        else if (workercountof(recheck) == 0)
            //尝试添加一个新的非核心工作线程（faLse表示非核心线程）
            addworker(null, false);
    }
    //步骤3
    else {
        //3.1尝试添加一个新的非核心工作线程来执行任务
        if (laddworker(command, false))
            //3.2如果添加失败，说明线程池已关闭或达到饱和状态，因此拒绝任务
            reject(command);
    }
}
```

> 我检查了 JDK 8 和 JDK 17 两个主版本源码，这块的处理逻辑也是一样的。

从源码可以看到，如果往线程池提交任务的时候，当 corePoolSize=O 时，代码正常情况下会执行到**步骤 2**。

##### 步骤 2.1：

此时，如果线程池处于运行状态，并且任务能够成功加入队列，说明线程池不为空，线程正常执行任务。

##### 步骤 2.3：

此时，如果当前线程池没有运行的线程，**则尝试添加一个新的非核心工作线程**，即任务会先进入队列排队再由线程获取任务执行。

##### 步骤 3.1：

此时，说明队列满了无法加入任务，**尝试添加一个新的非核心工作线程来执行任务**，如果添加失败，说明线程池已关闭或达到饱和状态，因此拒绝任务。

> ##### 扩展知识点：
>
> 这个逻辑在 JDK6 之前略有不同，**在 JDK6 之前，当 corePoolSize=O 的时候，先将这个任务放到阻塞队列中，只有等队列满了才创建线程来执行**，而 JDK 6+是直接创建一个非核心线程，再放在队列中来执行，很显示，JDK 6 这个优化动作减小了内存溢出的可能性。
>
> 光说 JDK 6 和 JDK 8 这两个版本，对线程池的重构就很大，现在主流的版本都是 JDK 8+，这个了解一下就好。

## 102、线程池 ExecutorService 和 Executors 的区别？

ExecutorService 是线程池接口，而 Executors 是 JDK 提供创建内置线程池的工具类：

```java
Executorservice es = Executors.newFixedThreadPool(3);
```

一般建议使用手动 new 的方式创建，以免默认的阻塞队列塞满导致内存溢出。

## 103、Java 里面有哪些内置的线程池？

Executors 是创建线程池的工厂类，它提供了几种常用的线程池工厂方法，而不必我们去手工构造：

![](/images/多线程/103.jpg)

##### 1、newFixedThreadPool

```java
public static Executorservice newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}
```

固定线程池，核心线程数和最大线程数固定相等，而空闲存活时间为 0 毫秒，说明线程永远存活，工作队列为 LinkedBlockingQueue 阻塞队列，最大为 Integer 最大值，待执行线程过多容易造成内存溢出。

当执行任务时，如果线程都很忙，就会丢到工作队列等有空闲线程时再执行，队列满就执行默认的拒绝策略。

##### 2、newCachedThreadPool

```java
public static Executorservice newcachedThreadpool() {
    return new ThreadPoolExecutor(e, Integer.MAx_vALUE,60L, TimeUnit.sEcONDS,new Synchronousqueue<Runnable>());
}
```

缓冲线程池，从构造看核心线程数为 0，最大线程数为 Integer 最大值，所有空闲线程在 60 秒后销毁。

它使用的是 SynchronousQueue 直接提交队列，意味着每个新任务都会有线程来执行，如果线程池有可用线程则执行任务，没有的话就创建一个来执行，线程池中的线程数不确定，一般建议执行速度较快较小的线程，不然这个最大线程池边界过大容易造成内存溢出。

##### 3、newSingleThreadExecutor

```java
public static Executorservice newsingleThreadExecutor() {return new FinalizableDelegatedExecutorservice(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()));
}
```

单线程线程池，核心线程数和最大线程数均为 1，空闲线程存活 0，线程永远存活，每次只执行一个线程，多余的先存储到工作队列，一个一个执行，保证了线程的顺序执行。

##### 4、newScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolsize) {
    return new ScheduledThreadPoolExecutor(corePoolsize);
}
```

调度线程池，即按一定的周期执行任务，即定时任务，对 ScheduledThreadPoolExecutor 进行了包装而已，另外还有对应的 newSingleThreadScheduledExecutor 单个调度线程池的创建方法。

##### 5、newWorkStealingPool (JDK 8+)

```java
public static Executorservice newiorkstealingpool(int parallelism) {
    return new ForkJoinPool(parallelism,ForkJoinPool.defaultForkJoinWorkerThreadFactory,null, true);
}
```

Fork/Join 线程池，使用的是 ForkJoinPool 框架构造的线程池，具体见 Fork/Join 相关面试题。

## 104、为什么阿里不让用 Executors 创建线程池？

因为 newSingleThreadExecutor 和 newFixedThreadPool 这两个线程池在`workQueue`参数使用了`new LinkedBlockingQueue<Runnable>()`阻塞队列，如源码所示：

```java
public static Executorservice newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nthreads, nThreads,OL, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}
```

LinkedBlockingQueue 的最大容量为 Integer 的最大值，所以它理论上可以无限添加待运行的任务到线程池队列，如果提交到线程池的任务过多，可能就会导致内存泄漏。

## 105、线程池的拒绝策略有哪几种？

##### 最常用的有以下四种：

##### 1、AbortPolicy

简单粗暴，直接抛出拒绝异常，这也是默认的拒绝策略。

##### 2、 CallerRunsPolicy

如果线程池未关闭，则会在调用者线程中直接执行新任务，这会导致主线程提交线程性能变慢。

##### 3、DiscardPolicy

从方法看没做任务操作，即表示不处理新任务，即丢弃。

##### 4、DiscardOldestPolicy

如果线程池已满，它将丢弃队列中最老的任务，并将新的任务请求加入队列。

## 106、如何提交一个线程到线程池？

比如先随便定义一个固定大小的线程池：

```java
ExecutorService es = Executors.newFixedThreadPool(3);
```

然后提交一个线程：

```java
//有返回结果
es.submit(xxRunnble);
//无返回结果
es.execute(xxRunnble);
```

## 107、线程池 submit 和 execute 有什么区别？

如源码所示：

![](/images/多线程/107_1.jpg)

![](/images/多线程/107_2.jpg)

##### 1、返回值：

submit() 方法具有返回值，返回 Future 对象，可以通过 Future 对象检查任务的执行状态和获取任务执行的结果；

execute() 方法没有返回值，无法获取任务执行结果。

##### 2、异常处理

submit() 方法可以通过 Future 对象获取任务抛出的异常，但却不会打印出来。

execute() 方法无法获取具体的异常信息，但出现异常会打印出来。

##### 3、任务类型

submit() 方法可以提交 Callable 和 Runnable 类型的任务。

execute() 方法只能提交 Runnable 类型的任务。

## 108、如何查看线程池的运行状态？

在实际开发过程中，在线程池使用过程中可能会遇到各方面的故障，如线程池阻塞，无法提交新任务等。

如果你想监控某一个线程池的执行状态，线程池执行类 ThreadPoolExecutort 也给出了相关的 API 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。

> 总线程数=排队线程数+活动线程数+执行完成的线程数。

下面给出一个线程池使用示例，及教你获取线程池状态。

```java
private static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLIsEcoNDS,new LinkedBlockingQueue<Runnable>(1eeee));
public static void main(String[] args) throws Exception {
    for (int i = e; i < 100000; i++) {
        es.execute(() -> {
            System.out.print(1);
            try {
                Thread.sleep(1000);
            }catch (InterruptedException e) {
                e.printstackTrace();
            }
        });
    }

    ThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);

    while (true) {
        System.out.println();

        int queuesize = tpe.getqueue().size();
        System.out.println("当前排队线程数: " + queuesize);

        int activecount = tpe.getActivecount();
        System.out.println("当前活动线程数："+activecount);

        long completedTaskcount = tpe.getcompletedTaskcount();
        System.out.printin("执行完成线程数:" + completedTaskcount);

        long taskcount = tpe.getTaskcount();
        System.out.printin("总线程数："+ taskcount);

        Thread.sleep(3000);
    }
}
```

线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。

第一次程序输出：

> 当前排队线程数：99950
>
> 当前活动线程数：50
>
> 执行完成线程数：0
>
> 总线程数（排队线程数+活动线程数+执行完成线程数）：100000

第二次程序输出：

> 前排队线程数：99800
>
> 当前活动线程数：50
>
> 执行完成线程数：150
>
> 总线程数（排队线程数+活动线程数+执行完成线程数）：100000

活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：

> 前排队线程数：0
>
> 当前活动线程数：0
>
> 执行完成线程数：100000
>
> 总线程数（排队线程数+活动线程数+执行完成线程数）：100000

这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。

## 109、如何设置线程池的大小？

配置线程池可以从以下几个方面考虑：

- 任务是 CPU 密集型 IO 密集型或者混合型
- 任务执行的优先级
- 任务执行的时间长短
- 任务依赖性，是否依赖其他系统资源

（1）CPU 密集型配置尽可能少的线程，比如 n+1 个线程；

（2）IO 密集型可以配置较多的线程，如 2n 个线程；

（3）混合型可以考虑拆分成 IO 密集型任务和 CPU 密集型任务；

CPU 个数（n）可以通过以下代码来获取：

```java
Runtime.getRuntime().availableProcessors()
```

建议使用有界队列，防止内存溢出风险。

## 110、如何关闭线程池？

##### 线程池的 shutdown 方法：

不再接受新的任务，之前提交的任务等执行结束再关闭线程池。

##### 线程池的 shutdownNow 方法：

不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程列表。

## 111、谈谈多线程中的 CompletionService 接口？

CompletionService 是 Java 并发包下的接口：

> java.util.concurrent.CompletionService

CompletionService，即完成服务，是对 ExecutorService 的增强。

它的好处是，不用像 ExecutorService 线程池一样拿到 Future 集合一个个阻塞获取结果（这样可能中间的线程已经完成，但也要等前面的线程阻塞完成获取结果），CompletionService 提供的 take 方法就能取到已经完成任务的结果。

## 112、谈谈多线程中的 ExecutorCompletionService 类？

ExecutorCompletionService 是 CompletionService 接口唯一的实现类。

来看使用示例：

```java
Executorservice es = Executors.newFixedThreadPool(10);
Completionservice<string> cs = new Executorcompletionservice<>(es);
cs.submit(() -> {
// ...
});
String result = cs.take().get();
```

其实底层结合的是 ExecutorService +阻塞队列（BlockingQueue）完成的：

![](/images/多线程/112.jpg)

## 113、CompletionService 用完需要关闭吗？怎么关闭？

CompletionService 是对线程池 ExecutorService 的包装：

```java
Executorservice es = Executors.newFixedThreadPool(10);
Completionservice<String> cs = new Executorcompletionservice<>(es);
```

用完需要关闭 CompletionService 对应的线程池，即调用线程池 ExecutorService 的 API 关闭即可。

## 114、Java 实现异步编程有什么方案？

##### 一般有以下两种方案：

（1）使用 Future/FutureTask

（2）使用 CompletableFuture (JDK 8+)

## 115、谈谈多线程中的 CompletableFuture 类？

CompletableFuture 是 Java 8 新增的并发包下的类：

> java.util.concurrent.CompletableFuture

它实现了 Future、CompletionStage 接口，扩展了 Future 的功能，是对 Future 的补充，以此提供了非常强大的异步编程功能，简化了 Java 异步编程的复杂性。

## 116、谈谈多线程中的 CompletionStage 接口？

CompletionStage 是 Java 8 新增的并发包下的接口 :

> java.util.concurrent.CompletionStage

用于异步执行中的阶段处理，同时在 Java 8 中新增了 CompletableFuture 实现类，可以很方便的支持异步编程，唯一实现了`CompletionStage`接口的类。

## 117、AQS 是什么？

AQS 的全称：AbstractQueuedSynchronizer，即抽象队列同步器，这个类在 java.util.concurrent.locks 包下面：

![](/images/多线程/117_1.jpg)

AQS 是一个用来构建锁和同步器的框架，也是 JUC 的基石，比如常见的 ReentrantLock，Semaphore,ReentrantReadWriteLock，SynchronousQueue 等等，如下图所示：

![](/images/多线程/117_2.jpg)

它们都是基于 AQS 实现的，如果 JDK 提供的线程同步类不能满足要求，也可以使用 AQS 实现自己自定义的线程同步类。

## 118、AQS 的底层原理是什么？

> ##### AQS 的核心思想是：
>
> - 果共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
> - 果共享资源被占用，则使用线程阻塞等待以及被唤醒时锁分配的机制，AQS 是用 CLH 队列锁实现这个机制的，即将暂时获取不到锁的线程加入到队列中。

AQS 使用一个 volatile 成员变量（state）来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作，AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

##### 如 ReentrantLock 使用 AQS 的原理图如下：

![](/images/多线程/118.jpg)

AQS 定义了两种资源获取方式：

- **共享**：可以允许多个线程同时执行；
- **独占**：只能有一个线程执行，分为公平锁和非公平锁;

AQS 底层使用了模板方法模式，线程等待队列的维护 AQS 已经实现好了，自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可。

## 119、Fork Join 框架有什么用？

Fork/Join 框架是 Java7 提供的并行执行任务框架，其核心思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。

Fork/oin 的思想和 MapReduce 的思想非常类似，对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。

## 120、ForkJoin 框架的运行流程？

Fork/Join 的运行流程图如下：

![](/images/多线程/120.jpg)

我们可以通过 Fork/oin 单词字面上的意思去理解这个框架，Fork 是叉子分叉的意思，即将大任务分解成并行的小任务，Join 是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。

## 121、Fork Join 框架底层什么机制？

ForkJoin 采用了**工作窃取（work-stealing）**算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。

如下图所示：

![](/images/多线程/121.jpg)

为了实现工作窃取，在工作线程中维护了双端队列，被窃取任务的线程从队列尾部获取任务，窃取任务的线程从队列头部获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。

## 122、Fork Join 框架核心类有哪些？

Fork/Join 框架主要由子任务、任务调度两部分组成，其类层次图如下所示：

![](/images/多线程/122.jpg)

##### ForkJoinPool

ForkJoinPool 是 ForkJoin 框架中的任务调度器，和 ThreadPoolExecutor 一样实现了自己的线程池，提供了三种调度子任务的方法：

- xecute：异步执行指定任务，无返回结果；
- voke、invokeAll：异步执行指定任务，等待完成才返回结果；
- ubmit：异步执行指定任务，并立即返回一个 Future 对象；

##### ForkJoinTask

Fork/小 oin 框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。

- RecursiveAction：用于无结果返回的子任务；
- RecursiveTask：用于有结果返回的子任务；

## 123、使用 ForkJoin 框架有什么需要注意的？

##### 使用 Fork/Join 时的注意事项！！！

1、如果任务拆解的很深，系统内的线程数量堆积，导致系统性能严重下降；

2、如果函数的调用栈很深，会导致栈内存溢出；

## 124、编程实现使用 ForkJoin 框架的例子

实现一个 Fork/Join 小例子，从 1+2+..10 亿，每个任务只能处理 1000 个数相加，超过 1000 个的自动分解成小任务并行处理；并展示了通过不使用 Fork/小 oin 和使用时的时间损耗对比。

---

如下面的示例代码：

```java
import java.util.concurrent.ForkjoinPool;
import java.util.concurrent.RecursiveTask;
public class ForkjoinTask extends RecursiveTask<Long> {
    private static final long MAx = 1000000000L;
    private static final long THRESHOLD = 1000L;
    private long start;
    private long end;

    public Forkjointask(long start, long end) {
        this.start = start;
        this.end = end;
    }

    public static void main(string[] args) {
        test();
        System.out.println("--");
        testForkjoin();
    }

    private static void test() {
        System.out.printin("test");
        long start = System.currentTimeMillis();
        Long sum = 0L;
        for (long i = OL; i <= MAx; i++) {
            sum += i;
        }
        System.out.println(sum);
        System.out.printin(System.currentTimeMillis() - start + "ms");
    }

    private static void testForkjoin() {
        System.out.println("testForkJoin");
        long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Long sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));
        System.out.println(sum);
        System.out.println(System.currentTimeMillis() - start + "ms");
    }

    @override
    protected Long compute() {
        long sum = 0;
        if (end - start <= THRESHOLD) {
            for (long i = start; i <= end; i++) {
                sum += i;
            }
            return sum;
        } else {
            long mid = (start + end) / 2;

            ForkjoinTask taskl = new ForkJoinTask(start, mid);
            task1.fork();

            ForkJoinTask task2 = new ForkjoinTask(mid + 1, end);
            task2.fork();

            return taski.join() + task2.join();
        }
    }
}
```

这里需要计算结果，所以任务继承的是 RecursiveTask 类。

ForkJoinTask 需要实现 compute 方法，在这个方法里首先需要判断任务是否小于等于阈值 1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用 fork 方法时，又会进入 compute 方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。

使用 join 方法会阻塞并等待子任务执行完并得到其结果。

程序输出：

> test
>
> 508800000500000000
>
> 4992m
>
> ---
>
> testForkJoin
>
> 500000000500000000
>
> 508ms

从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。

## 125、ThreadLocal 有什么用？

ThreadLocal 可以理解成线程本地变量，一般多个线程（Thread）对一个变量操作时，它操作的是同一个对象，也存在线程安全的问题，而使用 ThreadLocal 设置和获取的变量则是和当前线程绑定的，当前线程对 ThreadLocal 变量的操作不会影响其他线程的 ThreadLocal 变量。

## 126、ThreadLocal 的底层实现是怎样的？

ThreadLocal 内部是靠 ThreadLocalMap 类来实现的：

![](/images/多线程/126_1.jpg)

![](/images/多线程/126_2.jpg)

![](/images/多线程/126_3.jpg)

每个线程会维护一个 ThreadLocalMap 对象，然后由 ThreadLocalMap 对象实现不同 ThreadLocal 变量的存储,ThreadLocalMap 维护了一个 Entryl』] table 数组（初始容量 16），ThreadLocal 对象则作为 Entry 中的 Key，Value 则为实际变量的值。

如下图所示：

![](/images/多线程/126_4.jpg)

所以，ThreadLocal 对象并不存储变量，而是由每个线程中持有的 ThreadLocalMap 变量存储的，ThreadLocal 对象只是作为绑定的弱引用对象 Entry 的 Key，线程结束，对应的 Key 就会被回收。

## 127、ThreadLocal 中的 Key 为什么要设计为弱引用？

Key 设计为弱引引用，是为了当线程结束后，其引用的 TheadLocal 对象能被 JVM 及时回收。

若 Key 设计为强引用，Key 的引用依然指向 TheadLocal 对象，所以会造成引用的对象无法被回收，从而造成内存泄漏。

## 128、ThreadLocal 为什么会导致内存溢出？

> ##### 使用 ThreadLocal 需要注意的是：
>
> 如果线程过多，或者每个线程执行周期过长，可能会导致内存泄露的风险。

因为 ThreadLocal 内部实际是靠 ThreadLocalMap.Entry 类来实现的， ThreadLocalMap.Entry 继承了 WeakReference<ThreadLocal<?>>，如下面的图所示:

![](/images/多线程/128_1.jpg)

![](/images/多线程/128_2.jpg)

Entry 的 Key 是 ThreadLocal 对象的弱引用，所以没有引用的 Key 会在 JVM 垃圾回收的时候回收掉，而 Key 对应的 Value 则不会被回收，这样就会导致无效 Value 对象越来越多，从而内存溢出。

## 129、ThreadLocal 怎么避免内存溢出？

ThreadLocal 使用完后必须加上 remove 方法移除：

![](/images/多线程/129.jpg)

因为 ThreadLocal 的 get/set/remove 方法都会清除线程 ThreadLocalMap 里所有 key 为 null 的 value， 从而会加快内存的释放，避免内存溢出。

> ThreadLocal 应用比较广泛，如果不是滥用，利是大于弊的。

## 130、编程实现 ThreadLocal 的使用例子

> 使用 ThreadLocal 编程示例，变量类型为 User，并初始化为 tom,12 岁，启动 3 个线程，每个线程循环 3 次，休眠 1 秒，主线程再输出。

参考实现示例如下：

```java
public class Test {
    @Data
    @AllArgsconstructor
    static class User {
        private string username;
        private int age;
    }

    private static ThreadlocalkUser> tl = Threadlocal.withinitial(() -> new User("tom", 12));
    static class TestThread extends Thread {
        @override
        public void run() {
            for (int i = 0; i< 3; i++) {
                User user = tl.get();
                user.setusername(Thread.currentThread().getName());user.setAge(i);
                tl.set(user);
                System.out.println(tl.get());
            }
        }
    }

    public static void main(string[] args) throws InterruptedException {
        for (int i = 0; i < 3; i++) {
            new Testthread().start();
            Thread.sleep(1000);
            System.out.println(Thread.currentThread() getName() + tl.get());
        }
    }
}
```

输出结果如下：

> Test.User(username=Thread-0, age=0)
>
> Test.User(username=Thread-0, age=1)
>
> Test.User(username=Thread-0, age=2)
>
> mainTest.User(username=tom, age=12)
>
> Test.User(username=Thread-1, age=0)
>
> Test.User(username=Thread-1, age=1)
>
> Test.User(username=Thread-1, age=2)
>
> mainTest.User(username=tom, age=12)
>
> Test.User(username=Thread-2, age=0)
>
> Test.User(username=Thread-2, age=1)
>
> Test.User(username=Thread-2, age=2)
>
> mainTest.User(username=tom, age=12)

从结果可见每个线程使用的是各自线程的变量副本，并没有影响其他线程和主线程，实现了线程隔离的效果。

## 131、volatile 关键字有什么用？

volatile 是 Java 中的一一个关键字，只能用于修饰一个成员变量，如：

> private volatile int balance;

##### volatile 关键字的作用是：

（1）保证成员变量在多个线程中的可见性；

（2）确保变量不会被重排序，保证了有序性；

正确使用 volatile 必须依赖以下条件：

（1）对变量的写操作不依赖当前变量的值；

（2）该变量没有包含在其他变量的不变式中；

> 第 1 个条件就说明了 volatile 不是原子性的操作，不能使用 n++类似的计数器，它不是线程安全的。

## 132、volatile 有哪些应用场景？

##### 1、状态的改变

> 有些场景肯定会有状态的改变，完成一个主线程的停止等。

如下面的程序所示：

```java
public class Test {

    private static volatile boolean isstop = false;

    public static void stopit() {
        isstop = true;
    }

    public static void main(string[] args) throws Interruptedexception {
        new Threadi().start();
        while (lisstop) {
        }
        System.out.printin("stop");
    }

    static class Thread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(3000);
            } catch (Interruptedexception e) {
                e.printstackTrace();
            }
            stopit();
        }
    }
}
```

首先开启了一个无限循环的主线程，判断变量 isStop 变量是否为 true，如果 true 的话就退出程序，否则就一直循环，所以这个 isStop 的值是别的线程改变的。

上面这段程序如果不加 volatile 的话会一直卡在循环，此时的线程拿到的值永远为 false，加了 volatile 三秒后就输出 stop,所以这段程序很好的解释了可见性的特点。

##### 2、读多写少的情况

> 假设这样一种场景，有 N 个线程在读取变量的值，只有一个线程写变量的值，这时候就能保证读线程的可见性，又能保证写线程的线程安全问题。

像 n++不是原子类的操作，其实可以通过 synchronized 对写方法锁住，再用 volatile 修饰变量，这样就保证了读线程对变量的可见性，又保证了变量的原子性。

如下面的程序所示：

```java
public class Test {
    private static volatile int n = 0;

    public static synchronized void add() {
        n++;
    }

    public static void main(string[] args) throws InterruptedException {
        new Threadi().start();
        while (n <100) {
        }
        System.out.printin("stop");
    }

    static class Thread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(3000);
            } catch (Interruptedexception e) {
                e.printstackTrace();
            }
            for (int i = 0; i< 200; i++) {
                add();
            }
        }
    }
}
```

如果 n 不加 volatile，程序将一直循环，不能输出 stop，也就是此时的线程拿到的值永远为 O。当然不加 volatile，对获取 n 的方法进行 synchronized 修饰也是能及时获取最新值的，但是性能会远低于 volatile。

> 以上仅为示例，像 n++操作建议使用性能更好的 Atomic 包中的原子类。

## 133、volatile 可以保证原子性吗？怎么实现的？

volatile 关键字不可以保证原子性，如下图所示：

![](/images/多线程/133.jpg)

所以，volatile 不能保证原子性，只能保证可见性。

## 134、volatile 可以保证可见性吗？怎么实现的？

volatile 可以保证可见性，其原理主要是通过**内存屏障和禁止指令重排序**来实现的：

- **写一个 volatile 变量时**：JVM 会在写操作前后加入一条 Store 屏障指令，把该线程对应的工作内存中的共享变量的值刷新到主内存；
- **读一个 volatile 变量时**：JVM 会在读操作前加入一条 Load 屏障指令，把该线程对应的工作内存的变量置为无效，然后从主内存中读取共享变量最新的值；

## 135、volatile 可以保证有序性吗？怎么实现的？

可以的，`volatile`关键字可以一定程度上保证有序性，尤其是在**禁止指令重排序**方面，参考《 volatile 可以防止指令重排序吗？怎么实现的？》面试题。

但是，`volatile`关键字并不能解决所有的并发及顺序问题，在某些情况下，仍需要使用更强的同步机制，如`synchronized`关键字或`Lock`锁等，以确保程序的正确性。

## 136、volatile 可以代替 synchronized 使用吗？为什么？

在可见性方面，volatile 可以代替 synchronized，但它并不能完全代替 synchronized，因为有以下几点原因：

（1）volatile 不能代替 synchronized 原子性的特点；

（2）volatile 只能修饰成员变量，不能代替 synchronized 来修饰方法、代码块来实现同步性；

（3）volatile 不能像 synchronized 一样当锁使用，volatile 不会像 synchronized 一样阻塞程序；

## 137、CountDownLatch 有什么用？

CountDownLatch 见名思义，即倒计数器，是多线程并发控制中非常有用的线程并发控制类，它可以设置一个倒计数器数量，并控制另外一个线程等待，直到倒计数器归 0 再继续执行。

![](/images/多线程/137.jpg)

如该类注释所示，在调用 countDown 方法让计数器归 0 之前，await 的方法会一直阻塞。

> 具体用法可以参考另一道 CountDownLatch 编程题。

## 138、编程实现一个 CountDownLatch 的使用示例

##### 比如有下面一道题：

> 阻塞 N 个线程执行完后，主线再往下执行，并统计所有线程的总耗时。

当然我们可以通过 join 的形式完成这道题，但如果我说统计 100 个、1000 个线程呢？难道要写 1000 个 join 等待吗？这显然是不现实的，这时可以使用 CountDownLatch 类来实现。

废话少说，我们来做一个例子看看上面的题怎么实现：

```java
public class Test {
    public static void main(string[] args) throws InterruptedException {
        CountDownLatch cdl = new CountDownLatch(100);
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep(500);
                }catch (Interruptedexception e){
                    e.printstackTrace();
                } finally {
                    cdl.countDown();
                }
            }).start();
        }
        cdl.await();
        System.out.println(cdl.getcount());
        System.out.printin(String.format("耗时: %sms", System.currentTimeMillis() - start));
    }
}
```

输出结果：

> 0
>
> 耗时：521ms

![](/images/多线程/138.jpg)

首先通过 new CountDownLatch(10o)约定了倒计时器的数量，在这里也是线程的数量，每个线程执行完后再对倒计时器-1。countDown 方法即是对倒计时器－1，这个方法需要放在 finally 中，一定要保证在每个线程中得到释放，不然子线程如果因为某种原因报错倒计时器永远不会清 0，则会导报主线程会一直等待。

await 方法即是主线程阻塞等待倒计器归 O 后再继续往下执行，当然 await 方法也可以带时间进去，等待多久时间后不管倒计时器有没有归 0 主线程继续往下执行。

如上面的例子所示，我们输出了倒计时器最后的数字 0，表示倒计时器归 0 了，也输出了从开始到结束所花费的时间。从这个例子可以完全理解倒计时器的含义，这个工具类在实际开发经常有用到，也很好用。

## 139、CyclicBarrier 有什么用？

CyclicBarrier 和 CountDownLatch 的功能有点相反，它是一个可循环使用的屏障，称为：循环栅栏。

CyclicBarrier 可以让一组线程到达一个屏障（栅栏）时，这一组线程同时被阻塞，当最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。

##### CyclicBarrier 有两个构造方法：

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= e) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barriercommand = barrierAction;
}

public cyclicBarrier(int parties) {
    this(parties, null);
}
```

##### 参数说明：

- **parities**：表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 该线程已经到达屏障，然后当前线程被阻塞；

- **barrierAction**：屏障被打开时要执行的回调线程，它在被阻塞的线程继续运行前才运行；

> 具体用法可以参考另一道 CyclicBarrier 编程题。

## 140、编程实现一个 CyclicBarrier 的使用示例

##### 比如有下面一道题：

> 让 5 个线程同时执行，当每个线程都执行了某段代码后再继续往下执行，如果 5 个线程有一个线程还未执行该段代码，否则其他线程一直等待。

从上面的题目，我们来看下面的例子：

```java
public class Test {
    public static void main(string[] args) {
        long start = System.currentTimeMillis();
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> {
            System.out.println(String.format("时t: %sms", System.currentTimeMillis() - start));
            System.out.println("cyclicBarrier finished.");
        });
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep(3000);
                    cyclicBarrier.await();
                    System.out.println(Thread.currentThread().getName());
                } catch (Exception e) {
                    e.printstacktrace();
                }
            }).start();
        }
    }
}
```

输出结果：

> 耗时：3015ms
>
> CyclicBarrier finished.
>
> Thread-2
>
> 耗时：3021ms
>
> CyclicBarrier finished.
>
> Thread-9
>
> Thread-0
>
> Thread-1
>
> Thread-4
>
> Thread-3
>
> Thread-7
>
> Thread-5
>
> Thread-8
>
> Thread-6

![](/images/多线程/140.jpg)

首先 CyclicBarrier 构造方法接受 5 个线程数和线程聚齐时的回调线程，就是当 5 个线程都调用了 await 方法，这 5 个线程才继续往下执行，执行前先运行到齐时的回调线程。

从例子输出的结果可以看出 CyclicBarrier finished.先运行的，说明 5 个线程都执行完后运行了回调线程，再输出了每个线程名称，我们控制 10 个线程来阻塞等待，而循环栅栏只有 5 个，说明它是可以循环利用的，每到齐 5 个线程阻塞的线程就继续执行。

> ##### 需要注意的是，await 方法会抛出异常：
>
> - 一个是中断异常 InterruptedException，即其他线程中断了这个线程；
> - 一个是 BrokenBarrierException，如果 1 个线程被打断出现 InterruptedException，其他等待在循环栅栏外面的线程就会出现 BrokenBarrierException。因为一个线程被打断了，即打破了循环栅栏的完整性，导致线程不能到齐其他线程永远不能继续执行，这个异常也就避免了线程永远等待的情况。

## 141、CountDownLatch 与 CyclicBarrier 的区别？

##### CountDownLatch：

计数器：计数器只能使用一次。

等待：一个线程或多个等待另外 n 个线程完成之后才能执行。

##### CyclicBarrier：

计数器：计数器可以重置 (通过 reset 方法)。

等待：n 个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。

## 142、Semaphore 有什么用？

Semaphore 叫做信号量，它是用来控制同时访问资源的线程数量，即对线程限流，通过协调各个线程来保证合理的公共资源的访问，特别是公共资源有限的应用场景。

##### Semaphore 有两个构造方法：

```java
public Semaphore(int permits) {
    sync = new Nonfairsync(permits);
}

public Semaphore(int permits, boolean fair) {
    sync = fair ? new Fairsync(permits) : new Nonfairsync(permits);
}
```

参数说明：

- permits：许可通行的线程数量；
- fair：是否公平锁（先进先出），默认为非公平锁；

Semaphore 获取许可和释放许可原理如下图：

![](/images/多线程/142.jpg)

## 143、编程实现一个 Semaphore 的使用示例

如下面的示例：

```java
public class Test {
    public static void main(string[] args) {
        Semaphore semaphore = new Semaphore(2);
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();13System.out.printin(Thread.currentThread() ·getName() +"获取许可耗时: "+ (system.currentTimeMillis() - start));
                    TimeUnit.SECoNDs ,sleep(3);
                } catch (InterruptedException e) {
                    e.printstackTrace();
                } finally {
                    System.out.printin(Thread.currentThread() -getName() + " 释放许可");
                    semaphore.release();
                }
            }).start();
        }
    }
}
```

通过 Semaphore 构造了 2 个许可线程，然后开启了 5 个线程同时执行，然后每个线程需要获取 Semaphore 许可才能执行，执行时休眠 3 秒模拟阻塞获取许可的场景，每个线程执行完后需要在 finally 主动释放许可，不然会造成其他线程一直阻塞，除非被中断。

输出结果：

> Thread-0 获取许可耗时：6
>
> Thread-1 获取许可耗时：6
>
> Thread-0 释放许可
>
> Thread-1 释放许可
>
> Thread-2 获取许可耗时：3034
>
> Thread-3 获取许可耗时：3034
>
> Thread-3 释放许可
>
> Thread-2 释放许可
>
> Thread-4 获取许可耗时：6037
>
> Thread-4 释放许可

从输出结果可以看到是有序执行的，释放两个许可，才能继续执行后续两个线程。

## 144、Exchanger 有什么用？

Exchanger 是一个用于线程之间协作的工具类，它可以支持两个线程之间交换彼此的数据。比如第一个线程执行 exchange 方法，它会一直等待第二个线程也执行 exchange，当两个线程都到同步点，就可以交换数据了。

Exchanger 提供了两个公开方法：

![](/images/多线程/144.jpg)

（1）只带泛型 V（交换的数据对象）的交换方法，线程一直阻塞，直到其他任意线程和它交换数据，或者被线程中断。

（2）另外一个带时间的交换方法，如果超过设置时间还没有线程和它交换数据，就会抛出`TimeoutException`异常。

## 145、编程实现两个线程彼此交换数据的例子

##### 简单数据交换

来一个两个线程正常数据交换的简单示例：

```java
private static void test1() {
    Exchanger exchanger = new Exchanger();
    new Thread(() -> {
        try{
            object data ="-公众号Java技术栈AAA";
            System.out.println(Thread.currentThread() -getName() + data);
            //开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread() .getName() + data);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    }).start();

    new Thread(() -> {
        try {
            Object data ="-公众号Java技术栈BBB";
            System.out.printin(Thread.currentThread()-getName() + data);
            //开始交换数据
            data = exchanger.exchange(data);
            System.out.printin(Thread.currentThread().getName() + data);
        } catch (InterruptedException e) {
            e.printstackTrace();
        }
    }).start();
}
```

##### 这段代码的逻辑：

1、创建并启动两个线程；

2、进行数据交换前先打印出自己线程的数据；

3、进行数据交换；

4、打印数据交换之后的数据；

##### 输出结果：

![](/images/多线程/145_1.jpg)

从结果可以看出，线程 0、1 分别先打印出 A、B，数据交换之后，打印出了 B、A，数据交换正常！

##### 超时数据交换

上面演示了两个线程的正常交换，下面再来一个带超时的示例：

```java
rivate static void test2() {
    Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            object data="-公众号Java技术栈AAA";
            System.out.printin(Thread.currentThread() getName() + data);

            //开始交换数据
            data = exchanger.exchange(data, 3000L, TimeUnit.MILLISECONDS);
            System.out.println(Thread.currentThread() .getName() + data) ;
        } catch (Exception e) {
            e.printstackTrace();
        }
    }).start();
}
```

现在只启动了一个线程，并且设置了超时时间 3 秒。

##### 输出结果：

![](/images/多线程/145_2.jpg)

首先线程输出了自己的数据，然后 3 秒后，并没有其他线程和它交换数据，所以抛出了超时异常，最后线程结束运行。

##### 中断数据交换

线程开始交换数据后，会一直阻塞直到其他任意线程和它交换数据，或者被中断、超时，上面演示了超时，下面这个示例演示一下中断。

```java
private static void test3() {
    Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            Object data = "-公众号Java技术栈AAA";
            System.out.println(Thread.currentThread() ·getName() + data);
            //开始交换数据
            data = exchanger.exchange(data);
            System.out.printin(Thread.currentThread() -getName() + data);
        } catch (Exception e) {
            e.printstackTrace();
        }
    }).start();
}
```

结果输出：

![](/images/多线程/145_3.jpg)

默认情况下不带超时设置会一直阻塞运行中..

现在我再加入一段中断的逻辑：

```java
private static void test3() throws InterruptedException {
    Exchanger exchanger = new Exchanger();

    Thread thread = new Thread(() -> {
        try {
            Object data = "-公众号Java技术栈AAA";
            System.out.printin(Thread.currentThread() -getName() + data);
            //开始交换数据
            data = exchanger.exchange(data);
            System.out.printin(Thread.currentThread() -getName() + data);
        } catch (Exception e) {
            e.printstackTrace();
        }
    });
    thread.start();

    //线程中断
    Thread.sleep(3000L);
    thread.interrupt();
}
```

主线程休眠 3 秒后，中断该线程。

输出结果：

![](/images/多线程/145_4.jpg)

输出结果 3 秒后，线程被中断了，抛出了中断异常，线程也停止阻塞，最后线程结束运行。

##### 两两数据交换

另外需要知道是，Exchanger 只能用于两个线程之间的数据交换，一个线程开启数据交换之后，会阻塞直到其他任意线程同样开启数据交换达到交换点。

最后来个示例，开启 10 个线程，看它们是怎么两两交换的：

```java
private static void test4() {
    Exchanger exchanger = new Exchanger();

    for (int i = 1; i <= 10; i++) {
        Integer data = i;
        new Thread(() -> {
            try {
                Object exchange = exchanger.exchange(data);
                System.out.printin(Thread.currentThread() .getName() + "" + exchange);
            } catch (InterruptedException e) {
                e.printstackTrace();
            }
        },"Java技术栈"+ i).start();
  }
}
```

输出结果：

![](/images/多线程/145_5.jpg)

可以看到，10 个线程，都两两交换彼此的数据了。

> 这篇介绍了线程之间的数据交换器 Exchanger 类的使用，Exchanger 只能用于多个线程中的两个线程两两交换数据，如果没有对应的线程交换就会一直阻塞，可设置超时，可以中断。

## 146、LockSupport 有什么用？

LockSupport 是 JDK 中用来实现线程阻塞（park）和唤醒（unpark）的工具类，提供的方法如下图所示：

![](/images/多线程/146.jpg)

它可以很方便的使线程进行阻塞、唤醒，而不用担心阻塞和唤醒操作的顺序，但要注意连续多次唤醒和一次唤醒是一样的效果。

> 具体用法可以参考另一道 LockSupport 编程题。

## 147、LockSupport 和 wait-notify-notifyAll 有什么区别？

它们都可以用来阻塞唤醒线程，区别如下：

（1） wait, notify, notifyAll 是 Object 类的方法，LockSupport 是单独的线程工具类；

（2）wait, notify, notifyAll 需要使用 synchronized 关键字获取对象的锁才能阻塞线程，而 LockSupport 则不需要加锁，它可以在线程任意地方阻塞；

（3）notify 只能随机唤醒一个阻塞的线程，notifyAll 唤醒所有阻塞的线程，而 LockSupport 可以指定线程进行唤醒。

## 148、编程实现一个 LockSupport 阻塞唤醒线程的使用示例

如下面的使用示例：

```java
public class Test {
    public static void main(string[] args) {
        Thread thread1 = new Thread(() -> {
            System.out.println("thread1 start...");
            Locksupport.park();
            System.out.println("thread1 end...");
        });
        thread1.start();

        Thread thread2 = new Thread(() -> {
            System.out.printin("thread2 start...");
            try {
                TimeUnit.SECONDs.sleep(3);
            } catch (Interruptedexception e) {
                throw new RuntimeException(e);
            }
            Locksupport.unpark(thread1);
            System.out.println("thread2 唤醒了 thread1");
        });
        thread2.start();
    }
}
```

输出结果：

> thread1 start...
>
> thread2 start..
>
> thread2 唤醒了 thread1
>
> thread1 end...

thread1 阻塞后，在 thread2 休眠 3 秒后再唤醒 thread1 后才继续执行。

## 149、Java 中原子操作的类有哪些？

JDK 原子类包（java.util.concurrent.atomic）中的 Atomic\*类都是原子操作设计的类，比如：

- AtomicBoolean：原子布尔类型类；
- Atomiclnteger：原子整形类；
- AtomicLong：原子长整形类；
- AtomicReference：原子引用类型类；
- ....

更多可以看 atomic 原子包，如该包目录结构所示：

![](/images/多线程/149.jpg)

## 150、什么是 ABA 问题？

CAS 需要在操作值的时候，检查值有没有变化，如果没有变化则更新，如果一个值原来是 A 变成了 B，后来又变成了 A，那么使用 CAS 进行检测时会发现发的值没有发生变化，其实 A 中间是经过变过的，这就是所谓的 ABA 问题。

如下面的 CAS 流程图所示：

![](/images/多线程/150.jpg)

## 151、怎么解决 ABA 问题？

解决 ABA 问题有以下 3 种参考方案：

##### （1）使用 CAS+版本

号每次数据更新的时候追加版本号（+1)，如：A—B 一 A 一>1A—2B—3A，然后 CAS 再比较的时候，不仅要比较原来的值，还要比较版本号是否有改动，这样就解决了 ABA 问题了。

##### （2) AtomicMarkableReference

AtomicMarkableReference 是 Java 并发包中提供的一个类，它可以在原子性的基础上给引 l 用对象打标记，用来解决一些 ABA 问题，但并不能完全解决所有的 ABA 问题，因为它仍然存在一些限制。它可以通过标记来检测 ABA 问题，如果一个线程在修改引用对象时同时修改了标记，另一个线程就可以通过检查标记来判断对象是否被修改过。但是，**如果一个线程修改了引用对象，然后又将它改回原来的值，这个过程对于标记是没有影响的，因此另一个线程无法通过检查标记来判断对象是否被修改过。**

##### （3) 使用 AtomicStampedReference

从 JDK 1.5 开始，Atomic 包提供了一个 **AtomicStampedReference** 类来解决 ABA 的问题， AtomicStampedReference 是一个带有时间戳的对象引用，它在 AtomicMarkableReference 的基础上增加了一个版本号来解决 ABA 问题，即每次修改时都会更新版本号，从而确保不会出现 ABA 问题。

## 152、什么是 Happens-Before 原则？

Happens-Before 原则用来指定两个操作之间的执行顺序，由于这两个操作可以在一个线程之内，也可以在不同线程之间，因此，JMM 通过 Happens-Before 原则来保证跨线程的内存可见性。

> 比如：如果线程 A 是对变量进行写操作，而线程 B 是对变量进行读操作，如果线程 A 的操作是 Happens-Before 线程 B 的操作，那么线程 A 写操作之后的数据对线程 B 也是可见的。

两个操作之间存在 Happens-Before 关系，并不意味着一定要按照 Happens-Before 原则制定的顺序来执行，如果重排序之后的执行结果与按照 Happens-Before 关系来执行的结果一致，那么这种重排序是正常的。

## 153、Happens-Before 原则有哪些?

Happens-Before 八大原则如下表：

| 原则 | 名称              | 描述                                                                                                            |
| ---- | ----------------- | --------------------------------------------------------------------------------------------------------------- |
| 1    | 程序次序规则      | 同一个线程内的操作，按照程序代码的先后顺序执行。                                                                |
| 2    | volatile 变量规则 | 对一个 volatile 变量的写操作 Happens-Before 于后续对该变量的读操作。                                            |
| 3    | 传递性规则        | 如果操作 A Happens-Before 操作 B，操作 B Happens-Before 操作 C，那么操作 A Happens-Before 操作 C。              |
| 4    | 锁定规则          | 对一个锁的解锁 Happens-Before 于后续对同一个锁的加锁。                                                          |
| 5    | 线程启动规则      | Thread 对象的 start() 方法 Happens-Before 新线程的所有操作。                                                    |
| 6    | 线程终止规则      | 线程中的所有操作 Happens-Before 于其他线程检测到该线程已经终止。                                                |
| 7    | 中断规则          | 一个线程调用另一个线程的 interruptO 方法 Happens-Before 后者检测到中断信号。                                    |
| 8    | 终结器规则        | 一个对象的构造函数 Happens-Before 于该对象的 finalize() 方法。在该对象被 GC 回收之前，finalize() 方法会被调用。 |

> 注意：这里提到的原则仅是一些常见的 Happens-Before 原则，而不是全部。

## 154、Java 并发容器，你知道几个？

并发容器在 JUC 并发包中，比如有以下常用的几个：

- ConcurrentHashMap

- CopyOnWriteArrayList
- CopyOnWriteArraySet
- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- ConcurrentSkipListMap
- ConcurrentSkipListSet
- ArrayBlockingQueue
- LinkedBlockingQueue
- LinkedBlockingDeque
- PriorityBlockingQueue
- SynchronousQueue
- LinkedTransferQueue
- DelayQueue
- ....

## 155、什么是协程？

协程是比线程还要小的执行单元，它是对线程的更一步的分割，由于线程是操作系统中的最小执行单元，所以，协程必须也是基于线程来实现的，协程的所有生命周期都是在某一个线程中来完成的。

## 156、有了多线程，为什么还要搞出协程？

协程也叫纤程，在 Java 中叫做虚拟线程（Java 19+开始支持），有了多线程，为什么要虚拟线程，那是因为线程之间的切换成本比较高，而协程在这方面却很轻便，协程可以进一步提高系统的并行能力。

##### 说说 Java 为什么搞出虚拟线程：

虚拟线程是 JDK 19 开始支持的，它是 Java 实现的轻量级线程，虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。

## 157、Java 支持协程吗？

JDK 19+开始支持协程，在 Java 里面叫 Virtual Threads，即虚拟线程。

虚拟线程，我们来看看是什么鬼：

> 虚拟线程是一种成本低廉、轻量级的用户模式的线程实现，它可以充分利用可用硬件，大幅减少编写、维护和监测高并发应用的工作量。

**低成本+轻量级+用户态**，这一看就是**协程**的定义了。。

我们都知道使用线程是要十分注意的，因为线程的创建、销毁都十分消耗系统资源，所以有了线程池，但这还不够，因为线程的数量是有限的，线程会阻塞操作系统线程，无法尽可能的提高吞吐量。因为使用线程的成本很高，所以才会有了虚拟线程，它是用户态线程，成本是相当低廉的，调度也完全由用户进行控制（JDK 中的调度器），它同样可以进行阻塞，但不用阻塞操作系统线程，充分提高了硬件利用率，高并发也上了一个量级，从而实现了高吞吐量。

---

虚拟线程创建方式：

虚拟线程是`java.lang.Thread`的一个实现，可以使用`java.lang.Thread.Builder`接口创建，如下所示：

```java
Thread thread = Thread.ofvirtual()
    .name("javastack")
    .unstarted(runnable);
```

也可能会通过一个线程工厂类进行创建：

```java
ThreadFactory factory = Thread.ofvirtual().factory();
```

并且，可以通过 Thread.isVirtual0 方法判断是否虚拟线程。

虚拟线程运行的载体必须是线程，同一个线程中可以运行多个虚拟线程实例。

## 158、Java 支持协程的框架有哪些？

支持 Java 协程的主流框架有：

- kilim
- Quasar
- ea-async

另外，Java 19+开始支持虚拟线程了，也就是协程。

## 159、SimpleDateFormat 是线程安全的吗？为什么？以及怎么解决？

大家都说 SimpleDateFormat 不是线程安全的，到底哪里不安全呢？

来看 SimpleDateFormat 类的源码注释：

![](/images/多线程/159_1.jpg)

说的很清楚，**SimpleDateFormat 不是线程安全的**，多线程下需要为每个线程创建不同的实例。

不安全的原因是因为使用了 Calendar 这个全局变量：
![](/images/多线程/159_2.jpg)

在日期格式化的时候：

![](/images/多线程/159_3.jpg)

这个 time 就会出现多线程并发设置安全问题，比如 A 线程在执行设置的时候，刚好被 B 线程抢先设置了，这样时间不就错乱了。

---

其实在阿里巴巴 Java 开发手册中也规范的很清楚：

![](/images/多线程/159_4.jpg)

##### 解决方法：

其实在阿里巴巴 Java 开发手册中也给出了答案，再总结下：

（1）尽量使用局部变量；

（2）如果要使用全局变量，则需要加锁格式化操作；

（3）使用 ThreadLocal 进行线程隔离；

## 160、parallelStream 的底层实现是什么？

parallelStream 背后的秘密其实就是：ForkJoin

![](/images/多线程/160_1.jpg)

结果输出：

![](/images/多线程/160_2.jpg)

看到没，底层就是 ForkJoin 线程池，ForkJoinPool 和主线程都参与了并行任务。

## 161、parallelStream 有没有遇到什么坑？

比如会引发以下问题：

- 事务不共享;
- 不能访问主线程本地变量;
- 线程安全性

欢迎大家补充...

## 162、parallelStream 是线程安全的吗？

不是，parallelstream 会引起线程安全问题，所以要注意不要使用线程不安全的集合或者类。

## 163、parallelStream 默认启动了多少线程？

parallelStream 使用了 ForkJoin 框架，其默认线程数即当前服务器的 CPU 可用核心数，如源码所示：

![](/images/多线程/163.jpg)

## 164、parallelStream 如何修改默认线程数？

##### 1、全局设置

```java
System.setProperty("java.util.concurrent.ForkjoinPool.common.parallelism", "100");
```

或者：

```xml
-Djava.util.concurrent.ForkjoinPool.common.parallelism=8
```

##### 2、自定义 ForkJoinPool

```java
ForkJoinPool myPool = new ForkJoinPool(100);
myPool.submit(() ->
  list.parallelstream().forEach(...);
).get();
```

## 165、parallelStream 和 stream 的区别？

下面用一张表格总结下：

| 对比         | parallelStream | stream   |
| ------------ | -------------- | -------- |
| 执行顺序     | 并行执行       | 顺序执行 |
| 执行方式     | 异步           | 同步     |
| 线程安全问题 | 存在           | 不存在   |

## 166、parallelStream 和 stream 哪个快？

这个没有绝对答案，使用 parallelstream 处理耗时的数据肯定要更快，但 stream 处理简单的操作也未必比 parallelstream 慢。
