## 1、操作系统是什么？

操作系统（Operating System，简称OS）是计算机系统中的核心软件，本质上也是一个软件，它负责**管理和协调计算机硬件和软件资源**，以提供用户和应用程序所需的服务和接口。

操作系统使开发者能够专注于应用程序的开发，而不用和底层硬件打交道。

## 2、操作系统主要有哪几个特征？

操作系统的四个主要特征：

##### 1、并发

操作系统能够同时管理多个任务的执行，是多个进程或线程可以在同一台计算机上并行运行，包括多任务处理、多进程和多线程支持，并发性特征使计算机可以高效地共享和利用系统资源。

##### 2、共享

操作系统允许多个用户和应用程序共享计算机系统的硬件资源，如CPU、内存、磁盘和网络连接，他管理资源分配以确保公平性和高效性，并通过各种方式（如时间片轮转）进行资源共享。

##### 3、虚拟

操作系统允许将物理资源抽象成虚拟资源，从而使多个应用程序以为他们独占了资源，包括虚拟内存、虚拟文件系统和虚拟机技术，它们提供了更高的隔离和安全性。

##### 4、异步

操作系统可以让任务异步执行，而无需阻塞等待一个操作完成在进行另外一个操作，可以在并行处理多个任务的同时提升程序效率。

## 3、操作系统的主要功能有哪些？

操作系统的主要功能包括：

##### 1、资源管理

操作系统的一个主要任务是有效管理计算机的硬件资源，包括中央处理器（CPU）、内存、磁盘存储、输入设备（键盘、鼠标）和输出设备（显示器、打印机），操作系统通过分配和控制这些资源，确保它们能够被多个应用程序共享，并按钮需提供。

##### 2、进程管理

操作系统支持多任务处理，允许多个应用程序或进程同时运行。操作系统管理进程的创建、调度、暂停和终止，以确保它们能够有效地共享CPU时间。

##### 3、内存管理

操作系统负责管理计算机的内存，包括内存分配、回收和虚拟内存管理，确保应用程序能够访问所需的内存空间，并通过虚拟内存机制将物理内存和磁盘存储结合使用。

##### 4、文件系统管理

操作系统管理文件和文件夹，包括文件的创建、读取、写入、删除以及权限控制，为用户和应用程序提供文件存储和组织的接口。

##### 5、用户界面

操作系统为用户提供与计算机交互的方式，可以是命令行界面（CLI）或图形用户界面（GUI），用户可以通过这些界面执行命令、启动应用程序、管理文件等。

##### 6、设备驱动程序

操作系统支持设备驱动程序，使计算机能够与各种硬件设备通信，设备驱动程序允许操作系统和硬件设备之间的互操作。

##### 7、网络和通信

操作系统提供网络功能，允许计算机连接到局域网或互联网，并进行数据通信，它管理网络连接和数据传输。

##### 8、安全管理

操作系统实施安全性控制和权限管理，以确保只有经过授权的用户可以访问和修改系统资源。这包括用户身份验证、文件权限和网络安全。

## 4、操作系统有哪些分类？

操作系统的主要分类如下：

##### 1、桌面操作系统

这些操作系统设计用于个人计算机，提供图形用户界面（GUI），以便用户可以通过鼠标和键盘与计算机交互。

一些常见的桌面操作系统包括：

- Microsoft Windows （微软）
- MacOS（苹果电脑的系统）
- Linux发行版（如：Ubuntu、Fedora）

##### 2、服务器操作系统

这些操作系统专门设计用于服务器环境，以支持网络服务、应用程序和数据库，他们通常具有更高的性能、稳定性和安全性特征。

一些常见的服务器操作系统包括：

- Windows Server
- Linux发行版（如：Red Hat Enterprise Linux、CentOS）
- Unix操作系统（如：AIX、Solaris）

##### 3、嵌入式操作系统

这些操作系统用于嵌入式系统，如智能手机、嵌入式控制器、家电和汽车，它们通常需要小的存储空间和资源，并具有实时性能。

一些嵌入式操作系统包括：

- Android
- iOS
- FreeRTOS
- QNX

...

这些是操作系统的一些主要分类，根据用途和特性的不同，其实还可以细分更多。

## 5、操作系统的体系结构是怎样的？

操作系统的体系结构大致如下：

![](/images/操作系统/5.jpg)

##### 1、应用程序层

这一层包括应用程序和软件，这些应用程序依赖于操作系统提供的服务和资源，完成各种任务。

##### 2、内核层

内核是操作系统的核心部分，它直接与硬件交互并管理各种系统资源。

##### 3、硬件层

这是操作系统底层的物理硬件层，包括中央处理器（CPU）、内存、外部设备（如磁盘、键盘、显示器、鼠标等）、总线和通信接口，操作系统必须管理和控制这些硬件资源以提供高效的计算环境。

## 6、什么是实时操作系统？

实时操作系统（）是一种专门设计用于满足实时性要求的操作系统。

实时性指的是：**在特定时间限制内对事件或任务做出相应的能力**，实时操作系统旨在确保在严格的时间限制内执行任务，不会有较高的延时，以满足特定应用程序或系统的实时性需求。

实时操作系统广泛应用于自动控制系统、嵌入式系统、工业自动化、航空航天、医疗设备、交通控制、通信设备、机器人技术和多媒体处理等领域，不同类型的实时操作系统适用于不同的应用，因为它们对于响应时间和可靠性的要求有所不同。

## 7、软件与硬件交互的方式有哪些？

软件与硬件交互的方式多种多样，取决于应用程序、硬件设备和操作系统的特性。

以下是软件与硬件交互的主要方式：

##### 1、系统调用

操作系统提供一组系统调用，允许应用程序通过操作系统间接访问硬件资源，这些系统调用包括文件操作、网络通信、进程控制等。

##### 2、驱动程序

硬件设备通常需要特定的驱动程序，它们是操作系统的组成部分，用于为应用程序提供硬件访问接口，驱动程序充当硬件和操作系统之间的中间层。

##### 3、直接内存访问（DMA）

一些高性能硬件设备支持DMA，这允许硬件设备绕过CPU直接访问系统内存，以提高数据传输速度。

##### 4、I/O端口：

一些计算机系统使用I/O端口来访问硬件设备，应用程序可以通过读写特定的端口来与硬件设备通信。

等等。。。

## 8、为什么Linux应用程序不能直接在Windows下运行？

以下是一些主要原因：

##### 1、内核不同

Linux和Windows使用不同的操作系统内核，这两个内核的设计、架构和系统调用接口都不同，因为两者无法兼容。

##### 2、二进制格式不同

Linux应用程序通常以ELF（Executable and Linkable Format）格式编译，而Windows应用程序以PE（Portable Executable）格式编译，这两种格式不兼容。

##### 3、库依赖性

Linux和Windows的应用程序通常依赖于特定的库和共享对象文件，所以它们只能在自己的平台使用。

##### 4、系统调用和API

Linux和Windows拥有不同的系统调用和应用程序接口（API），所以两者不能兼容。

总之，Linux和Windows是两个不同的操作系统，它们的设计、架构和应用程序生态系统都不同，因此不能直接运行对方的应用程序。

## 9、什么是内核？

内核（Kernel）是操作系统的核心组成部分，他是一个运行在计算机内存中的管理和控制程序，主要负责管理计算机硬件资源、执行任务调度、提供系统服务、处理中断和异常等核心操作。

## 10、什么是内核态和用户态？

内核态和用户态是指操作系统运行中不同特权级别的两种执行环境，用于区分操作系统内核和用户应用程序之间的权限和访问级别，这两种模式具有不同的特征和访问权限。

##### 内核态

- 内核态是操作系统内核运行的特权级别，具有最高的系统权限，操作系统内核可以执行任何指令，访问所有的硬件资源和内存，包括保护和敏感的系统资源。
- 内核态允许操作系统执行关键任务，如管理硬件设备、执行系统调用、调度进程、分配内存、处理中断和异常等。

##### 用户态

- 用户态是应用程序运行的特权级别，具有较低的系统权限，应用程序只能执行受限的指令，无法直接访问大部分硬件资源和系统数据结构。
- 用户态允许应用程序执行普通任务，如数据处理、图形界面交互、文件操作等，而不能直接执行敏感操作或访问系统资源，必须通过系统调用（系统服务）来请求内核执行特定任务，系统调用是用户态和内核态之间的接口。

操作系统的内核代码运行在内核态，而用户程序的代码运行在用户态。

## 11、为什么要分内核态和用户态？

内核态和用户态分离的好处：

- 内核代码在内核态下运行，可以执行高风险和关键的任务；
- 应用程序代码在用户态下运行，不会对系统的稳定性产生直接影响；

所以，这种分离有助于维护操作系统的稳定性、安全性和可靠性，避免应用程序的错误和恶意行为对整个系统造成损害。

## 12、用户态和内核态如何切换？

用户态只能执行用户代码，而当应用程序需要处理关键任务时，比如：从硬盘读取数据、和外部设备交互等，这些都是内核态的权限，所以就必须切换到内核态（也叫做：**陷入内核**），内核态处理完再切换回用户态。

用户态和内核态切换的几种方式：

##### 1、系统调用

用户态程序可以通过系统调用请求内核执行特定的操作。

系统调用是一种显式的用户态到内核态切换，用户程序通过特定的系统调用指令请求内核执行相应的任务，比如文件读写、网络通信、进程创建等。

##### 2、异常处理

当用户态程序执行时发生错误或违反了特定的规则时（比如访问未分配内存或执行非法指令），就会引发异常，这会导致处理器从用户态切换到内核态，以处理异常情况。

##### 3、硬件中断

内核态和用户态之间的切换可以通过硬件中断触发，比如，时钟中断、硬件设备中断、网络数据包到达等事件，可以引发内核进入内核态执行相关中断处理程序，然后再返回用户态。

## 13、什么是进程？

进程是操作系统中的基本概念，进程（Process）是计算机程序的执行实例，它代表了计算机中正在运行的程序，用于管理和调度程序的执行，操作系统通过进程管理实现了**资源的分配、并发执行、通信和协作**，从而实现了多任务处理。

进程的主要特性如下：

##### 1、独立实例

进程是应用程序的执行实例，一个程序可以被多个进程同时执行，每个进程拥有自己的内存空间、寄存器状态、栈和其他资源。

每个进程都有一个唯一的标识符，即进程ID（PID），用于操作系统识别和管理进程。进程之间是独立的，他们互相隔离，一个进程的错误或崩溃不会影响其他进程的正常运行。

##### 2、并发执行

操作系统可以同时运行多个进程，实现多任务并发执行，操作系统会分配处理器时间片，轮流执行各个进程。

##### 3、资源分配

进程是资源分配额最小单位，操作系统分配和管理进程所需的资源，包括内存、CPU时间、文件描述符、网络连接等。

##### 4、状态管理

进程可以处于不同的状态，包括就绪状态、运行状态、等待状态和终止状态，操作系统管理进程的状态转换和调度。

##### 5、通信和同步

进程之间可以通过进程间通信（Inter-Process Communication, IPC）机制进行数据交换和协作，IPC包括管道、共享管道、共享内存、消息队列、套接字等。

##### 6、父子进程

进程可以创建其他进程，创建进程的进程称为父进程，被创建的进程成为子进程，父进程可以监控和控制子进程。

## 14、进程由哪些部分组成？

进程由以下几个关键部分组成：

##### 1、进程控制块（PCB）：

PCB是操作系统中用于管理进程的数据结构，它包含了进程的状态、标识符（如进程ID）、调度信息、资源占用信息、打开文件表等，PCB使操作系统能够对进程进行管理和调度。

#### 2、程序代码

进程包含执行的程序代码，即程序的指令集合，这些指令定义了进程的操作和行为。

##### 3、数据

进程需要使用数据来执行任务，包括程序的变量、常量、数据结构等，数据存储在进程的内存空间中。

## 15、进程有哪几个状态？怎么流转的？

进程的几个状态是：

| 进程状态               | 描述 |
| ---------------------- | ---- |
| 创建状态（Created）    |      |
| 就绪状态（Ready）      |      |
| 运行状态（Running）    |      |
| 阻塞状态（Blocked）    |      |
| 终止状态（Terminated） |      |

进程状态之间的流转通常如下：

![](/images/操作系统/15.jpg)

- **创建状态 -> 就绪状态**：当进程被初始化并准备好运行时，它从创建状态切换到就绪状态；
- **就绪状态 -> 运行状态**：操作系统的调度程序选择就绪状态的进程，并将其切换到运行状态，开始执行；
- **运行状态 -> 阻塞状态**：进程在等待某个事件发生时，会从运行状态切换到阻塞状态；
- **阻塞状态 -> 就绪状态**：一旦阻塞状态的进程等待的事件发生，它将切换回就绪状态，等待操作系统的调度；
- **运行状态 -> 终止状态**：当进程执行结束时，它从运行状态切换到终止状态。

## 16、进程的基本操作有哪些？

进程的基本操作如下：

| 操作           | 描述 |
| -------------- | ---- |
| 创建进程       |      |
| 等待进程       |      |
| 切换进程       |      |
| 修改进程优先级 |      |
| 分配和回收资源 |      |
| 挂起和恢复进程 |      |
| 终止进程       |      |

## 17、什么是进程表？

进程表是操作系统用于管理和维护系统中所有正在运行的进程信息，以便进行进程调度、资源分配、进程间通信等操作，操作系统可以确保多个进程能够同时运行，而不会发生冲突或混乱。

进程表是一个PCB数组，每个进程表项对应一个进程，包含该进程的各种信息：

| 属性             | 描述 |
| ---------------- | ---- |
| 进程ID（PID）    |      |
| 进程状态         |      |
| 程序计数器（PC） |      |
| 寄存器值         |      |
| 执行时间和优先级 |      |
| 父进程ID         |      |
| 打开文件列表     |      |
| 资源使用情况     |      |
| 等待队列         |      |
| 各种状态标志     |      |

## 18、什么是守护进程？

守护进程是操作系统中以后台方式运行的一种特殊类型的进程，守护进程通常在系统启动时启动，并在系统运行期间持续存在，以执行一些特定的任务或服务。

守护进程以无交互的方式运行，不予用户直接交互，而是在后台默默地执行任务。

典型的守护进程包括以下几个：

- 系统日志守护进程（syslogd）
- 网络服务守护进程（如：HTTP服务器、数据库服务器）
- 定时任务守护进程（cron）
- 硬件设备守护进程等。

## 19、什么是孤儿进程？

孤儿进程是指当**一个父进程提前终止或意外终止时，其子进程继续在系统中执行**，它们在处于没有父进程控制的情况下而存在，这些子进程被称为**孤儿进程**。

操作系统的**init**进程会接管孤儿进程，成为它们的新的父进程，**init**进程负责处理这些孤儿进程的终止，以释放它们占用的系统资源。

## 20、什么是僵尸进程？

僵尸进程指的是一个子进程已经终止了，**但其父进程还没有处理子进程的终止状态**，此时，**其退出状态信息仍然保留在系统中**，等待父进程获取，如果父进程未及时处理子进程的退出状态，操作系统的**init**进程会自动接管这些僵尸进程，以便清理它们的资源信息。

虽然僵尸进程不会再执行代码，但它们仍然存在于进程表中，占用极少的系统资源，一般不会导致系统性能下降。

## 21、什么是线程？

线程（Thread）时计算程序执行的最小单元，它是进程的一部分，用于执行程序的实际指令。在一个进程内，可以包含多个线程，这些线程共享相同的内存空间和资源，但可以单独执行不同的任务。

线程的主要特性如下：

##### 1、轻量级执行单元

线程是轻量级的执行单元，相比整个进程，线程的创建、销毁和切换开销较小，因此可以更高效地支持多任务并发执行。

##### 2、共享资源与通信

在同一进程中的线程共享相同的内存空间和资源，这使得线程之间可以相互通信和共享数据。

##### 3、并发执行

多个线程可以并发执行，它们在不同的CPU核心上或在同一核心上交替执行，提高了程序的响应速度和资源利用率。

##### 4、同步与互斥

线程之间的并发执行可能导致竟态条件和数据访问冲突。因此，线程需要使用同步机制（如互斥锁、信号量、条件变量）来协调堆共享资源的访问。

##### 5、优先级

操作系统调度器独立地调度线程的执行，不同线程可以具有不同的优先级，操作系统会根据优先级来决定现成的执行顺序。

##### 6、线程状态

线程可以处于不同的状态，包括就绪状态、运行状态、等待状态和终止状态，操作系统管理线程的状态转换和调度。

##### 7、用户态与内核态切换

线程可以在用户态和内核态之间切换，当线程需要执行特权操作（如系统调用）时，会从用户态切换到内核态。

## 22、线程可以分为哪两种？

##### 1、用户级线程：

- 用户级线程完全在用户空间中管理，操作系统内核不会参与它们的调度和管理；
- 由于用户级线程管理不需要内核模式的切换，所以具有更低的开销；
- 由于用户级线程没有内核参与，所以并发效率没有内核级线程高；

##### 2、内核级线程：

- 内核级线程有操作系统内核进行管理和调度；
- 由于内核级线程管理需要切换内核态，所以增加了一定的开销；
- 由于内核可以将不同内核级线程更好地分配到不同的CPU上，所以并发效率要更高；

在现代操作系统中，通常会使用组合方式实现多线程，即用户级线程完全在用户空间中创建，并且一个应用程序中的多个用户级线程可以被映射到一些内核级线程上，以实现更优的性能。

## 23、什么是上下文？

上下文（Context）是指进程（或线程）的运行环境，它描述了一个线程或进程当前执行状态和环境的一组信息，包括了程序运行所需的寄存器状态、内存分配、变量值、CPU指令执行位置等，以便系统可以在需要时暂停、恢复或切换执行。

上下文大概包括以下内容：

- 寄存器状态：包括通用寄存器、程序计数器（PC）等，这些寄存器保存了程序的运行状态和执行位置；
- 内存映射：描述了程序或进程的内存分配，包括代码段、数据段、堆栈等；
- 变量值：包括程序中的各种变量、数据结构和内容以及执行过程中的临时数据；
- 堆栈信息：描述了函数调用栈，包括当前函数的参数、局部变量和返回地址；
- 打开文件和网络连接：描述了程序打开的文件、套接字连接以及其他I/O资源；

## 24、什么是上下文切换？

因为一个CPU核心在任意时刻只能被一个线程使用，而CPU的资源是有限的，并发执行的线程数可能远远超过CPU核心数，所以，为了让这些线程都能得到有效执行，**有时需要将CPU资源从一个进程（线程）切换到另一个进程（线程），这便是上下文切换（Context Switching）**。

当进行上下文切换时，操作系统会将当前执行的进程（线程）状态保存起来，并恢复另一个进程（线程）的状态，以实现多进程（线程）之间的切换执行，用于确保多个进程（线程）可以共享处理器的时间，以实现并发执行。

上下文切换一般分为线程切换和进程切换，两者的差异主要体现在资源消耗上，进程上下文切换无疑要更高，另外，上下文切换会消耗大量的CPU时间和内存操作，所以要尽量避免减少上下文切换，以提高系统的性能和响应速度。

## 25、怎么查看上下文切换情况？

##### 1、vmstat

使用vmstat命令可以查看系统总体的上下文切换情况：

![](/images/操作系统/25_1.png)

参数解释：

| 列名 | 含义 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

##### 2、pidstat

vmstat命令只能看到系统总体的上下文切换情况，如果要查看每个进程的纤细情况，可以使用**pidstat**命令，pidstat是著名的采集软件**sysstat**的组件之一，用于监控全部或指定进程的CPU、内存、线程、设备IO等系统资源的占用情况。

首先安装sysstat

> $ sudo yum install sysstat

然后使用pidstat -w命令查看：

![](/images/操作系统/25_2.png)

参数解释：

- **cswch（voluntary context switches）**：

  表示每秒**自愿上下文切换**的次数，即进程无法获取所需资源时所导致的上下文切换次数。

- **nvcswch （non voluntary context switches）**：

  表示每秒**非自愿上下文切换**的次数，即进程由于时间片已到等原因，被系统强制进行的上下文切换次数。

## 26、如何避免上下文切换？

上下文切换是操作系统中的必要操作，不能完全避免，但是可以尽量避免。

下面一些常见的优化技巧：

##### 1、调整线程数量

建议将系统的线程数调整到合适的水平，过多的线程会消耗更多CPU资源，增加上下文切换的概率。相反，如果线程过少，也无法充分利用CPU资源，造成资源浪费。

##### 2、使用线程池

使用线程池来管理线程的创建和销毁，减少线程的频繁创建和销毁。

##### 3、使用非阻塞IO

使用非阻塞IO操作，例如异步IO或事件驱动编程，可以减少在IO操作中的等待时间。

##### 4、合理调度

使用合适的调度算法，确保高优先级任务能够及时执行。

##### 5、减少锁竞争

少使用同步锁，或者使用无锁数据结构来减少多线程之间的锁争用。

## 27、为什么进程上下文切换比线程上下文切换代价高？

##### 不同内存空间：

- **进程**：每个进程有自己的独立的虚拟内存空间，进程上下文切换会改变内存空间的映射，另外也需要保存和恢复更多的状态信息；
- **线程**：线程是进程内的轻量级执行单元，共享相同的内存空间，线程上下文切换不需要改变内存空间的映射，因此，线程的内存空间依然是相同的，涉及的状态信息也要更少。

##### 内核介入程度：

- **进程**：进程上下文切换涉及更多的操作系统内核级操作；
- **线程**：线程上下文切换更轻量级，尤其是用户线程，可能完全不需要内核的介入。

##### 缓存和局部性：

- **进程**：因为不同进程的数据和代码位于不同的内存区域，进程上下文切换可能导致缓存和TLB失效；
- **线程**：线程上下文切换由于仍在同一进程内部，所以更可能保持缓存和TLB的有效性。

## 28、什么是临界资源和临界区？3

##### 临界资源：

临界资源是指一次仅允许一个进程使用的共享资源，多个进程必须互斥对它进行访问，如某进程占用了临界资源，其他进程就会被阻塞直到临界资源被释放。

临界资源包括硬件临界资源和软件临界资源，如：**共享内存区域、文件和数据库连接、硬件设备、系统资源和服务**等。

##### 临界区：

临界区是指每个进程中访问临界资源的那段代码。

## 29、系统调用与库函数的区别？

系统调用和库函数，它们是用于访问操作系统和执行特定任务的两种不同方式。

##### 系统调用：

系统调用是应用程序与操作系统之间的接口，用于请求操作系统执行特权操作，例如文件操作、进程管理、网络通信等。系统调用允许应用程序访问底层的系统资源和功能，如内核态。

##### 库函数：

库函数是由编程语言或第三方库提供的函数，用于执行特定任务，如字符串操作、数学计算、图形处理等。库函数通常是在用户态运行的，它们是使用高级语言编写的常规函数。

-----

它们的区别如下：

##### 权限控制：

- **系统调用**：系统调用通常涉及特权操作，需要进行用户态到内核态的切换。因此，系统调用需要操作系统的授权，并受到操作系统的权限控制；
- **库函数**：库函数通常在用户态运行，不需要特权访问，可以直接由应用程序调用，它们不会引发用户态到内核态的切换，因此不涉及操作系统的权限控制。

##### 调用性能：

- **系统调用**：由于系统调用涉及内核态和用户态之间的切换，所以会比库函数更影响性能；
- **库函数**：库函数通常在用户态运行，因此调用它们通常比系统调用更快速，并且更轻量级。

##### 使用场景：

- **系统调用**：通常用于访问操作系统提供的底层功能，如文件操作、进程管理、网络通信等，它们通常用于实现高级功能或解决操作系统级别的问题；
- **库函数**：用于执行通用任务，如数据处理、算法实现、用户界面开发等，它们通常用于构建应用程序的核心功能。

## 30、静态链接库与动态链接库的区别？

##### 链接时机：

- 静态链接库在程序编译时，将静态链接库的全部指令直接链接入可执行文件中，程序包含了它所需的所有代码；
- 动态链接库只有在程序运行时才被加载，可执行文件仅包含对动态库函数的引用，而不是函数的实际代码。

##### 相互包含：

- 静态链接库中不能包含动态链接库或静态链接库；
- 动态库中还可以再包含其他动态链接库和静态链接库。

##### 文件体积：

- 静态链接库被编译进可执行文件中，所以可能会导致程序文件体积较大；
- 动态链接库的库文件是分开存储的，并且在需要时有多个程序共享，所以不会导致程序文件体积太大。

##### 更新和维护：

- 更新静态链接库，所有使用该库的程序都需要重新编译和链接；
- 更新动态链接库更加灵活，只需替换库文件本身，使用给库的程序再下次运行时会加载新的库版本。

##### 依赖和分发：

- 静态链接库生成的可执行文件不依赖于外部库文件， 编译分发和运行；
- 动态链接库的程序需要确保运行环境中由正确版本的库文件，如果缺少，程序可能无法运行。

##### 运行时性能：

- 静态链接库再编译时就已经和程序代码一起优化，性能通常比动态链接库要好；
- 动态库可能在加载时稍微慢一些，但对于系统资源的总体占用来说可能更高效。

## 31、什么是信号？

在操作系统中，信号是一种轻量级的进程间通信机制，用于向进程发送异步通知或中断。

信号通常用于处理异步事件，如用户输入、硬件异常、系统状态变换等，操作系统和其他进程可以向目标进程发送信号，以触发特定的动作或通知进程发生了某种事件。

比如在Linux系统中，kill命令就可以向进程发送信号，并可指定信号类型，用于终止或管理正在运行的进程。

## 32、什么是时钟？

时钟又称为计时器，主要负责维护时间。

操作系统中的时钟通常有两种主要类型，操作系统会利用这两种时钟来管理时间，以确保计算机系统正常运行并提供时间相关的服务。

##### 1、系统时钟

系统时钟是操作系统内部使用的时钟，它用于测量时间和协调系统内部的活动。

- 时间管理：系统时钟用于跟踪系统的时间，记录时间戳、计算时间间隔等。
- 电源管理：系统时钟也在电源管理中发挥作用，帮助操作系统管理计算机调的节能模式和唤醒机制。
- 时钟中断：系统时钟周期性地触发时钟中断，操作系统会捕获这个中断并执行相应的处理程序。

##### 2、硬件时钟

硬件时钟是一种物理设备，通常是计算机主板上的一个独立芯片，它用于持久性地跟踪实时的日期和时间，即使计算机关闭也能保持准确。

硬件时钟通常用于操作系统启动时初始化系统时间，并在需要时提供准确的时间信息。

## 33、什么是中断？

中断时操作系统中的一种事件，它是由硬件设备、外部信号或软件请求引发的，用于打破正常的程序执行流程，以通知操作系统或处理器需要采取某种特殊的处理动作。

中断的目的时允许计算机系统对外部事件进行响应，例如处理硬件设备的输入/输出、处理异常条件、进行系统调度等，等这些特殊事件处理完之后再回去执行之前的程序。

中断通常可以分为两种主要类型：

- 硬件中断：由外部硬件设备生成的中断，例如时间中断、键盘中断、磁盘中断等；
- 软件中断：由正在运行的程序或操作系统内部生成的中断，包括系统调用和异常处理。

中断允许计算机系统在不同的上下文之间切换，以处理紧急事件或执行特殊任务，然后再返回到原始的执行上下文，这种切换可以确保系统能够有效地管理多个任务并响应外部事件，使计算机系统更加灵活和高效。

## 34、中断和异常的区别？

中断和异常都是系统在执行过程中，对特殊情况的响应机制。

##### 中断：

中断时操作系统中的一种事件，它是由硬件设备、外部信号或软件请求引发的，用于打破正常的程序执行流程，以通知操作系统或处理器需要采取某种特殊的处理动作。

##### 异常：

异常则一般是由程序执行过程中的错误或特殊情况引起的，比如数组越界、内存溢出等异常，需要由操作系统或程序本身来处理。

## 35、什么是时间片？

时间片用于划分CPU时间，即**CPU分配给每个进程或线程的固定时间段**，即每个进程或线程在执行时最多可以占用CPU时间片的时长，然后必须让出CPU资源，以便多个任务能轮流执行，从而实现并发执行，确保了系统的响应性和公平性。

如果进程（线程）在时间片结束后还在运行，或者在时间片过期前阻塞或终止了，CPU都会让出资源。

## 36、进程调度的时机有哪些？ 

进程调度的时机一版有以下几种：

##### 1、进程创建

当一个新进程被创建时，操作系统需要决定何时将其放入就绪队列以等待CPU执行，这是一个初始的进程调度时机。

##### 2、进程终止

当一个进程完成它的任务或发生错误而终止时，操作系统需要选择一个要运行的进程。

##### 3、时间片用尽

在使用时间片轮转调度算法时，一个进程再分配的时间片用尽后，会被挂起并放回就绪队列。此时，调度程序需要选择下一个要运行的进程。

##### 4、阻塞/唤醒

- 当一个进程执行IO操作或等待某些事件发生时，它会从运行状态切换到阻塞状态，操作系统需要选择一个新的就绪进城来执行；
- 当一个被阻塞的进程等待的事件发生，它将从阻塞状态转换为就绪状态，等待进一步调度。

##### 5、抢占条件

在抢占性调度中，操作系统可以选择中断当前运行的进程，将CPU分配给更高优先级的进程。

## 37、常见的调度算法都有哪些？

下表是一些常见的调度算法：

| 调度算法               | 类型            | 特点 |
| ---------------------- | --------------- | ---- |
| 先来先服务调度算法     | 非抢占式        |      |
| 最短作业优先调度算法   | 非抢占式        |      |
| 最短剩余时间调度算法   | 抢占式          |      |
| 高响应比优先级调度算法 | 抢占式          |      |
| 时间片轮转调度算法     | 抢占式          |      |
| 多级反馈队列调度算法   | 抢占式          |      |
| 最高优先级优先调度算法 | 非抢占式/抢占式 |      |

## 38、怎么理解抢占式和非抢占式？

**”抢占式“**和**”非抢占式“**是操作系统中两种不同的进程调度策略，它们决定了在多个就绪进程之间如何分配CPU时间，这两种策略的核心在于弄清楚何时一个正在执行的进程可以被中断，以便其他进程有机会执行。

##### 抢占式：

- 抢占式调度允许操作系统随时中断正在执行的进程，将CPU分配给其他高优先级进程。
- 抢占式调度常用于多任务操作系统，以确保及时响应高优先级任务，同时防止低优先级任务长时间占用CPU。

##### 非抢占式：

- 非抢占式调度不会在进程执行期间中断它，而是等待进程主动放弃CPU控制权，或等待发生阻塞事件。
- 非抢占式调度常用于实时操作系统，其中任务有确定的执行时间，确保任务执行的确定性。

## 39、影响进程调度算法的指标有哪些？

下表是影响进程调度算法的主要指标：

| 指标      | 描述                           |
| --------- | ------------------------------ |
| CPU利用率 | CPU执行任务所占的时间百分比    |
| 吞吐量    | 单位时间内CPU完成进程的数量    |
| 等待时间  | 进程处于等待处理机状态的总时间 |
| 周转时间  | 进程提交最终完成执行的总时间   |
| 响应时间  | 用户提交请求到获得响应的总时间 |

## 40、不能进行进程的调度与切换的情况有哪些？

一般有以下三种情况：

##### 1、当操作系统处理中断时

中断通常代表着紧急事件或硬件状态的改变，系统必须尽快响应，这个过程设计复杂的任务，所以，不能进行进程的调度与切换，以确保系统的正常运行。

##### 2、当进程位于操作系统的内核程序临界区时

此时进程可能正在访问一些共享资源，这些资源需要保存一致性，所以，不能进行进程的调度与切换，以确保对共享资源的独占性访问。

##### 3、在原子操作过程中

原子操作是一种不可分割的操作，它要么完全执行，要么完全不执行，没有中间状态，所以，不能进行进程的调度与切换，必须一气呵成，以保持数据的可靠性。

## 41、什么是优先级反转问题？如何解决？

优先级反转：低优先级的线程优先于高优先级的线程先执行，具体来说，当多线程在共享资源时，导致高优先级线程迟迟得不到调度，反而使其他低等优先级的线程却能抢到CPU资源而先执行。

以下是两种解决方案：

##### 1、优先级继承

当一个低优先级线程占用了一个高优先级线程需要的共享资源时，系统会将低优先级线程的优先级提高到与高优先级线程相同或更高的级别，以确保高优先级线程能够及时完成。一旦低优先级线程释放了资源，它的优先级将被还原到原始值。

##### 2、优先级天花板

当线程使用共享资源时，不管该线程是否阻塞了高优先级的线程，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级，即该资源的优先级天花板。

## 42、什么是虚拟内存？

虚拟内存是计算机操作系统中的一个管理和扩展物理内存的技术，它通过将**物理内存和磁盘空间结合使用**，用磁盘来模拟内存空间，即将内存中使用较少的数据移动到外部磁盘存储器中，以释放其内存空间供其他程序使用，当物理内存不足时，系统可以从虚拟内存中读取数据，并将其写回虚拟内存以腾出更多空间。

虚拟内存的主要目的是**提高系统的稳定性和多任务处理能力**，为每个进程提供了一种具有更大连续内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

## 43、物理地址和虚拟地址的区别？

物理地址和虚拟地址是计算机内存管理中不同的两个概念。

##### 物理地址：

物理地址是实际存在于计算机硬件内存芯片上的唯一地址，它可以直接访问硬件中的存储单元。

物理地址是固定的，并且受到物理内存大小的限制。

##### 虚拟地址：

虚拟地址是进程或程序所使用的地址，它是逻辑地址，不能直接访问硬件中的存储单元。虚拟地址是任意的，不受物理内存大小的限制。

操作系统可以使用内存管理单元（）将虚拟地址映射到物理地址，当程序访问虚拟地址时，实际上访问的是物理地址。

## 44、虚拟内存实现有哪几种方式？

虚拟内存实现主要有以下几种方式：

##### 1、分页

物理内存和虚拟内存被分成固定大小的页（），进程的虚拟内存空间也被划分成相同大小的页面，操作系统通过页表来跟踪哪些页在物理内存中，哪些页在磁盘上，当进程访问虚拟内存中的某一页时，操作系统将相应调的物理页加载到内存中。

##### 2、分段

它将程序的不同部分（如函数、数组等）划分为逻辑上的段（Segment），每个段都可以有不同的大小，分段皆在使程序和数据的组织更加符合其逻辑结构，从而提高效率。

##### 3、段页式

这种方式结合了分段和分页的特点，虚拟内存空间首先被划分成固定大小的页，这种方式允许更灵活地管理不同类型的数据，同时提供了粒度更细的地址映射。

## 45、虚拟内存是越大越好吗？

虚拟内存的大小并不一定是约到越好，而是需要根据具体的应用场景和系统需求来合理配置。

过大的虚拟内存可能会导致性能下降，因为虚拟内存是通过外部磁盘来模拟内存空间的，而磁盘的读写速度远比内存要慢得多，所以，**当虚拟内存过大时，就会导致操作系统频繁地与磁盘交换数据，从而影响性能。**

## 46、内部碎片与外部碎片的分别？怎么解决？

内部碎片和外部碎片都是与内存分配和管理相关的概念，通常出现在操作系统和内存管理系统中，这些内存碎片会降低内存的有效利用率，有效地管理内存碎片对于确保内存的高效使用和系统性能至关重要。

##### 内部碎片

----

内部碎片，指的是分配给进程的内存块中存在但未被使用的内存部分。

这种浪费的内存是由于进程所请求的内存大小通常以固定的块或页面为单位分配，而进程实际需要的内存可能小于分配的块大小。所以，未被使用的部分构成了内部碎片。

> 比如，如果一个进程请求了1MB的内存，但实际只使用了900KB，那么有100KB的内部碎片。

解决内部碎片的方法通常包括内存分配策略，如使用动态分区分配或首次适应算法等，以更好地匹配进程的内存需求。

##### 外部碎片

----

外部碎片，指的是在物理内存中存在但无法分配给任何进程的内存块或碎片。

外部碎片通常是由于内存分配和释放的不规则性或动态性而产生的，即使总的可用内存足够，但由于内存块之间存在零散的未使用内存，导致无法满足某些进程的内存需求。

> 比如，如果物理内存中有大量散落的未使用内存块，但它们都太小以至于无法满足某个大型进程的内存请求，这就导致了外部碎片。

解决外部碎片的方法包括内存紧缩、内存合并或使用虚拟内存等技术，以优化可用内存块的分配。

## 47、什么是页面置换？

页面置换算法是用于虚拟内存管理中的一种策略，虚拟内存允许操作系统在物理内存不足的情况下运行更多的进程，但由于物理物理内存是有限的，操作系统不可能将所有进程的所有页面都加载到内存中。

所以，当一个进程访问了一个未加载到内存中的页面，并且内存已经满了时，**操作系统需要从内存中替换一个页出去，并从磁盘加载一个新页面**，这便是页面置换。

## 48、常见的页面置换算法有哪些？

常见的页面置换算法：

##### 1、先进先出页面置换算法（FIFO）

先进先出，即置换最早进入内存中的页面。

这种算法实现简单，缺点就是置换出去的页面也能是经常要被访问的。

##### 2、最近最少使用页面置换算法（LRU）

最近最少使用，即置换最近最久未被访问的页面。

这种算法需要维护一个页面访问历史记录，实现稍微要复杂一点，但性能较好。

##### 3、最不常用页面置换算法（LFU）

最不常用，即置换访问次数最少的页面。

这种算法需要维护页面的访问计数，缺点就是开销较大，另外，前期访问较多后期没有访问的页面很难被置换。

## 49、什么是写时复制？

写时复制是一种内存管理技术，其核心思想是在某个进程需要修改共享资源时，才进行实际的复制，而在只读或未修改的情况下则不用复制，继续使用共享资源，旨在提高资源的利用效率和减少复制数据的开销。

写时复制通常用于共享数据结构，例如字符串、列表、树等，当多个进程需要访问相同的数据时，写时复制可以提供高效的共享和修改保护，确保数据的一致性和安全性。

##### 写时复制的工作原理：

- 初始阶段，多个进程或线程共享一个资源；
- 当有一个进程需要修改这个共享资源时，不会直接进行修改，而是首先创建该资源的一份副本，即复制一份独立的资源；
- 原始资源和副本资源不再共享相同的内存区域，修改操作只应用于副本资源；
- 其他进程继续使用共享资源，而不受影响。

写时复制的好处包括：

- **节省内存**：在资源被修改之前，多个进程可以共享相同的资源，无需复制多份相同的数据；
- **高效性**：只有在需要修改资源时才进行复制，减少了复制的开销；
- **数据一致性**：资源的修改不会影响其他进程对相同资源的访问，因为它们访问的是不同的副本；

## 50、什么是按需分页？

进程是以页为单位加载到内存中的，操作系统不会一开始将进程的所有页面加载到物理内存中，只有在进程实际需要访问某个页面时，才将该页面加载到物理内存中。

这种方式减少了初始加载的开销，提高了内存利用率，但可能会导致性能开销，因为每次页面错误都需要访问磁盘。

## 51、什么是懒分配？

操作系统在分配内存时不会立即分配物理内存页，只有在进程实际访问这些分配时，才分配物理内存页。

这种方式减少了初始内存分配的开销，特别是对于大型数据结构，提高了内存分配的效率，但可能会在访问分配时引发页面错误，需要额外的处理。
