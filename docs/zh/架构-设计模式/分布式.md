## 1、什么是 CAP 原则？

CAP 原则又称 CAP 定理，在一个分布式系统中包含三个部分，Consistency（**一致性**）、Availability（**可用性**）、Partition tolerance（**分区容错性**）。

##### 一致性（C）：

同一时刻，分布式系统中所有节点的数据都是相同的。

##### 可用性（A）：

在合理时间范围内，系统是否能够正常响应客户端的读写请求。

##### 分区容错性（P）：

当分布式系统集群中的一部分节点或者网络分区故障后，系统是否仍能正常提供服务。

## 2、CAP 原则可以同时满足几个？

CAP 原则不能同时满足，最多只能满足两个，这也是分布式理论的基础。

| CAP | 说明                                                                                           |
| --- | ---------------------------------------------------------------------------------------------- |
| CA  | 放弃 P（分区容错性），意味着不能进行网络分区，放弃了系统的可扩展性。                           |
| CP  | 放弃 A(可用性)，系统如遇到网络故障，那么受到影响的服务需要等待一定的时间，系统在该时段不可用。 |
| AP  | 放弃 C（一致性），放弃数据的强一致性，但可以实现数据的最终一致性。                             |

实际工作中，一般要保证 P（分区容错性），在 C（一致性）/A（可用性）中作出选择，涉及到金钱的要保证（C）强一致性。

## 3、CAP 原则为什么不能同时满足？

**C**onsistency（**一致性**）

**A**vailability（**可用性**）

**P**artition tolerance（**分区容错性**）

---

如果要保证 CAP 三个都满足，即发生网络分区（P）后：

1）要保证合理时间内正常提供服务（A），这时候数据库可能都断开了，没有同步，某些节点的数据可能不是最新的了，显然就不能保证所有节点的数据一致性了（C）；**----AP**

2）要保证数据一致性（C），那就要等网络恢复并完成数据同步后才能正常提供服务，这样就不能保证可用性（A）了，即不能在合理时间内正常提供服务；**------CP**

---

所以，CAP 不能同时满足，要在 AP/ CP/ CA 之间作出选择。

## 4、什么是 BASE 原则？

##### BASE 原则是指：

- Basically Available (基本可用)
- Soft state (软状态)
- Eventually consistent (最终一致性)

BASE 是对 CAP 中一致性和可用性的一个权衡，即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使得系统达到最终一致性。

## 5、什么是 RMI？

**RMl**，全称：Remote Method Invocation，即：“**远程方法调用**"，是 JDK1.2 中实现的，用于在分布式系统中实现远程调用，它允许 Java 应用程序中的一个对象调用另一个 Java 应用程序中的对象的方法，就像调用本地对象的方法一样，RMIl 大大增强了 Java 开发分布式应用的能力。

> ##### RMI 的基本思想是：
>
> 将 Java 对象视为可以在网络上传输的对象，并使用 Java 序列化来在客户端和服务器之间传递这些对象。通过 RMI，开发人员可以将应用程序拆分成可复用的组件，这些组件可以在网络上进行调用，从而构建分布式系统。

RMI 的核心组件包括：

- **远程接口（RemoteInterface）**：定义了客户端和服务器之间可以调用的方法。
- **远程对象（RemoteObject）**：实现了远程接口，并且能够在远程服务器上调用。
- **远程存根（RemoteStub）**：在客户端代表远程对象的代理，使得客户端可以像调用本地对象一样调用远程对象的方法。
- **RMI 注册表（RMI Registry）**：提供了远程对象的注册和查找服务。

RMII 还提供了一些高级特性，如远程异常处理、动态代理、对象传输等，使得它更加适合于构建基于 Java 的分布式系统。通过使用 RMI，Java 开发人员可以轻松地构建分布式应用程序，而无需担心底层的网络通信和远程调用细节。

## 6、什么是 RPC？

**RPC**，全称：Remote Procedure Call，即：“**远程过程调用**"，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络通信的规范或协议，可以理解为一台计算机程序远程调用另外一台计算机的子程序，而不用关心底层网络通信。

> ##### 一个通俗的描述是：
>
> 客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。

## 7、RMI 和 RPC 有什么区别？

RMI（远程方法调用）和 RPC（远程过程调用）是两种用于实现分布式系统中远程调用的技术，它们的使用需要看具体的应用场景和需求。

它们之间的主要区别包括：

##### 编程语言和平台

RMl 基于 Java 编程语言，只能用于 Java 应用程序之间的通信，而 RPC 是一种通用的远程调用机制，可以用于不同的编程语言和平台之间的通信。

##### 通信协议

RMI 使用 JaVa 远程方法协议（JRMP）作为通信协议，而 RPC 使用各种通信协议，如 HTTP、TCP、UDP 等来实现远程调用。

##### 编程模型

RMI 采用了面向对象的编程模型，将远程调用看作是一种方法调用，使得远程调用和本地调用非常类似。而 RPC 采用了过程式编程模型，将远程调用看作是一种过程调用，也类似于本地调用。

##### 实现复杂度

RMI 相对来说比较简单，因为它是基于 Java 编程语言和 JRMP 通信协议实现的，可以轻松地在 Java 平台上使用。而 RPC 的实现则比较复杂，因为它需要解决跨语言、跨平台、网络传输等多种问题。

##### 功能特性

RMI 提供了一些高级特性，如远程异常处理和对象传输等，使得它更加适合于构建基于 Java 的分布式系统。而 RPC 的实现则相对简单，它的主要功能是在不同语言和平台之间进行通信。

## 8、什么是 SOA？

**SOA：面向服务的架构**，是一种软件设计和开发的方法论，旨在实现应用程序中的模块化、松耦合、可重用和可维护性。在 SOA 中，应用程序被视为一组相互独立的服务，这些服务可通过网络互相通信并相互协作，从而实现特定的业务功能。

> ##### SOA 的核心思想是：
>
> 将应用程序拆分成独立的、自治的服务，并通过标准化的接口，使它们可被其他服务和应用程序调用。

SOA 可以提高应用程序的灵活性、可重用性和可维护性，因为它们可以在不影响整个应用程序的情况下进行单独部署、测试、更新和替换。

SOA 也支持跨组织、跨平台和跨技术栈的集成，使不同的应用程序和服务可以共同工作，并促进了企业内部和企业间的合作。

## 9、你怎么理解分布式系统？

##### 分布式系统背景

说分布式系统必须要说集中式系统，集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目，所有的东西都在一个应用里面。

如下图所示：

![](/images/分布式/9_1.jpg)

如一个网站就是一个应用，最后是多个增加多台服务器或者多个容器来达到负载均衡的避免单点故障的目的，当然，数据库是可以分开部署的。

集中式很明显的优点就是开发测试运维会比较方便，不用为考虑复杂的分布式环境。

集中式很明显的弊端就是不易扩展，每次更新都必须更新所有的应用。而且，一个有问题意味着所有的应用都有问题。当系统越来越大，集中式将是系统最大的瓶颈。

##### 什么是分布式系统？

> 分布式系统是若干独立计算机的集合，这计算机对用户来说就像单个相关系统。

以上定义摘自<<分布式系统原理与范型>>一书。

也就是说分布式系统背后是由一系列的计算机组成的，但用户感知不到背后的逻辑，就像访问单个计算机一样。

说的有点绕，我们可以来简单看下分布式系统图。

![](/images/分布式/9_2.jpg)

## 10、使用分布式系统有什么优缺点？

##### 分布式系统的优点：

1、应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC 端等定义不同的接口应用；

2、数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；

3、增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件；

很明显，分布式系统可以解决集中式不便扩展的弊端，我们可以很方便的在任何一个环节扩展应用，就算一个应用出现问题也不会影响到别的应用。

随着微服务 Spring Cloud & Docker 的大热，及国内开源分布式 Dubbo 框架的重生，分布式技术发展非常迅速。

##### 分布式系统的缺点：

分布式系统虽好，也带来了系统的复杂性，如：分布式事务、分布式锁、分布式 session、数据一致性等都是现在分布式系统中需要解决的难题。

虽然已经有很多成熟的方案，但都不完美。

分布式系统也增加了开发测试运维成本，工作量增加，分布式系统管理不好反而会变成一种负担。

## 11、分布式系统下会遇到哪些问题？

分布式系统会遇到的问题：

- 网络延迟和不可靠性
- 节点故障
- 多系统维护问题
- 一致性问题
- 性能问题
- 安全问题
- 通信问题
- 分布式应用问题（比如：分布式锁、分布式唯一 ID、分布式事务、分布式 Session 共享、分布式任务调度、分布式日志收集，等等。。）
- ...

## 12、什么是分布式定时任务？

分布式定时任务就是把单机定时任务分散到分布式的、多台机器中执行，同一个任务、不同的机器可以分别执行不同的数据，大大提升任务效率。

## 13、为什么需要分布式定时任务？

##### 分布式定时任务的优势：

1、多机部署，按一定的规则进行分片，提高任务效率；

2、出现故障可以自动转移到正常的机器执行，防止单点故障，提高系统可用性；

3、伸缩性好，可以灵活调整任务的机器数，并发能力强；

4、分布式定时任务框架都带有可视化页面，可以手动操作控制任务，查看历史任务等；

## 14、分布式定时任务有哪些解决方案？

##### 主流的分布式定时任务框架有：

1、**quartz** (主流开源调度框架，支持分布式)

2、**elastic-job**（当当网开源，目前已进入 Apache 开源项目）

3、**xxl-job**（许雪里个人开源的项目）

---

单机 quartz 用的多，分布式的后两个用的比较多。

## 15、什么是 Session 共享？

Session 是服务器用来保存用户操作的一系列会话信息，由 Web 容器进行管理，在单机系统中，Session 是保存在单机的，不存在共享。

在分布式系统中，系统是部署在不同的机器上的，即多个 Tomcat，**Session 共享就是 Session 复制（Tomcat 自带 Session 复制机制），在多个 Tomcat 中共享同一个会话。**

## 16、为什么需要 Session 共享？

分布式系统中，如果不进行 Session 共享，可能会出现请求落到不同的机器而出现要重复登录、会话失效的情况，

##### 比如，系统部署在 A/B/C 三台机器上：

1）用户首次登录访问的是 B 机器上的系统；

2）用户点击某个页面，如果使用的是随机负载均衡，请求可能到了 A 机器，A 机器没有 Session，所以需要重新登录.....

## 17、Session 共享有哪些实现方案？

一般来说解决 Session 共享有以下几种方案。

##### 1、session 复制

session 复制是早期的企业级的使用比较多的一种服务器集群 session 管理机制。应用服务器开启 web 容器的 session 复制功能，在集群中的几台服务器之间同步 session 对象，使得每台服务器上都保存所有的 session 信息，这样任何一台宕机都不会导致 session 的数据丢失，服务器使用 session 时，直接从本地获取。

这种方式在应用集群达到数干台的时候，就会出现瓶颈，每台都需要备份 session，出现内存不够用的情况。

> 此外，如果单台 Tomcat 会话数量过多，也可能会影响 Tomcat 的垃圾回收机制，导致垃圾回收时间变长,从而导致应用程序响应变慢。

##### 2、session 绑定

利用 hash 算法，比如 nginx 的 ip_hash,使得同一个 lp 的请求分发到同一台服务器上。

这种方式不符合对系统的高可用要求，因为一旦某台服务器宕机，那么该机器上的 session 也就不复存在了，用户请求切换到其他机器后么有 session，无法完成业务处理。

##### 3、利用 cookie 记录 session

session 记录在客户端，每次请求服务器的时候，将 session 放在请求中发送给服务器，服务器处理完请求后再将修改后的 session 响应给客户端。这里的客户端就是 cookie。

利用 cookie 记录 session 的也有缺点，比如受 cookie 大小的限制，能记录的信息有限；每次请求响应都需要传递 cookie，影响性能，如果用户关闭 cookie，访问就不正常。但是由于 cookie，影响性能，如果用户关闭 cookie，访问就不正常。但是由于 cookie 的简单易用，可用性高，支持应用服务器的线性伸缩，而大部分要记录的 session 信息比较小，因此事实上，许多网站或多或少的在使用 cookie 记录 session。

##### 4、session 服务器

session 服务器可以解决上面的所有的问题，利用独立部署的 session 服务器（集群）统一管理 session，服务器每次读写 session 时，都访问 session 服务器。

这种解决方案事实上是应用服务器的状态分离，分为无状态的应用服务器和有状态的 session 服务器，然后针对这两种服务器的不同特性分别设计架构。

对于有状态的 session 服务器，一种比较简单的方法是利用分布式缓存(memcached),数据库等。在这些产品的基础上进行包装，使其符合 session 的存储和访问要求。

如果业务场景对 session 管理有比较高的要求，比如利用 session 服务基层单点登录(sso),用户服务器等功能，需要开发专门的 session 服务管理平台。

## 18、为什么需要分布式唯一 ID？

##### 主要有以下几个原因：

1、分库分表后，每个表都按一定的规则进行 ID 自增就可能会重复；

2、不便于数据迁移，比如在 A 表的一条记录 ID 是 10，迁移到 B 表，B 表已经有了 10，这时候就会出现冲突；

## 19、分布式唯一 ID 应该具备哪些条件？

##### 一个分布式 ID 有下面几个要素：

1）**唯一性**：确保生成的 ID 是全网唯一的；

2）**有序递增性**：确保生成的 ID 是对于某个用户或者业务是按一定的数字有序递增的；

3）**高可用性**：确保任何时候都能正确的生成 ID；

4）**带时间**：ID 里面包含时间，一眼扫过去就知道哪天的交易；

## 20、分布式唯一 ID 有哪些实现方案？

##### 系统时间毫秒数

我们可以使用当前系统时间精确到毫秒数+业务属性+用户属性+随机数+..等参数组合形式来确保 ID 的唯一性，缺点是 ID 的有序性难以保证，要保证有序性就要依赖数据库或者其他中间存储媒介。

##### UUID

Java 自带的生成 UUID 的方式就能生成一串唯一随机 32 位长度数据，而且够我们用 N 亿年，保证唯一性肯定是不用说的了，但缺点是它不包含时间、业务数据可读性太差了，而且也不能 D 的有序递增。

这是一种简单的生成方式，简单，高效，但在一般业务系统中我还没见过有这种生成方式。

##### 数据库自增 ID

我们都知道为数据库主键设置自增序号，以一定的趋势自增，以保证主键 ID 的唯一性。

这个方案很简单，但最主要的问题在于依赖数据库本身，这就无形增加了对数据库的访问压力和依赖，一旦对单库进行分库分表或者数据迁移就尴尬了。

所以，这也不是合适的 ID 生成方法。

##### 批量生成 ID

一次按需批量生成多个 ID，每次生成都需要访问数据库，将数据库修改为最大的 ID 值，并在内存中记录当前值及最大值。这样就避免了每次生成 D 都要访问数据库并带来压力。

这种方案服务就是单点了，如果服务重启势必会造成 D 丢失不连续的情况，而且这种方式也不利于水平扩展。

##### 中间件

Redis 的所有命令操作都是单线程的，本身提供像 incr 这样的自增命令，所以能保证生成的 ID 肯定是唯一有序的。这种方式不依赖关系数据库，而且速度快。但系统要引 I 入 Redis 这一中间件，增加维护成本，而且编码和配置工作量比较大。即使已经有了 Redis 组件，但生成 ID 的高频率访问对单线程的 Redis 性能势必也会造成影响。

还可以利用像 Zookeeper 中的 znode 数据版本来生成序列号，及 MongoDB 的 Objectld 等，这种利用中间件的做法不是很推荐。

##### snowflake 算法

##### ![](/images/分布式/20.jpg)

如上图的所示，Twitter 的 snowflake 算法下面几部分组成：

- 41 位的时间序列，精确到毫秒，可以使用 69 年
- 10 位的机器标识，最多支持部署 1024 个节点
- 12 位的序列号，支持每个节点每毫秒产生 4096 个 ID 序号，最高位是符号位始终为 0。

这种方案性能好，在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。

而且这个项目在 2010 就停止维护了，但这个设计思路还是应用于其他各个 ID 生成器及变种。

##### UidGenerator

UidGenerator 是百度开源的分布式 lD 生成器，基于于 snowflake 算法的实现，看起来感觉还行。不过，国内开源的项目维护性真是担忧。

大家可以参考具体使用：

> https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md

##### Leaf

Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper 等中间件。

具体可以参考官网说明：

> https://tech.meituan.com/MT_Leaf.html

好了，就这么多了，不同的方案应用的场景和系统也是不同的。

## 21、为什么需要分布式锁？

##### 我们都知道，Java 提供的 synchronized/lock 锁只能作用在单个 JVM 中的单个应用中。

##### 来看这两个场景：

- 单个应用进行集群部署，负载均衡就可能把请求分配到不同的机器上；
- 多个不同的分布式应用，多个应用需要同时锁定同一个资源；

基于以上的情况，单机锁就会失效，就需要一种全局应用锁代替单机锁，即：**分布式锁**。

## 22、分布式锁应该具备哪些条件？

##### 分布式锁具备的条件（特点）：

1）在分布式系统中，一个方法（代码）在同一时间只能被一个线程执行；

2）获取锁与释放锁要具备高可用、高性能；

3）具备可重入特性，同一个线程可以反复获取锁；

4）具备锁失效机制，防止死锁、锁失效问题；

5）具备非阻塞锁特性，获取锁失败立即返回；

## 23、分布式锁都有哪些主流实现方案？

##### 分布式锁的几种主流实现方案：

1、关系数据库

2、Redis

3、Zookeeper

## 24、分布式锁选用哪种方案最合适？

##### 可以从以下 3 方面进行考虑：

**性能**：Redis >Zookeeper >数据库

**可靠性**：Zookeeper>Redis >数据库

**复杂性**：Zookeeper>Redis >数据库

---

所以：

1）简单的非高并发应用场景，也没有用到 Redis/ Zookeeper 等中间件，可以考虑用数据库锁；

2）高并发场景下，考虑使用 Redis/ Zookeeper 等中间件去实现；

---

没有 100%完美的解决方案，只有根据不同的应用场景选择最适合的方案才是王道。

## 25、关系数据库如何实现分布式锁？

关系数据库也能实现分布式锁，这个会影响数据库性能，高并发、数据库压力较大的场景不推荐使用。

##### 参考方案 1：

> 新增一张分布式锁数据库表，谁能成功插入数据（唯一锁 ID），就代表谁能获取锁，删除数据即代表释放锁。

这是一种利用关系数据库的唯一索引特性实现分布式锁，不可能出现重复数据。

##### 参考方案 2：

> 在对应数据库表中新增一个版本号字段，每次修改数据时和之前的版本号作对比，谁能修改成功（同时版本号+1），就代表谁能获取锁，修改失败的不断重试。

这是一种乐观锁，不断重试会影响数据库性能。

##### 参考方案 3：

> 使用 select ... from ... where ... for update

这是一种悲观锁，会锁住对应的索引行。

## 26、分布式锁 Redis&Zookeeper 怎么选？

纠结怎么选？看下表：

| 选项           | Redis | ZK  |
| -------------- | ----- | --- |
| 性能要求较高   | x     |     |
| 可靠性要求较高 |       | x   |
| 需要读写锁     |       | x   |
| 需要公平锁     |       | x   |
| 需要非公平锁   | x     |     |

如果允许偶然的锁失效情况，不影响系统正常使用，建议采用 Redis 锁，性能最好；

如果要求高可靠性，建议采用 Zookeeper 锁，它不依靠超时时间释放锁，可靠性比 Redis 要高；

## 27、Redis 如何实现分布式锁？

##### Redis 可以使用 set 命令：

> set (key, 1, 30, NX)

##### 应用的原理就是：

当 key 不存在时才进行保存，谁能成功保存数据，就代表谁能获取锁，获取失败则隔一段时间重试（单位：毫秒），删除 key 代表释放锁。

## 28、Redis 分布式锁有哪些问题？如何解决？

##### 1、死锁

setnx 不支持超时设置，如果 setnx 和 expire 命令组合使用设置超时，因为两个命令不是原子性操作，所以可能会出现死锁问题。

##### 解决方案：

Redis 2.6.12 开始可以使用 **set** 代替解决这个问题了。

##### 2、锁提前释放

比如，线路 A 获取到了锁，并默认持有锁 30 秒，如果 A 执行了 35 秒，锁在 30 秒的时候释放了，线程 B 又获取到了锁，这时候锁就出现问题了。

##### 解决方案：

1）获取锁之后开辟一个守护线程，在守护线程中每隔一段时间延长过期时间；

2）使用 Redisson 框架提供的看门狗特性，可以在锁失效前不断延长过期时间；

##### 3、主节点挂了

通过 Redis 加锁都是在某一个 Redis 集群节点上进行的，如果线程 A 在 Master 节点获取到锁后，在 Master 节点未完成数据同步的情况下发生了故障转移，此时其他线程依然可以获取到锁，这时候锁就出现问题了。

##### 解决方案：

可以通过 Redisson 框架提供的 RedLock 算法实现分布式锁来解决。

## 29、Zookeeper 如何实现分布式锁？

利用 Zookeeper 的临时有序节点来实现分布式锁。

##### ZooKeeper 实现分布式锁的步骤如下：

1）客户端连接 ZooKeeper

2）客户端在/lock 下创建一个临时有序子节点，如：/lock/lock-10000000001，以此类推

3）客户端获取/lock 下的子节点列表

4）判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是，则表示成功获得锁，否则监听自己前一位的子节点的删除消息，获得子节点变更通知后重复此步骤直至获得锁

5）执行业务流程代码 6）完成业务流程后，删除对应的子节点表示释放锁

## 30、ZK 分布式锁有哪些问题？如何解决？

##### 1、锁提前释放

如果获取到分布式锁的客户端发生了 GC 停顿，就可能导致 Zookeeper 检测不到客户端的心跳，Zookeeper 就认为客户端已经过期，并自动删除该临时节点所在的锁，如果另外一个客户端此时来获取锁，分布式锁就出现问题了。。

##### 解决方案：

可以通过 JVM 调优尽量避免 GC 停顿问题，但不能完全避免。

## 31、什么是分布式事务？

分布式事务是指涉及多个独立系统或服务的事务处理，在分布式系统中，不同的服务或应用程序可能被部署在不同的服务器上，这些服务需要协同工作来完成一个事务。**事务的每个操作步骤都位于不同的节点上，需要保证事务的 AICD 特性**。

在传统的单机环境下，事务处理通常由单一的事务管理器（Transaction Manager）来管理，保证事务的原子性、一致性、隔离性和持久性（ACID），但在分布式系统中，由于存在网络延迟、节点故障等问题，事务处理变得更加困难。

## 32、分布式事务的解决方案有哪些？

##### 一般有以下几种解决方案：

1、两阶段提交 (2PC)

2、三阶段提交(3PC)

3、补偿事务(TCC)

4、本地消息表 (最终一致性)

5、MQ 消息事务 (最终一致性)

6、最大努力通知 (最终一致性)

##### 7、Seata(支持 4 种事务模式)

## 33、哪些场景会产生分布式事务？

##### 1、跨数据库实例

比如有以下两个场景：

1）单体系统下，同一个系统使用了多个数据源连接不同的数据库；

2）分布式、微服务系统，各系统服务使用不同的数据库；

##### 2、跨 JVM 进程

比如有以下场景：

1）分布式、微服务系统，各系统服务使用不同的数据库（或者同一个数据库），都会产生分布式事务；

## 34、单体系统会产生分布式事务问题吗？

##### 答案：会。

如果一个单体系统使用了多个数据源连接不同的数据库，也会产生分布式事务问题。

## 35、如何解决单体系统中的分布式事务问题？

推荐使用开源的分布式事务解决方案：**Atomikos**。

在 Spring Boot 中可以使用 spring-boot-starter-jta-atomikos 进行集成：

![](/images/分布式/35.jpg)

## 36、只有一个库，会产生分布式事务问题吗？

##### 答案：会。

分布式、微服务系统，各系统服务使用不同的数据库，**或者是同一个数据库**，都会产生分布式事务，因为它们使用的是不同的数据库连接和事务管理器。

## 37、怎么理解本地消息表分布式事务？

本地消息表实现分布式事务，据说是 eBay 的解决方案，核心思想是新增一张消息表记录信息的发送状态，将分布式事务变成一种本地事务进行处理。

> 需要额外一张消息表，会影响高并发场景下的性能。

##### 举个下单改库存的例子：

1）用户下单后，订单系统新增一笔订单记录，同时在消息表添加一样消息，这两步在同一个事务中完成；

2）订单系统使用定时任务查询消息表中未处理的消息记录，然后发送到 MQ，发送失败就一直重试发送；

3）库存系统收到 MQ 消息后，修改对应的产品库存，为了避免重复消息发送，需要保证幂等性操作；

4）如果库存系统修改成功，调用订单系统接口，修改消息表中的记录状态为已完成，或者删除该记录；

5）如果库存系统修改失败，回到第 2 步，等待再次发送消息重试修改；

## 38、怎么理解 MQ 消息分布式事务？

MQ 消息事务的原理是将**两个事务通过消息中间件进行异步解耦**，需要依赖消息中间件的消息事务功能，比如支付消息事务的 RocketMQ。

> 这种方案不会用到本地消息表中的数据库表，适合高并发场景。

##### 举个下单改库存的例子：

1）用户下单后，订单系统新增一笔订单记录，同时发送一条 Prepare 消息到 MQ，这两步在同一个事务中完成；

2）如果订单系统事务执行成功，消息中间件将这条 Prepare 消息下发至库存系统；

3）如果订单系统事务执行失败，消息中间件将这条 Prepare 消息删除；

4）库存系统收到 MQ 消息后，修改对应的产品库存，如果修改失败，则不断重试；

具体可以参考 RocketMQ 实现分布式事务的案例。

## 39、怎么理解最大努力通知分布式事务？

最大努力通知的方案实现比较简单，**适用于最终一致性要求较低的业务**，比如：支付结果通知、受理结果通知等，一般用在内部平台和外部平台的处理。

##### 举个支付的例子：

1）某电商平台对接了某第三方支付平台，用户在电商平台下单后跳到支付平台进行支付；

2）支付平台支付成功/失败后，都需要将最终结果通知给电商平台，尽最大努力通知，比如：按一定的频率最多通知 5 次；

3）不管通知成功与否，达到最大 N 次通知之后都不再通知，电商平台可以主动调用支付平台提供的接口查询支付结果；

## 40、分布式事务模式都有哪些？怎么选？

##### 常用的分布式事务模式及对比：

| 分布式事务模式 | 介绍                                                                 |
| -------------- | -------------------------------------------------------------------- |
| AT 模式        | 无侵入的解决方案，适用于不想对业务改造的场景                         |
| TCC 模式       | 高性能的解决方案，适用于核心系统等对性能有很高要求的场景             |
| Saga 模式      | 长事务的解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统 |
| XA 模式        | 强一致性的解决方案，**性能低**，很少使用                             |

## 41、什么是 XA 分布式事务？

XA（eXtended Architecture）是由 X/Open 组织提出的分布式事务处理的规范、或称为协议，各大关系数据库厂家都提供了对 XA 的支持。

XA 协议采用**两阶段提交方式**来管理分布式事务，主要包含以下四部分：

- AP (应用程序)
- TM(事务管理器)
- RM(资源管理器，指数据库)
- CRM（通信资源管理器）

XA 提供了 TM 与 RM 之间通信的标准接口。

## 42、XA 和 TCC 分布式事务的区别？

XA 的两、三阶段提交（2PC、3PC）都是基于资源层面的，而 TCC 是基于应用层面、2PC 的一个变种。

## 43、什么是二阶段提交（2PC）分布式事务？

##### XA 定义了分布式事务规范，2PC、3PC 就是其具体的实现。

2PC 就是指分布式事务将事务分为两步进行提交，包含以下组件：

- 协调者：事务管理器(TM)

- 参与者：资源管理器(RM)

---

##### 第一阶段（投票阶段）：

协调者向参与者发送 prepare 信息，询问参与者是否可以提交事务；

参与者收到 prepare 信息后，进行本地事务的预处理，但还没有提交，最后返回处理结果；

##### 第二阶段（执行阶段）：

如果协调者收到了任意一个参与者的失败消息，则向每个参与者发送 rollback 消息进行事务回滚，否则，则向每个参与者发送提交 commit 消息进行事务提交；

![](/images/分布式/43.jpg)

## 44、二阶段提交（2PC）分布式事务的端？

##### 1、同步阻塞

事务执行过程中的所有参与者都是阻塞的，第三方参与者访问参与者占有的资源时会被阻塞，严重影响性能；

##### 2、单点故障

协调者一旦发生故障，参与者会被阻塞，尤其在执行阶段，所有参与者都处于锁定资源状态中，无法完成事务操作；

##### 3、数据不一致

提交阶段协调者向参与者发送 commit 信息，如果发生网络故障，可能会导致部分参与者不能收到 commit 信息无法提交事务而出现数据不一致现象；

## 45、什么是三阶段提交（3PC）分布式事务？

3PC 是对 2PC 的改进，在协调者和参与者中都引 I 入超时机制，并且把 2PC 中的的第一个阶段拆再分成了两步：询问，然后再锁资源，最后真正提交。

---

##### 1、canCommit(新增)

协调者询问参与者，是否具备执行事务的条件，参与者进行自身事务必要条件的检查；

##### 2、 preCommit

协调者通知参与者进行事务的预提交，并返回处理结果；

##### 3、doCommit

协调者根据参与者的处理结果，通知所有参与者是否进行事务提交或者回滚；

![](/images/分布式/45.jpg)

## 46、三阶段提交分布式事务有什么弊端？

##### 1、实现相比 2PC 较复杂

##### 2、需要更多的通讯次数

##### 3、依然存在数据不一致性问题

如协调者向所有参与者都发送了回滚命令，因为网络问题，有了超时机制，部分参与者没有收到从而进行了事务提交操作。

## 47、三阶段和二阶段提交分布式事务的区别？

1、3PC 分为**CanCommit（新增）**、**PreCommit**、**DoCommit**三个阶段完成事务提交；

2、3PC 同时在协调者和参与者中引 I 入了**超时机制**，如果超时，参与者就会默认提交，减少 2PC 的**同步阻塞**时间，但不能完全避免，也避免 2PC 中的**单点故障**问题；

## 48、什么是 JTA 分布式事务？

JTA 全称：**Java Transaction APl**，即：Java 事务 APl。

![](/images/分布式/48.jpg)

JTA 定义了事务管理器和分布式事务系统中涉及的各个组件(资源管理器、应用程序服务器、事务应用程序)之间的标准 Java 接口。

JTA 是基于 XA 实现的，也就是说资源管理器（RM）需要支持 XA。

## 49、JTA 分布式事务一般怎么实现？

##### JTA 只提供了接口，具体的实现有以下两种：

- 依赖于 J2EE 容器提供的 JTA 实现；
- 独立于 J2EE 容器的 JTA 实现，比如：Atomikos；

## 50、什么是 TCC 分布式事务？

TCC 是指：**Try、Confirm、Cancel**。

##### Try（资源预留）：

对业务进行数据检查和资源预留；

##### Confirm（提交）：

执行业务的提交操作；

##### Cancel（回滚）：

对业务的执行操作进行回滚；

TCC 的核心思想就是校验、资源锁定、补偿，根据（Try）操作的结果来确认是进行确认（Confirm）还是取消(cancel）操作。

## 51、TCC 分布式事务的应用场景？

TCC 比较适合的场景：

TCC 比较适合一些特别核心的业务场景，比如常见的：**支付、交易、转账**之类的资金相关操作场景，因为这些操作需要严格保证分布式事务强一致性，**要么全部成功，要么全部失败自动回滚，严格保证资金的正确性**。

比如：A 向 B 银行转账，A 扣钱，B 加钱，这两步肯定是要同时、尽快完成的。

## 52、TCC 分布式事务有什么弊端？

1、每个分布式事务的服务都必须实现 try、confirm、cancel 方法；

2、代码侵入性比较强，开发成本和维护成本都比较高；

2、为了满足事务的一致性的要求，try、confirm、cancel 方法必须实现等幂性操作；

## 53、常用的 TCC 分布式事务框架有哪些？

##### 常用的 TCC 分布式事务框架有：

- tcc-transaction
- ByteTCC
- spring-cloud-rest-tcc
- Himly
- ....

## 54、什么是 Saga 分布式事务？

Saga 是一种分布式事务模式，它通过将**一个大事务分解为多个小事务来实现分布式事务的执行**。在 Saga 模式中，每个小事务都可以独立执行，并且可以通过某种协调机制来保证整个事务的一致性。

Saga 模式中的每个小事务都被组织成一个有向无环图（DAG）结构，其中每个节点表示一个局部事务，每条边表示局部事务之间的依赖关系。当某个局部事务执行成功时，它会向 Saga 事务引擎发送通知，以便 Saga 事务引擎可以继续执行下一个局部事务。当局部事务执行失败时，它会向 Saga 事务引擎发送通知，并执行回滚操作。

Saga 模式的好处在于，它可以将大事务分解为多个小事务，从而降低了分布式事务的复杂性。此外，Saga 模式还支持异步执行，可以提高分布式事务的性能和可伸缩性。

## 55、Saga 分布式事务有哪些实现方式？

##### 最流行的两种 SAGE 事务实现方式是：

##### 1）事件编排

参与者通过交换事件沟通，进行分配决策和排序；

##### 2）命令协调

中央协调器负责集中处理事件的决策和业务逻辑顺序；

## 56、Saga 和 TCC 分布式事务的区别？

Saga 和 TCC 有些类似，都是补偿型事务，与 TCC 不同的是，**Saga 不需要 Try，而是直接进行 confirm,cancel 操作。**

## 57、GTS 是一种什么技术解决方案？

全局事务服务**（Global Transaction Service，简称 GTS）**是阿里云上的一款高性能、高可靠、接入简单的分布式事务中间件，用于解决分布式事务问题。

2019 年在 GTS 的基础上，阿里又开源了 Seata，GTS 和 Seata 定义的分布式事务框架是完全一致的，现在 GTS 已经实现与 Seata 的协议兼容，支持使用 Seata 的应用无缝迁移到云上。

![](/images/分布式/57.jpg)

## 58、Seata 是一种什么技术解决方案？

Seata 是一款开源的**分布式事务解决方案**，由阿里 2019 年开源，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。

![](/images/分布式/58.jpg)

## 59、Seata 都支持什么 RPC 框架？

##### Seata 目前已支持以下几种主流 RPC 框架：

- Dubbo
- Spring Cloud
- Sofa-RPC
- Motan
- gRPC

其他框架持续集成中，具体可以查看官网。

## 60、Seata 都支持哪几种分布式事务模式？

##### Seata 提供了以下 4 种事务模式：

- AT
- TCC
- Saga
- XA

Seata 致力于打造一站式的分布式解决方案。

## 61、说说 Seata 中的 AT 事务模式？

AT 是一种 Seata 事务模式，它是一种基于**数据库**的事务模式，它利用数据库的 **ACID** 属性来保证事务的一致性。

##### 前提

---

1）基于支持本地 ACID 事务的关系型数据库。

2）Java 应用，通过 JDBC 访问数据库。

##### 整体机制

---

它是两阶段提交协议的演变：

##### 1）一阶段

业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。

##### 2）二阶段：

- 提交异步化，非常快速地完成。
- 回滚通过一阶段的回滚日志进行反向补偿。

> 详细可以参考官方文档：
>
> https://seata.io/zh-cn/docs/dev/mode/at-mode.html

## 62、说说 Seata 中的 TCC 事务模式？

一个分布式的全局事务，整体是**两阶段提交**的模型，而全局事务是由若干分支事务组成的，分支事务要满足**两阶段提交**的模型要求，即需要每个分支事务都具备自己的：

- 一阶段 prepare 行为
- 二阶段 commit 或 rollback 行为

![](/images/分布式/62.jpg)

Seata 根据两阶段行为模式的不同，将分支事务划分为：

- AT 模式 - Automatic (Branch) Transaction Mode
- TCC 模式 - TCC (Branch) Transaction Mode

AT 模式是基于**支持本地 ACID 事务**和**关系型数据库**：

- 一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。
- 二阶段 commit 行为：马上成功结束，**自动**异步批量清理回滚日志。
- 二阶段 rollback 行为：通过回滚日志，**自动** 生成补偿操作，完成数据回滚。

TCC 模式则**不依赖于底层数据资源的事务支持**：

- 一阶段 prepare 行为：调用**自定义**的 prepare 逻辑。
- 二阶段 commit 行为：调用**自定义**的 commit 逻辑。
- 二阶段 rollback 行为：调用**自定义**的 rollback 逻辑。

所谓 TCC 模式，是指支持把 **自定义** 的分支事务纳入到全局事务的管理中。

## 63、说说 Seata 中的 Saga 事务模式？

Saga 模式是 Seata 提供的长事务解决方案，在 Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败时，则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。

![](/images/分布式/63.jpg)

##### 适用场景：

- 业务流程长、业务流程多
- 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口

##### 优势：

- 一阶段提交本地事务，无锁，高性能
- 事件驱动架构，参与者可异步执行，高吞吐
- 补偿服务易于实现

##### 缺点：

- 不保证隔离性

> ##### 详细可以参考官方文档：
>
> https://seata.io/zh-cn/docs/user/saga.html

## 64、说说 Seata 中的 XA 事务模式？

XA 事务模式是在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种事务模式。

##### 前提

---

1）支持 XA 事务的数据库。

2）Java 应用，通过 JDBC 访问数据库。

##### 整体机制

---

![](/images/分布式/64.jpg)

##### 1）执行阶段：

- 可回滚：业务 SQL 操作放在 XA 分支中进行，由资源对 XA 协议的支持来保证可回滚。
- 持久化：XA 分支完成后，执行 ×A prepare，同样，由资源对 XA 协议的支持来保证 持久化（即，之后任何意外都不会造成无法回滚的情况)

##### 2）完成阶段：

- 分支提交：执行 XA 分支的 commit
- 分支回滚：执行 XA 分支的 rollback

> ##### 详细可以参考官方文档：
>
> https://seata.io/zh-cn/docs/dev/mode/xa-mode.html

## 65、Seata 目前可以用于生产环境吗？

**Seata0.4.2+**版本就可以用于生产环境了。
