## 1、什么是设计模式？

设计模式（Design pattern）是大神们经过相当长的一段时间沉淀出来的一套代码编写和设计的最佳实践总结。

设计模式就像工人们盖房子一样，如果有一套成熟的建造模式，工人们只要按那个模式盖就好了，能保证整体质量和可靠性。如果每个工人都按自己的思路盖，那盖出来的房子必定是七扭八歪的。开发人员开发软件亦是如此!

## 2、为什么要使用设计模式？

设计模式是软件工程开发的基石，它可以帮助我们最大化的复用代码，减少代码冗余，使代码变得更有层次感，更容易被开发人员理解，也保证了代码的质量和可靠性。

## 3、总共有多少种设计模式？

1995 年，GoF（Gang ofFour，四人组/四人帮）合作出版了**《设计模式：可复用面向对象软件的基础》**书，书中共收录了 23 种设计模式，所以公认的权威的设计模式有 23 种。

![](/images/设计模式/3.jpg)

## 4、设计模式有哪些分类？

##### 设计模式一般分为三大类：

| 分类       | 设计模式                                                                                                                                                                                                                                                                                                                                             |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 创建型模式 | 工厂模式(Factory Pattern)、抽象工厂模式(Abstract Factory Pattern)、单例模式(Singleton Pattern)、建造者模式 (Builder Pattern)、原型模式(Prototype Pattern)                                                                                                                                                                                            |
| 结构型模式 | 代理模式 (Proxy Pattern)、适配器模式(Adapter Pattern)、桥接模式 (Bridge Pattern)、组合模式（Composite Pattern）、装饰器模式(Decorator Pattern)、外观模式 (Facade Pattern)、享元模式(Flyweight Pattern)                                                                                                                                               |
| 行为型模式 | 责任链模式 (Chain of Responsibility Pattern)、命令模式(Command Pattern)、解释器模式（Interpreter Pattern）、选代器模式(Iterator Pattern)、中介者模式 (Mediator Pattern)、备忘录模式 (Memento Pattern)、观察者模式(Observer Pattern)、状态模式 (State Pattern)、策略模式(Strategy Pattern)、模板模式 (Template Pattern)、访问者模式 (Visitor Pattern) |

## 5、你都用过哪些设计模式？

##### 最常用的几种要说上来：

1）工厂模式

2）单例模式

3）策略模式

4）代理模式

5）适配器模式

6）模板模式

7）观察者模式

8）装饰器模式

9）责任链模式

最好结合自己的业务运用这些设计模式，面试不慌。

## 6、JDK 中都用了哪些设计模式？

很多，比如以几下种：

1）Runtime、Calendar 等一些工具类中使用了单例模式

2）工厂模式，存在各种*Factory 工厂类中*

3）IO 库中使用了装饰器模式\*

4）IO 库中使用了适配器模式\*

5）JDK 提供了动态代理模式实现方式\*

6）JDK 提供了观察者模式实现方式\*

7）模板模式，存在各种 Abstract\*抽象类中

8）原型模式：Object#clone()

9）策略模式：如线程池中的各种拒绝策略

面试也不可能说全，举例说明就好。

## 7、Spring 框架用到了哪些设计模式？

##### 1、工厂模式

Spring 中的 BeanFactory 和 FactoryBean 就是工厂模式的实现。

##### 2、单例模式

Spring 容器中的 bean 默认就是单例模式的，保证一个类在 Spring 容器中仅有一个实例。

##### 3、观察者模式

Spring 中的事件监听机制就是观察者模式的实现。

##### 4、代理模式

Spring 中的 AOP 就是代理模式的实现，包括 JDK 和 CGLIB 动态代理。

##### 5、策略模式

Spring 在实例化对象的时候就用到了策略模式，策略接口：InstantiationStrategy。

##### 6、模板模式

Spring 中 JdbcTemplate、HibernateTemplate 等就用到模板模式，共用了一个模板。

##### 7、装饰器模式

Spring 中的 TransactionAwareCacheDecorator 类就是装饰器模式中的抽象装饰角色，主要用来处理事务缓存。

##### 8、适配器模式

Spring MVC 中的 DispatcherServlet 就使用了适配器模式，HandlerAdapter 为适配器接口，每一种 Controller 都有一种对应的适配器实现类。

## 8、什么是高内聚、低耦合？

##### 高内聚：

通俗点说就是，相关度比较高的部分尽可能的放在一起，尽量集中，不要分散。

比如：用户模块，可以把用户信息、用户收藏、用户足迹等相关的信息放到一个模块。

##### 低耦合：

通俗点说就是，不同模块之间的内容尽可能的少去依赖对方，减少相互依赖。

比如：用户下完订单后，需要向用户发邮件，不能由订单系统自主发送，而是要由邮件系统去发送，订单系统（或者其他业务系统）只需要发一个消息指令给邮件系统即可，这就是利用消息队列来进行解耦。

## 9、设计模式的六大原则是？

![](/images/设计模式/9.jpg)

## 10、你怎么理解单一职责原则？

##### 单一职责原则（SRP），The SingleResponsibilityPrinciple

> ##### 定义
>
> 一个类的修改只能有一个被修改的原因。

通俗地讲，就是一个类只能负责一个职责，修改一个类不能影响到别的功能，也就是说只有一个导致该类被修改的原因。我们写代码的都知道尽量要做到低耦合、高内聚的特性，单一职责原则正是保证了类与类之间的低耦合性。一个类如果承担过多的职责，就会有很多原因来导致这个类的被修改，就有很大可能性影响到别的功能。

单一职责原则看起来是一个非常简单的原则，但真正实践起来也并非易事，因为职责的联合在实际当中是经常遇到的事，也不能随便地去拆分类去适配单一职责模式，所以如何从这些联合的职责中合理地把职责分隔出来更合适的遵守单一职责原则要好好考虑。

##### 看看下面这这个接口是否符合单一职责原则呢？

![](/images/设计模式/10_1.jpg)

这是一个用户接口，提供四个方法：保存用户、获取用户、更新用户余额、获取用户余额，很显然用户个人信息与用户的账户余额是两回事，这样设计在一起耦合非常高，不利于扩展，也不符合单一职责原则。我们可以把它折分成两个，一个为用户信息接口，一个账户接口，如下

##### Userlnterface：

![](/images/设计模式/10_2.jpg)

##### Accountlnterface：

![](/images/设计模式/10_3.jpg)

这样分开来，是不是就符合了单一职责原则，类的复杂性和耦合性也降低了，即使用户接口或账户接口加减接口也不影响别的接口实现类。

##### 所以，单一职责原则可以总结为以下优势：

1、低耦合性，影响范围小。

2、类复杂度降低，职责分明，提高了可读性。

3、职责单一，利于维护。

## 11、你怎么理解开闭原则？

##### 开放封闭原则（OcP），TheOpenClosedPrinciple

> ##### 定义
>
> 一个软件的实体，包括类、方法、模块、应该对扩展开放，对修改关闭。

也就是说一个软件的实体应该通过扩展的方式来修改变化，而不是修改已有实体源代码。

开放封闭原则也是最基本需要遵守的原则，我们应该尽量保证系统的稳定性，我们在实现另外一个功能的时候不能修改之前已有的代码以免造成之前的功能出现 BUG，带来不必要的麻烦，所以开放封闭原则正是引导我们去设计一个稳定、方便扩展的系统。

##### 在实际应用中我们一般会有以下几种做法保证开放封闭原则：

1、抽象出一个接口或者抽象类，定义公共的方法，达到扩展的目的；

2、参数类型和引用类型使用接口或者抽象类，不能依赖实现类；

3、接口和抽象类不能修改，可以使用继承接口或者抽象父类的形式达到扩展的目的；

这些应用看起来也并不复杂，无非是合理地定义接口和抽象类，不同的业务功能采用不同的实现类达到扩展，像设计模式中的策略模式、模板方式模式等都是开放封闭的原则。

##### 总结一下，开放封闭原则具有以下几个优点：

1、方便扩展，提高了可维护性。

2、不影响已有功能，提高了系统稳定性和减少了重复测试。

3、扩展之前的逻辑，提高了代码复用性。

## 12、你怎么理解迪米特原则？

##### 迪米特原则（LoD），TheLawOfDemeter，也称为最少知识原则

> ##### 定义
>
> 一个对象应该对其他对象有最少的了解。

也就是说一个类耦合和调用一个类应该知道的最少，它只关心被耦合和调用的类的公共方法，而被耦合和调用的类如何复杂它并不关心。这在另一程度也说明类方法的最小权限性，不要随意定义 public 公开方法，你只公开你需要公开的。

#### 迪米特原则对类的低耦合度提出了以下几点要求：

##### 1、只和朋友类交流

类与类之间的交流无需知道内部结构，其内部与其他陌生类打交道我并不关心。

##### 2、朋友类之间的距离

一个类公开的属性和方法越多，其被修改的可能性也会更大，所以在设计一个的时候要权衡利弊，把范围定义在合理的范围内。

所以，迪米特很明显的优点是低耦合度，提高了系统的可维护性和可扩展性。但另一方面，为了满足这些特性而又不得不增加很多包装的类或方法，这在一定程度上也就提高了类的复杂性。

## 13、你怎么理解依赖倒置原则？

##### 依赖倒置原则（DiP），TheDependencyInversionPrinciple

> ##### 定义
>
> 1、高层模块不应该依赖低层模块，两都应该依赖于抽象。
>
> 2、抽象不依赖于具体细节。
>
> 3、具体细节应该依赖于抽象。

抽象就是指接口或者抽象类，细节是指实现接口或者抽象类的具体实现类。

也就是说模块之间的依赖通过接口或抽象发生的，两个实现细节之间不能直接发生依赖，接口不能依赖实现，实现应该依赖抽象。

我们在进行分布式系统开发时，比如常用的 dubbo 框架，各个系统的连接都是通过接口发生的，只要依赖对方的接口就行了，而不需要知道对方的实现，更不可能依赖对方的实现类，在实际开发中只要其他模块的人把接口定义好就行了，先按接口提供的参数开发，等真正实现类都开发完了再一起联调。其他两条就更好理解了，依赖都只能依赖其抽象，而不是具体实现类。

所以，采用依赖倒置原则最大的特点是减少了类与类之间的耦合性，良好的支持各个模块并行开发互不影响，也提高了系统的可读性、可维护性和可扩展性。

## 14、你怎么理解接口隔离原则？

##### 接口隔离原则（ISP），The Interface Segregation Principle

> ##### 定义
>
> 客户端不需要强迫依赖那些它们不需要的接口。

类与接口的依赖应该建议在最小的接口上，也就是说接口应该最小化，不能建立在一个庞大的接口之上，接口合理地按功能职能分成更细的几个单一的子接口。

如果一个接口定义并公布过多的方法，会导致所有的实现类必须要实现接口的方法，可能不同的业务场景不需要实现，所以接口隔离的原则就是只实现他们需要的接口。

像 Spring 中的 BeanFactory 定义了 bean 的各种最基本的操作的方法，而 BeanFactory 下面又有 3 个扩展的子接口，扩展的子接口拥有父接口的全部方法并且拥有自己的独特的方法，我们可以按需要直接实现父接口或者实现子接口，这样就达到了接口隔离的原则，使接口最小化。

![](/images/设计模式/14.jpg)

看起来，接口隔离原则是不怎么难实现的原则，只要具备一点业务抽象能力的都可以做到，接口隔离原则在一方面也满足了单一职责原则。

## 15、你怎么理解里氏替换原则？

##### 里氏替换原则（LSP），TheLiskovSubstitutionPrinciple

> ##### 定义
>
> 所有引用基类的地方必须能透明地引用其子类的对象，即子类可以拓展父类的功能，但不能修改父类已有的功能。

也就是说在父类出现的地方子类也可以出现，并且替换为子类也不会报错，引用者根本不需要知道引用的是父类还是子类，但是反过来就行不通了，子类出现的地方父类就不一定能出现并代替子类。

##### 里氏替换原则的特点：

1、子类可以拓展父类的功能，但不能修改父类已有的功能，如果修改了父类已有的功能，可能导致父类定义的功能在子类覆盖后不适用。

2、重载父类的方法时，子类的方法形参应该比父类更宽松。

3、实现父类的抽象方法时，子类的方法输出结果应该比父类更加严格。

4、子类可以有自己独特的私有方法，但是需要注意的是，如果子类不能完全实现父类的方法，或者父类的某-些方法在子类中已经不适用，这种情况则建议断开父子关系，使用组合等方式代替继承出现。

##### 里氏替换原则的优缺点：

1、合理得用类的继承关系，提高了代码的复用性，但也增强了类与类之间的耦合性。

2、通过建立抽象，运行过程中具体实现取代抽象，保证了系统的可拓展性。

3、只要继承父类就拥有父类的全部属性和方法，这样减少了代码重复创建量共享了代码但也约束了子类的行为，降低了系统灵活性。

我们平时开发中可能没考虑这么多，乱覆盖父类的方法，没有多少联系的继承等很多打破了里氏替换的原则，这样不顾后果的后果就是我们写的程序存在着潜在的漏洞，而且出问题的机率也会显著提升。

## 16、Java 设计原则中，为什么组合要优先于继承？

在《阿里巴巴 Java 开发手册》中有一条规定：

> 谨慎使用继承的方式进行扩展，优先使用组合的方式实现。

![](/images/设计模式/16.jpg)

1）因为 Java 只支持单继承，耦合性强，不利于扩展；

2）如果继承层次过深继承关系过于复杂，代码可读性和可维护性较差；

使用组合的方式，可以面向接口编程，也可以解决以上问题。

> 只是优先推荐组合，常并不说明继承不能用了，根据实际业务和需求来。

## 17、什么是工厂模式？

顾名思义，工厂模式中的“工厂”指的是创建对象的工厂，它提供了一种创建对象的最佳方式，也就是工厂模式。

工厂模式的好处是这些对象不需要暴露自身的创建过程，统一由工厂模式进行创建和提供，隐藏了创建细节，避免了错误的创建对象的形式，也减少了重复创建冗余代码。

## 18、工厂模式分为哪几类？

##### 一般情况下，工厂模式可以细分为三类：

- 简单工厂模式
- 工厂方法模式

不过在设计模式权威书籍**《设计模式：可复用面向对象软件的基础》**一书中，简单工厂模式只是工厂方法模式的一个特例而已。

所以，从权威的角度说，工厂模式只分为：**工厂模式**和**抽象工厂模式**两大类。

## 19、工厂模式中简单工厂和工厂方法的区别？

##### 简单工厂模式与工厂方法模式区别：

| 简单工厂模式                           | 工厂方法模式                                 |
| -------------------------------------- | -------------------------------------------- |
| 面向**多个产品**                       | 面向**1 个产品**                             |
| 工厂类可以创建**多个**具体产品类的实例 | 工厂类可以只能创建 **1 个** 具体产品类的实例 |

## 20、工厂模式中工厂方法和抽象工厂的区别？

##### 工厂方法模式与抽象工厂模式区别：

| 工厂方法模式                          | 抽象工厂模式                           |
| ------------------------------------- | -------------------------------------- |
| 面向**1 个产品**                      | 面向**多个产品**                       |
| 只有**1**个抽象产品类                 | 可以有**多个**抽象产品类               |
| 工厂类只能创建**1**个具体产品类的实例 | 工厂类可以创建**多个**具体产品类的实例 |

## 21、编程实现简单工厂模式 (真实应用案例)

比如 XX 公司是做支付的，公司有几大类的客户：电商商户、银行客户、代理商...

创建这些客户的时候我们可以用简单工厂模式来实现看看。

新建客户基类：

可以把所有客户公共的信息放到一个客户基类中，比如：客户名、客户类型等，所有的客户继承这个抽象基类。

```java
/**
* 客户
*/
@Data
@NoArgsConstructor
@AllArgsConstructor
public abstract class Customer {
    /**
    * 客户名称
    */
    private String name;

    /**
    * 客户类型
    */
    private String type;
}
```

##### 新建电商商户类：

```java
/**
* 商户
*/
@Data
@ToString(callsuper = true)
public class Merchant extends Customer {
    /**
    * 合同类型
    */
     private int contractType;

    /**
    *结算周期 (天)
    */
    private int settmentDays;

    public Merchant(String name, String type) {
        super(name, type);
    }
}

```

##### 新建银行客户类：

```java
/**
* 银行客户
*/
@Data
@ToString(callsuper = true)
public class BankPartner extends Customer {
    /**
    * 银行编码
    */
    private String code;

    /**
    * 银行地址
    */
     private String address;

    public BankPartner(String name, String type) {
        super(name, type);
    }
}
```

##### 新建代理商类：

```java
/**
* 代理商
*/
@Data
@ToString(callsuper = true)
public class Agent extends Customer {
    /**
    * 代理周期
    */
    private int period;

    /**
    * 代理产品
    */
    private int[] products;

    public Agent(String name, String type) {
        super(name, type);
    }
}
```

##### 新增简单工厂类：

新建一个简单工厂，提供一个公共静态方法，根据不同的客户类型创建不同的客户。

```java
/**
*
*/
public class CustomerFactory {
    private static Merchant createMerchant(String type, String name) {
        return new Merchant(type, name);
    }

    private static BankPartner createBankPartner(String type, String name) {
        return new BankPartner(type, name);
    }

    private static Agent createAgent(String type, String name) {
        return new Agent(type, name);
    }

    public static Customer create(String type, String name) {
        if ("M".equals(type)) {
            return createMerchant(type, name);
        } else if ("B".equals(type)) {
            return createBankPartner(type, name);
        } else if ("A".equals(type)) {
            return createAgent(type, name);
        }
        return null;
    }
}
```

##### 新建测试类：

```java
public class Test {
    public static void main(String[] args) {
        Customer merchant = CustomerFactory.create("M", "Java技术栈商户");
        System.out.println(merchant);

        Customer bankPartner = CustomerFactory.create("B", "Java技术栈银行客户");
        System.out.println(bankPartner);

        Customer agent = CustomerFactory.create("A", "Java技术栈代理商");
        System.out.println(agent);
    }
}
```

##### 输出结果：

![](/images/设计模式/21.jpg)

可以看出简单工厂的使用很简单，就是耦合性太高了。

第一，对象和基类之间是基于继承的。

第二，工厂类耦合了不同对象的创建，如果对象类型不是固定或者经常变动的，就要频繁修改工厂类，比如我现在要再加一种客户，就必须要改动工厂类，不符开闭原则。

所以，简单工厂只适用于固定类型对象的创建。

## 22、编程实现工厂方式模式(真实应用案例)

工厂方法就是为某类产品提供一个工厂接口，然后为每个产品提供一个工厂实现类。

废话少说，我们将简单工厂的示例用工厂方法再改造一下。

##### 新建工厂方法接口：

```java
/**
* 工厂方法客户接口
*/
public interface CustomerFactory {
    Customer create(String type, String name);
}
```

##### 新建商户工厂实现类：

```java
/**
* 商户工厂
*/
public class MerchantFactory implements CustomerFactory {

    @Override
    public Customer create(String type, String name) {
        return new Merchant(type, name);
    }
}
```

##### 新建银行客户工厂实现类：

```java
/**
* 银行客户工厂
*/
public class BankPartnerFactory implements CustomerFactory {

    @override
    public Customer create(String type, String name) {
        return new BankPartner(type, name);
    }
}
```

##### 新建代理商工厂实现类：

```java
/**
* 代理商工厂
*/
public class AgentFactory implements CustomerFactory {
    @Override
    public Customer create(String type, String name) {
        return new Agent(type, name);
    }
}
```

##### 新建测试类：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("------工厂模式-工厂方法-----");
        CustomerFactory merchantFactory = new MerchantFactory();
        Customer merchant = merchantFactory.create("M", "Java技术栈商户");
        System.out.println(merchant);
        CustomerFactory bankPartnerFactory = new BankPartnerFactory();
        Customer bankPartner = bankPartnerFactory.create("B", "Java技术栈银行客户");
        System.out.println(bankPartner);
        CustomerFactory agentFactoryy = new AgentFactory();
        Customer agent = agentFactory.create("A"，"Java技术栈代理商");
        System.out.println(agent);
    }
}
```

##### 输出结果：

![](/images/设计模式/22.jpg)

可以看出，工厂方法也是挺简单易用的，耦合性问题也解决了，每增加一个产品就新增一个产品工厂实现类就行了，扩展性非常好。

但也有一个问题，如果产品非常多，那势必会造成工厂实现类泛滥，另外一种可怕的场景就是，如果涉及到工厂接口变更，工厂实现类的维护简直就是一种恶梦。

## 23、编程实现抽象工厂模式 (真实应用案例)

工厂方法中一个工厂只能创建一个对象，如果现在每次创建客户的时候都需要同时创建一份客户扩展资料,那就可以考虑使用抽象工厂。

##### 新建客户扩展基类：

可以把所有客户公共的扩展信息放到一个客户扩展基类中，比如：客户曾用名、客户扩展说明等，所有的客户继承这个扩展抽象基类。

```java
/**
* 客户扩展
*/
@Data
@NoArgsConstructor
public abstract class CustomerExt {
  /**
  * 客户曾用名
  */
  private String formerName;

    /**
    * 客户扩展说明
    */
    private String note;

}
```

##### 新建商户扩展类：

```java
/**
* 商户
*/
@Data
@ToString(callsuper = true)
public class MerchantExt extends CustomerExt {
    /**
    * 介绍人
    */
    private int introduceName;

    /**
    * 介绍人电话
    */
    private String introduceTel;
}
```

##### 新建银行客户扩展类：

```java
/**
* 银行客户扩展
*/
@Data
@ToString(callsuper = true)
public class BankPartnerExt extends CustomerExt {
  /**
  * 分行个数
  */
    private int branchcount;

    /**
    * ATM个数
    */
     private int atmCount;
}
```

##### 新建代理商扩展类：

```java
/**
* 商户
*/
@Data
@ToString(callsuper = true)
public class AgentExt extends CustomerExt {

    /**
    * 来源
    */
    private String source;

    /**
    * 资质
    */
    private String certification;
}
```

##### 新建抽象工厂接口：

```java
/**
* 抽象工厂客户接口
*/
public interface CustomerFactory {

    Customer createCustomer(String type, String name);

  CustomerExt createCustomerExt();
}
```

##### 新建商户工厂实现类：

```java
/**
* 商户工厂
*/
public class MerchantFactory implements CustomerFactory {

    @Override
    public Customer createCustomer(String type, String name) {
        return new Merchant(type, name);
    }

    @override14public CustomerExt createCustomerExt() {
        return new MerchantExt();
    }
}
```

##### 新建银行客户工厂实现类：

```java
/**
* 银行客户工厂
*/
public class BankPartnerFactory implements CustomerFactory {

    @override
    public Customer createCustomer(String type, String name) {
        return new BankPartner(type, name);
    }

    @Override
    public CustomerExt createCustomerExt() {
        return new BankPartnerExt();
    }
}
```

##### 新建代理商工厂实现类：

```java
/**
* 代理商工厂
*/
public class AgentFactory implements CustomerFactory {

    @Override
    public Customer createcustomer(String type, String name) {
        return new Agent(type, name);
    }

    @Override
    public CustomerExt createCustomerExt() {
        return new AgentExt();
    }
}
```

##### 新建测试类：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("------工厂模式-抽象工厂------");

        CustomerFactory merchantFactory = new MerchantFactory();
        Customer merchant = merchantFactory.createCustomer("M", "Java技术栈商户");
        CustomerExt merchantExt = merchantFactory.createCustomerExt();
        System.out.println(merchant):
        System.out.println(merchantExt);

        CustomerFactory bankPartnerFactory = new BankPartnerFactory();
        Customer bankPartner = bankPartnerFactory.createCustomer("B"，"Java技术栈银行客户");
        CustomerExt bankPartnerExt = bankPartnerFactory.createCustomerExt();
        System.out.println(bankPartner);
        System.out.println(bankPartnerExt);

        CustomerFactory agentFactory = new AgentFactory();
        Customer agent = agentFactory.createCustomer("A", "Java技术栈代理商");
        CustomerExt agentExt = agentFactory.createCustomerExt();
        System.out.println(agent);
        System.out.println(agentExt);
    }
}
```

##### 输出结果：

![](/images/设计模式/23.jpg)

可以看出，抽象工厂和工厂方法十分类似，只不过工厂方法里面只生产一个对象，而抽象工厂可以生产多个对象。

抽象工厂缺点也很明显，第一就是和工厂方法一样工厂类非常多，第二就是扩展非常麻烦，比如我现在要为每个客户类型再加一份客户特殊资料，那所有涉及到抽象工厂的工厂类都要改，是不是要疯了。生

## 24、什么是单例模式？

**单例模式（Singleton Pattern）**：即一个 JVM 内存中只能存在一个类的对象实例，所以叫做：单例。

## 25、单例模式有哪几种实现方式？

#### 分类

---

##### 1、懒汉式

使用的时候才创建实例

##### 2、饿汉式

类加载的时候就创建实例

##### 懒汉式

---

##### 1）示例 1

![](/images/设计模式/25_1.jpg)

线程不安全，不可用。

##### 2）示例 2

![](/images/设计模式/25_2.jpg)

同步方法，线程安全，效率低，不推荐。

##### 3）示例 3

![](/images/设计模式/25_3.jpg)

线程不安全，会产生多个实例，不可用。

##### 饿汉式

---

无线程安全问题，不能延迟加载，影响系统性能。

##### 4）示例 1

![](/images/设计模式/25_4.jpg)

##### 5）示例 2

![](/images/设计模式/25_5.jpg)

##### 6）双重校验锁

![](/images/设计模式/25_6.jpg)

双重校验锁，线程安全，推荐使用。

##### 7）静态内部类

![](/images/设计模式/25_7.jpg)

静态内部类，线程安全，主动调用时才实例化，延迟加载效率高，推荐使用。

##### 8）枚举

![](/images/设计模式/25_8.jpg)

枚举类型，无线程安全问题，避免反序列华创建新的实例，很少使用。

## 26、单例模式有哪些应用场景？

##### 单例模式常用的应用场景：

1、工具类型的类，如下面是单例模式在 JDK 的应用：

![](/images/设计模式/26.jpg)

2、创建频繁或又耗时耗资源且又经常用到的对象，如 Spring 中的 bean 就是默认单例的；

## 27、如何保证一个类一定是单例？

##### 通过一下措施解决：

1）把类构造器设置为私有，类的实例化在本类中进行；

2）在方法中创建类实例时，需要使用同步锁；

3）如果类可序列化，反序列化返回单个实例：

![](/images/设计模式/27.jpg)

## 28、SpringBean 是什么类型单例？

Spring 容器中的实例默认是 **饿汉式** 单例类型的，即容器启动时就实例化 bean 到容器中。

当然也可以设置懒汉式，设置 bean 的 lazy =“true”为延迟实例化，用到时再实例化。

## 29、什么是代理模式？

##### 举个例子：

比如，你想向某个美女表白，你不好意思自己去，但是可以通过中介、或者一个代理人帮你去完成这件事件，你只需要提供礼物，代理人可以帮你送礼物，还可以在送礼物之前、之后帮你再做一点其他事情，比如送礼物之前先表白，送完礼物后再送她回家。

代理模式亦是如此，代理模式即是一个类代另外一个类完成这个类的功能，并且可以在这个类的前、后再插入一段逻辑，比如在执行前打印日志，在方法执行完统计耗时等。

##### 代理模式类结构图：

![](/images/设计模式/29.jpg)

## 30、代理模式分为哪两类？

根据代理类创建时期，代理模式可以分为：**静态代理**和**动态代理**。

## 31、什么叫静态代理？

静态代理其实在程序编译期间就已经创建代理类了，即需要通过 java 文件手动编译到.class 文件中。

代理类和实现类都实现相同的接口，然后通过代理类来调用实现类的方法。

## 32、编程实现静态代理(真实应用案例）

##### 举例说明：

如我们想保存用户信息之前打印用户信息，或者保存用户信息之后把这些信息缓存下来，即在运行方法前后插入执行一个别的操作，下面是一个简单的示例。

##### 用户接口：

```java
public interface UserInterface {
    boolean saveUser(User user);
}
```

##### 用户接口实现：

```java
public class UserInterfaceImpl implements UserInterface {
    @Overrid
    epublic boolean saveUser(User user) {
        System.out.println("保存用户：" + user.getName());
        return true;
    }
}
```

##### 静态代理类：

```java
public class StaticProxy implements UserInterface {

    private final UserInterface userInterface;
    public StaticProxy(UserInterface userInterface) {
        this.userInterface = userInterface;
    }

    @Override
    public boolean saveUser(User user) {
        System.out.println("静态代理-开始保存用户");
        boolean result = userInterface.saveUser(user);
        System.out.println("静态代理-保存用户结果："+result);
        System.out.println();
        return result;
    }
}
```

##### 测试类：

```java
public class ProxyTest {
    // 测试静态代理
    @Test public void teststaticProxy() {
        User user = new User();
        user.setName("tom");
        new StaticProxy(new UserInterfaceImpl()).saveUser(user);
    }
}
```

##### 输出结果：

> 静态代理-开始保存用户
>
> 保存用户：tom
>
> 静态代理-保存用户结果：true

通过代码实战的方法学习设计模式，是不是觉得静态代理很简单了？

## 33、什么叫动态代理？

在程序运行期才创建代理对象的方式叫做动态代理，而不是通过在 Java 源文件中手动创建代理类。

在生成代理对象期间，目标对象始终不变，代理对象只是目标对象类的子类对象重写后的增强方法。

## 34、静态代理和动态代理的区别？

**静态代理**：在程序编译期间，就已经创建代理类了，即需要通过 java 文件手动编译到.class 文件中；

**动态代理**：程序编译期间（.class 文件中）没有创建任何代理类，而是在程序运行期间，利用反射机制动态创建代理类；

动态代理与静态代理最主要的区别在于，静态代理是编译期间就确定好的代理关系，而动态代理是运行期间由 JVM 通过反射等技术生成的代理对象，不存在于.class 文件中。

## 35、实现动态代理有哪几种方式？

##### 有两种方式实现：

1）JDK 中的动态代理，只能基于接口实现；

2）CGLib 中的动态代理，可以基于接口和类实现；

## 36、JDK 是怎么实现动态代理的？

在 JDK 中提供了动态代理的创建方式，但是只能通过接口进行代理。

##### JDK 动态代理结构图：

![](/images/设计模式/36.jpg)

Proxy 类主要用来获取动态代理对象，InvocationHandler 接口用来实现代理逻辑。

## 37、编程：用 JDK 实现动态代理（真实应用案例）

把静态代理中的示例用动态代理改编下：

##### 用户接口：

```java
public interface UserInterface {
    boolean saveUser(User user);
}
```

##### 用户接口实现：

```java
public class UserInterfaceImpl implements UserInterface {
    @Override
    public boolean saveUser(User user) {
        System.out.println("保存用户:"+ user.getName());
        return true;
    }
}
```

##### JDK 动态代理类：

```java
public class JdkDynamicProxy {
    private static final InvocationHandler USER_HANDLE = (proxy, method, args) -> {
        System.out.println("JDk接口动态代理-开始保存用户：");
        Object result = method.invoke(new UserInterfaceImpl(), args);
        System.out.println("JDk接口动态代理-保存用户结果：" + result);
        System.out.println();
        return result;
    };

    public static UserInterface getUserProxy() {
        return (UserInterface) Proxy.newProxyInstance(JdkDynamicProxy.class.getClassLoader(), new Class[]{UserInterface.class}, USER_HANDLE);
    }
}
```

##### 测试类：

```java
public class ProxyTest {

    @Test
    public void testJDKProxy() {
        User user = new User();
        user.setName("tom");
        JdkDynamicProxy.getUserProxy() .saveUser(user);
    }
}
```

##### 结果输出：

> JDK 接口动态代理-开始保存用户：
>
> 保存用户：tom
>
> JDK 接口动态代理-保存用户结果：true

## 38、为什么 JDK 动态代理必须基于接口？

1）生成的代理类已经继承了 java.lang.reflect.Proxy 类，因为 Java 是单继承，所以代理目标只能是接口；

![](/images/设计模式/38.jpg)

2）从设计的理念讲，接口优于继承，符合基于接口编码的规范毕竟单继承是 Java 的瓶颈；

## 39、什么是 CGLib？

CGLib(Code Generation Library)是一个强大的字节码处理框架，它可以在程序运行期扩展 Java 类与实现 Java 接口。

CGLib 底层使用了字节码处理框架 ASM 来转换字节码并生成新的代理类。

CGLib 比 Java 的 java.lang.reflect.Proxy 类更强的在于，它不仅可以代理接口类的方法，甚至还可以代理普通类的方法。

## 40、编程：用 CGLib 实现动态代理（真实应用案例)

把静态代理中的示例用动态代理改编下：

##### 用户接口：

```java
public interface UserInterface {
    boolean saveUser(User user);
}
```

##### 用户接口实现：

```java
 public class UserInterfaceImpl implements UserInterface {

  @Override
    public boolean saveUser(User user) {
      System.out.println("保存用户：" + user.getName());
        return true;
    }
}
```

##### Cglib 基于接口动态代理类实现：

```java
import org.springframework.cglib.proxy.InvocationHandler;
import org.springframework.cglib.proxy.Proxy;

public class CglibDynamicProxy {

    /**
    * 基于接口实现动态代理
    */
    private static final InvocationHandler INTERFACE_USER_HANDLE = (proxy, method, args) -> {
        System.out.println("Cglib接口动态代理-开始保存用户");
        Object result = method.invoke(new UserInterfaceImpl(), args);
        System.out.println("cglib接口动态代理-保存用户结果：" + result);
        System.out.println();
        return result;
    }

    public static UserInterface getUserProxy() {
        return (UserInterface) Proxy.newProxyInstance(CglibDynamicProxy.class.getclassLoader(), new Class[]{UserInterface.class}, INTERFACE_USER_HANDLE);
    }
}
```

##### Cglib 基于类动态代理类实现：

```java
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;

public class CglibDynamicProxy {

    /**
    * CGLIB基于类实现动态代理
    */
    private static final MethodInterceptor CLASS_USER_HANDLE = (obj, method, args, proxy) -> {
        System.out.println("cglib类动态代理-开始保存用户");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("cglib类动态代理-保存用户结果：" + result);
        System.out.println();
        return result;
    }

    public static Object getUserProxy(object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setsuperclass(target.getclass());
        enhancer.setCallback(CLASS_USER_HANDLE);
        return enhancer.create();
    }
}
```

##### 测试类：

```java
public class ProxyTest {
    /**
    * 测试CGLIB基于接口的动态代理
    */
    @Test
    public void testCglibInterfaceProxy() {
        User user = new User();
        user.setName("tom");
        CglibDynamicProxy.getUserProxy().saveUser(user);
    }

    /**
    * 测试CGLIB基于类的动态代理
    */
    @Test
    public void testcglibclassProxy() {
        User user = new User();
        user.setName("tom");
        UserInterfaceImpl userImpl = (UserInterfaceImpl) CglibDynamicProxy.getUserProxy(new UserInterfaceImpl());
        userImpl.saveUser(user);
    }
}
```

##### 输出结果：

> Cglib 接口动态代理-开始保存用户
>
> 保存用户：tom
>
> Cglib 接口动态代理-保存用户结果：true
>
> Cglib 类动态代理-开始保存用户
>
> 保存用户：tom
>
> Cglib 类动态代理-保存用户结果： true

## 41、什么是观察者模式？

**观察者模式（ObserverPattern）**定义了对象间的一种一对多的依赖关系，这样只要一个对象的状态发生改变，其依赖的所有相关对象都会得到通知并自动更新。

##### 观察者模式类结构图：

![](/images/设计模式/41.jpg)

在观察者模式中，发生改变的对象叫做 **观察目标**，而被通知更新的对象称为 **观察者**，一个观察目标对应多个观察者，观察者一般是一个列表集合，可以根据需要动态增加和删除，易于扩展。

## 42、观察者模式有什么优缺点？

##### 观察者模式优点：

1、观察目标和观察者之间是抽象松耦合关系，降低了两者之间的耦合关系；

2、触发机制,代码更优雅；

##### 观察者模式缺点：

1、如果观察者对象太多的话，有可能会造成内存泄露；

2、从性能上面考虑，所有观察者的更新都是在一个循环中排队进行的，要将所有的观察者都通知到会花费很多时间，所以观察者的更新操作可以考虑做成线程异步（或者可以使用线程池）的方式，以提升整体效率；

3、如果观察者和观察目标之间存在循环调用，可能导致系统直接崩溃；

## 43、观察者模式和发布订阅模式的区别？

观察者模式很多地方也叫 **发布－订阅**模式（Publish/Subscribe），其实也可以这么理解，不过两者之间还是略有不同。

观察者模式中的观察者是直接绑定观察目标，观察目标要维护一套观察者列表，两者是有一个基于接口的组合依赖关系的，所以说观察者模式虽然是松耦合的，但并不是完全解耦的。

而 **发布－订阅**模式中的发布者和订阅者两者并没有任何联系，发布者通过中间方发布一个主题（Topic），订阅者通过中间方（调度中心）订阅一个主题（Topic），发布者状态的变更也并不会直接通知订阅者，而要通过中间方进行通知，或者订阅者自行从中间方拉取，所以说 **发布－订阅**模式是完全解耦的。

##### 一图搞懂它们的关系：

![](/images/设计模式/43.jpg)

从图片看两者是有差别的，统一都叫观察者模式，也没毛病。

## 44、JDK 是怎么实现观察者模式的？

因观察者模式应用比较广泛，所以 JDK 工具包从 1.0 版本里面自带了观察者模式模板套装，我们根据其模板很方便就能实现观察者模式，不需要再重复造轮子了。

##### 观察者目标类：

> java.util.Observable

里面两个最重要的变量：

- **changed**：观察目标状态是否变更，默认为：false；
- **obs**：观察者列表（observers），一个线程安全的列表集合：Vector，默认为空集合；

里面的重要的方法都是和观察目标状态和观察者相关的，一看就清楚，这里就不介绍了。

##### 观察者接口：

> java.util.Observer

```java
public interface Observer {
    void update(Observable o, Object arg);
}
```

观察者接口只有一个 update 方法，用来通知观察者自己更新。

## 45、编程实现观察者模式（真实应用案例）

现在就来实现一个简单的观察者模式的应用场景，模拟公众号文章推送，观察目标是 R 哥我，观察者是你们大家，我在公众号 Java 技术栈推一篇文章，你们都能接收到更新通知并能阅读。

##### 新增观察目标类：

```java
import lombok.Getter;
import java.util.Observable;

@Getter
public class JavaStackobservable extends Observable {

    private String article;

    public void publish(String article){
        // 发表文章
        this.article = article;

        // 改变状态
        this.setchanged();

        // 通知所有观察者
        this.notifyobservers();
    }
}
```

观察目标的逻辑是先发表文章，再改变观察目标的状态，再通知所有观察者。

我们来重点看 notifyObservers 方法的源码：

![](/images/设计模式/45_1.jpg)

先获取同步锁，判断状态是否更新，如已更新则清空观察目标状态，然后再使用 for 循环遍历所有观察者，一一调用观察者的更新方法通知观察者更新。

##### 新增观察者类：

```java
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

import java.util.Observable;
import java.util.Observer;

@RequiredArgsConstructor
public class Readerobserver implements Observer {

    @NonNull
    private String name;

    private String article;

    @Override
    public void update(Observable o, Object arg) {
       // 更新文章
       updateArticle(o);
    }

    private void updateArticle(observable o) {
        JavaStackobservable javaStackobservable = (JavaStackobservable) 0;
        this.article = javaStackobservable.getArticle();
        System.out.printf("我是读者：%s，文章已更新为：%s\n"，this.name，this.article);
    }
}
```

观察者的逻辑是获取到观察者目标实例对象，然后再用观察目标对象的文章信息更新为自己的文章信息，最后输出某某某的文章已更新。

观察者只要实现 Observer 这个接口的 update 方法即可，用于观察目标进行调用通知。

##### 观察目标和观察者类结构图如下：

![](/images/设计模式/45_2.jpg)

##### 新增测试类：

```java
public class ObserverTest {
    public static void main(String[] args) {
        //创建一个观察目标
        JavaStackobservable javaStackobservable = new Javastackobservable();
        //添加观察者
        javaStackobservable.addobserver(new Readerobserver("小明"));
        javaStackobservable.addobserver(new Readerobserver("小张"));
        javaStackobservable.addobserver(new ReaderObserver("小爱"));
        //发表文章
        javaStackobservable.publish("什么是观察者模式？");
    }
}
```

观察目标、观察者的创建并没有先后顺序要求，重点是发表文章通知观察者之前，观察目标要添加观察者列表这一步不能少。

输出结果：

![](/images/设计模式/45_3.jpg)

通过这个简单的文章推送实践，大家应该对观察者模式有一个基本的认知了，在实际工作当中也可以有很多场景拿去用，就一对多的依赖关系都可以考虑使用观察者模式。

##### 总结

---

不容易啊，陆陆续续又肝了大半天，你学会观察者模式了吗？

观察者模式的优点是为了给观察目标和观察者解耦，而缺点也很明显，从上面的例子也可以看出，如果观察者对象太多的话，有可能会造成内存泄露。

另外，从性能上面考虑，所有观察者的更新都是在一个循环中排队进行的，所以观察者的更新操作可以考虑做成线程异步（或者可以使用线程池）的方式，以提升整体效率。

本节教程所有实战源码已上传到这个仓库：

> https://github.com/javastacks/javastack

## 46、Spring 如何实现观察者模式？

实现原理可以参考 Spring 面试题中的事件机制：Spring 中的事件监听机制是什么？

下面是具体实战。

##### 新增观察者目标类

```java
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class JavaStackEvent extends ApplicationEvent {
    public JavaStackEvent(object source) {
        super(source);
    }
}
```

实现 Spring 框架中的 ApplicationEvent 应用程序事件接口，相当于是一个观察者目标。

##### 新增观察者类

```java
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationListener;
import org.springframework.scheduling.annotation.Async;

@RequiredArgsConstructor
public class Readerlistener implements Applicationlistener<JavaStackEvent> {

    @NonNull
    private String name;

    private String article;

    @Async
    @Override
    public void onApplicationEvent(JavaStackEvent event) {
        //更新文章
        updateArticle(event);
    }

    private void updateArticle(JavaStackEvent event) {
        this.article = (String) event.getSource();
        System.out.printf("我是读者：%s，文章已更新为：%s\n"，this.name，this.article);
    }
}
```

实现 Spring 框架中的 ApplicationListener 应用监听接口，相当于是观察者。

##### 观察目标和观察者类结构图如下：

![](/images/设计模式/46_1.jpg)

##### 新增测试配置类

```java
import lombok.extern.slf4j.slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.Applicationcontext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Slf4j
@Configuration
public class ObserverConfiguration {

    @Bean
    public CommandLineRunner commandLineRunner(ApplicationContext context) {
        return (args) ->{
            log.info("发布事件：什么是观察者模式？");
            context.publishEvent(new JavaStackEvent("什么是观察者模式？"));
        }
    }

    @Bean
    public ReaderListener readerListener1(){
        return new ReaderListener("小明");
    }

    @Bean
    public ReaderListener readerListener2(){
        return new ReaderListener("小张");
    }

    @Bean
    public ReaderListener readerListener3(){
        return new ReaderListener("小爱");
    }
}
```

在 Spring 配置中创建了三个读者 Bean，在 Spring Boot 启动后发布一个观察者模式事件，然后这三个 Bean 就会收到通知。

输出结果：

![](/images/设计模式/46_2.jpg)

这里每个读者创建一个 Bean 可能不太合适，因为要模仿上一个观察者模式的应用。

实际中的观察者模式应用应该是指具体业务，举例说一个电商支付场景，在用户支付完后可以发布一个支付事件，然后会有扣减积分，短信通知、赠送优惠券等一系列后续的事件监听器观察者，这样可以实现业务解耦，这是一种很典型的应用场景。

如果大家有用到消息中间件，其实也是观察者模式中发布订阅模式的概念。

##### 总结

---

利用 Spring 中的事件监听机制也可以轻松实现观察者模式，观察目标也不需要维护观察者列表了，相当于发布-订阅模式，它们之间是完全解耦的，但每个观察者需要创建一个 Bean。

## 47、什么是策略模式？

比如说对象的某个行为，在不同场景中有不同的实现方式，这样就可以将这些实现方式定义成一组策略，每个实现类对应一个策略，在不同的场景就使用不同的实现类，并且可以自由切换策略。

策略模式结构图如下：

![](/images/设计模式/47.jpg)

策略模式需要一个策略接口，不同的策略实现不同的实现类，在具体业务环境中仅持有该策略接口，根据不同的场景使用不同的实现类即可。

面向接口编程，而不是面向实现。

## 48、策略模式有什么优缺点？

##### 策略模式的优点：

1、干掉繁琐的 if、switch 判断逻辑；

2、代码优雅、可复用、亨可读性好；

3、符合开闭原则，扩展性好、便于维护；

##### 策略模式的缺点：

1、策略如果很多的话，会造成策略类膨胀；

2、使用者必须清楚所有的策略类及其用途；

## 49、策略模式在 JDK 中的应用有哪些？

我们再看看 JDK 哪些地方运用了策略模式呢。

##### 1、线程池中的拒绝策略

线程池的构造中有一个拒绝策略参数，默认是默认拒绝策略：

![](/images/设计模式/49_1.jpg)

其实这就是一个策略接口：

![](/images/设计模式/49_2.jpg)

下面有几种拒绝策略的实现：

![](/images/设计模式/49_3.jpg)

在创建 线程池的时候，就可以传入不同的拒绝策略，这就是 JDK 中策略模式的经典实现了。

##### 2、比较器

JDK 中大量使用了 Comparator 这个策略接口：

![](/images/设计模式/49_4.jpg)

策略接口有了，但策略需要开发人员自己定。

集合排序我们比较熟悉的了，不同的排序规则其实就是不同的策略：

![](/images/设计模式/49_5.jpg)

这个策略模式使用了函数式编程接口，比较规则使用匿名内部类或者 Lambda 表达式就搞定了，不需要每个规则定义一个实现类，这样就大量省略策略类了。

这个策略模式可能藏的比较深，但也是 JDK 中经典的策略模式的应用了。

不限于这两个，其实还有更多，你还知道别的么？

所以说，策略模式就在你身边，你一直都在用，但可能没有发觉。。

## 50、编程实现策略模式（真实应用案例）

举个实际的例子，XX 公司是做支付的，根据不同的客户类型会有不同的支付方式和支付产品，比如：信用卡、本地支付，而本地支付在中国又有微信支付、支付宝、云闪付、等更多其他第三方支付公司，这时候策略模式就派上用场了。

传统的 if/else/ switch 等判断写法大家都会写，这里就不贴代码了，直接看策略模式怎么搞！

##### 1、定义策略接口

定义一个策略接口，所有支付方式的接口。

##### 策略接口：

```java
/**
* 支付接口
*/
public interface IPayment {
    /**
    * 支付
    */
    PayResult pay(Order order);
}
```

##### 订单信息类：

```java
/**
* 订单信息
*/
@Data
public class Order {
    /**
    * 金额
    */
    private int amount;

    /**
    * 支付类型
    */
    private String paymentType;
}
```

##### 返回结果类：

```java
@Data
@AllArgsConstructor
public class PayResult {
    /**
    * 支付结果
    */
    private String result;
}
```

##### 2、定义各种策略

定义各种支付策略，微信支付、支付宝、云闪付等支付实现类都实现这个接口。

##### 微信支付实现：

```java
/**
* 微信支付
*/
@Service("WechatPay")
public class WechatPay implements IPayment {

    @override
    public PayResult pay(Order order) {
        return new PayResult("微信支付成功");
    }
}
```

##### 支付宝实现：

```java
/**
* 支付宝
*/
@Service("Alipay")
public class Alipay implements IPayment {
    @Override
    public PayResult pay(Order order) {
        return new PayResult("支付宝支付成功");
    }
}
```

##### 云闪付实现：

```java
/**
* 银联云闪付
*/
@Service("UnionPay")
public class UnionPay implements IPayment {

    @override
    public PayResult pay(Order order) {
        return new PayResult("云闪付支付成功");
    }
}
```

这里我把所有支付方式类都用 @Service 注解生成 Bean 放入 Spring Bean 容器中了，在使用策略的时候就不用 new 支付对象了，何以直接使用 Bean，这样更贴近业务。

##### 3、使用策略

有的文章使用了枚举、HashMap 的方式来根据策略名称映射策略实现类，这样是没有问题，但在使用了 Spring 框架的项目还是有点多此一举，完全可以发挥 Spring 框架的优势，使用 Bean 名称就能找到对应的策略实现类了。

参考示例代码如下：

```java
/**
* 支付服务
*/
@RestController
public class Payservice {

    @Autowired
    private ApplicationContext applicationContext;

    /**
    * 支付接口
    */
    @RequestMapping("/pay")
    public PayResult pay(@RequestParam("amount") int amount, @RequestParam("paymentType") String paymentType) {
        Order order = new Order();
        order.setAmount(amount);
        order.setPaymentType(paymentType);

        // 根据支付类型获取对应的策略bean
         IPayment payment = applicationContext.getBean(order.getPaymentType(), IPayment.class);

        // 开始支付
         PayResult payResult = payment.pay(order);

        return payResult;
    }
}
```

看示例代码，我并没有像策略模式结构图中那样新建一个 Context 类持有策略接口，那是标准的策略模式其实道理是一样的，关键是怎么施放策略。

##### 4、测试一下

> http://localhost:8080/pay?amount=8800&paymentType=WechatPay

![](/images/设计模式/50_1.jpg)

![](/images/设计模式/50_2.jpg)

测试 OK，传入不同的支付方式会调用不同的策略。

## 51、什么是模板方法模式？

模板方法模式是一种行为型设计模式，**它定义了一个包含一系列操作的模板方法，把模板中特定的操作留给子类来实现**，并允许子类在不改变模板总体结构的情况下重新定义模板中的某些步骤。

模板设计模式有两个非常重要的概念：

##### 1、模板方法

模板设计模式有一个抽象类，该抽象类定义了一个模板方法，它包含了一系列的基本操作方法，其中有一些子方法是抽象的，具体的实现留给子类来完成。

##### 2、具体实现

子类继承抽象类，并重写模板方法中调用的的抽象方法，这样如果我们业务有多个实现类，业务流程相同，但某些实现细节不同，我们只需要继承模板抽象类并实现特定的抽象方法即可。

责任链模式结构图如下：

![](/images/设计模式/51.jpg)

模板方法中有多个步骤，如果这里只有 step2、step3 是抽象方法，那子类只需要实现这两个抽象方法即可，其他继承抽象类。

## 52、模板方法模式有什么优缺点？

#### 模板方法模式的优点：

##### 1、代码复用

模板方法模式最大的好处就是代码复用，子类通过继承抽象类来复用父类的代码，自己仅需要实现特定的步骤方法，大大减少了代码的重复性。

##### 2、可扩展性

模板方法模式提供了一种骨架，可以把许多通用的步骤提取出去，剩下的通过抽象方法留给各种子类来实现，这样做提高了代码的可扩展性。

---

#### 模板方法模式的缺点：

##### 1、限制了灵活性

由于模板方法模式在抽象类中已经定义了一系列操作的模板骨架，这就限制了子类的行为，子类在继承时就必须遵循这个骨架，一旦抽象类有变动就会违反开闭原则。

##### 2、违反开闭原则

如果某个子类不完全符合骨架，可能就需要打破模板骨架，或者重新修改抽象类的骨架，这就可能导致需要修改已有的实现类，从而违反了开闭原则。

##### 3、导致类的数量增多

模板方法模式中，每一个不同的实现都需要一个新的子类，这可能会导致类的数量急剧增加，也就是类膨胀，增加了系统的复杂性。

## 53、模板方法模式在 JDK 中的应用有哪些？

##### 1、集合

---

比如 AbstractList、AbstractSet、AbstractMap 这些集合抽象类，这些抽象类中的方法定义了操作的算法骨架，例如迭代元素、添加元素或删除元素的基本步骤，具体的实现细节则留给了继承这些抽象类的具体实现类，如 ArrayList、HashSet、HashMap 等。

比如 **AbstractList** 抽象类的 **add** 模板方法：

```java
public abstract class Abstractlist<E> extends Abstractcollection<E> implements List<E> {
    // ...
    public boolean add(E e) {
        add(size(), e);
        return true;
    }

    public void add(int index, E element) {
        throw new UnsupportedoperationException();
    }
    // ...
}
```

它调用的方法直接抛出异常，这是需要子类去实现的，比如：ArrayList、LinkedList，等等，因为它添加元素的算法是不同的。

##### 2、Servlet

---

大家都知道，HttpServlet 类在 Java 中用于创建 Servlet 请求，它提供了完整的处理 HTTP 请求的方法，如 doGet、doPost 等，而这些方法也都是模板方法中的一个步骤。

真正的模板方法是`Httpservlet`中的`service`方法，它定义了处理 HTTP 请求的模板，它根据请求类型调用相应的 doGet、doPost 等方法，而这些方法都是需要我们在创建 Servlet 时自定义实现的。

如源码所示：

```java
 public abstract class Httpservlet extends Genericservlet {

     protected void service(HttpservletRequest req, HttpservletResponse resp)throws servletException, IoException {
         String method = req.getMethod();

         if (method.equals(METHOD_GET)) {
             long lastModified = getlastModified(req);
             if (lastModified == -1) {
                 doGet(req, resp);
             } else {
                 long ifModifiedsince;
                 try {
                    ifModifiedSince = req·getDateHeader(HEADER_IFMODSINCE);
                 } catch (IllegalArgumentException iae) {
                    ifModifiedsince = -1;
                 }
                 if (ifModifiedsince < (lastModified / 1000 * 1000)) {
                     maybesetlastModified(resp, lastModified);
                     doGet(req, resp);
                 } else {
                          resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                 }
             }
         } else if (method.equals(METHOD_HEAD)) {
             long lastModified = getlastModified(req);
             maybesetlastModified(resp, lastModified);
             doHead(req, resp);
         } else if (method.equals(METHOD_POST)) {
             dopost(req, resp);
         } else if (method.equals(METHOD_PUT)) {
             doput(req, resp);
         } else if (method.equals(METHOD_DELETE)) {
           doDelete(req,resp);
         } else if (method.equals(METHOD_oPTIONS)) {
             dooptions(req,resp);
         } else if (method.equals(METHOD_TRACE)) {
             dotrace(req,resp):
         }else {

             String errMsg = Istrings.getstring("http.method_not_implemented");
             Object[] errArgs = new object[1];
             errArgs[0] = method;errMsg = MessageFormat.format(errMsg, errArgs);

             resp.sendError(HttpservletResponse.SC_NOT_IMPLEMENTED, errMsg);
         }
     }

 // ...
 }
```

## 54、模板方法模式在 Spring 中的应用有哪些？

##### 1、事务管理器

---

Spring 中的事务管理器抽象类是一个经典的模板方法设计模式，如源码所示：

```java
public abstract class AbstractplatformTransactionManager implements PlatformTransactionManager,  ConfigurableTransactionManager, Serializable {
    public final Transactionstatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {
        TransactionDefinition def = definition l= null ? definition : TransactionDefinition.withDefaults();
        object transaction = this.doGetTransaction();
        boolean debugenabled = this.logger.isDebugEnabled();
        if (this.isExistingTransaction(transaction)) {
            return this.handleexistingTransaction(def, transaction, debugEnabled);
        }else if (def.getTimeout()<-1){
            throw new InvalidTimeoutException("Invalid transaction timeout", def.getTimeout());
        } else if (def.getropagationBehavior() == 2) {
            throw new IllegalTransactionstateException("No existing transaction found for titransaction marked with propagation 'mandatory'");
        } else if (def.getPropagationBehavior() l= 0 && def.getPropagationBehavior() l= 3 && def.getPropagationBehavior() l= 6) {
            if (def.getIsolationlevel() l= -1 && this.logger.isWarnEnabled()) {
                this.logger.warn("custom isolation level specified but no actual transaction initiated; isolation level will effectively be ignored: "+ def);
            }
            boolean newsynchronization = this.getTransactionsynchronization() = 0;
            return this.prepareTransactionstatus(def, (object)null, true, newSynchronization, debugEnabled, (object)null);
        }else {
            SuspendedResourcesHolder suspendedResources = this.suspend((object)null);
            if (debugenabled) {
                log var1e = this.logger;
                String varleoe1 = def.getName();
                varl0000.debug("creating new transaction with name [" + varleeo1 + "]: " + def);
            }
            try {
                return this.startTransaction(def, transaction, false, debugEnabled, suspendedResources);
            } catch (Error | RuntimeException var7) {
                this.resume((object)null, suspendedResources);
                throw var7;
            }
        }
    }

    protected abstract object doGetTransaction() throws TransactionException;
// ...
}
```

抽象类是 AbstractPlatformTransactionManager， 模板方法有 getTransaction、startTransaction 等，比如具体的事务处理是通过子类去实现 doGetTransaction 抽象方法的，实现类包括 RabbitTransactionManager、MongoTransactionManager、JpaTransactionManager 等等。

##### 2、模板工具类

---

如 JdbcTemplate，它是 Spring 提供的一个用于简化数据库交互的模板类，它封装了数据库连接的获取、执行查询、更新操作、处理异常和资源清理等标准流程。

如 execute 方法源码所示

![](/images/设计模式/54.jpg)

这是一个典型的模型方法，包含多个步骤，有些步骤是特定的 SQL 操作实现的，但 Spring 并没有使用继承的方式，而是使用方法传参的方式实现的。

Spring 类似的还有 RestTemplate、TransactionTemplate 等等各种模板工具类，它们都是这样设计的。

## 55、编程实现模板方法模式(真实应用案例)

我们来把策略模式的案例再用模板方法模式加强一下，，做成模板方法，把支付流程按实现步骤一步步提取出去，抽象类只保留通用的支付步骤，然后和支付类型相关的步骤留给具体的支付子类去实现。

##### 定义抽象类

定义一个包含模板方法的抽象类，并定义一些固定的支付步骤：

```java
/**
* 模板方法模式-抽象支付类
*/
public abstract class AbstractPayment implements IPayment {

    /**
    * 支付方法 (模板方法)
    */
    @Override
    public PayResult pay(Order order) {
        // 校验支付参数
        checkPaymentData(order);

        // 风控检查
        checkRiskControl(order);

        // 准备支付渠道数据(子类实现)
        preparePaymentchannelData(order);

        // 校验支付结果(子类实现)
        checkPaymentResult(payResult);

        // 发送支付结果通知消息
        sendPaymentResultNotification(payResult);

        return payResult;
    }

    /**
    * 校验支付参数
    */
    protected final void checkPaymentData(Order order) {
        System.out.println("支付参数校验已通过！");
    }

    /**
    * 风控检查
    */
    protected final void checkRiskControl(Order order) {
        System.out.println("风控检查已通过！");
    }

    /**
    * 准备支付渠道数据（子类实现)
    */
    protected abstract void preparePaymentchannelData(Order order);

    /**
    * 调用支付渠道接口 (子类实现)
    */
    protected abstract PayResult callPaymentchannel(Order order);


    /**
    * 校验支付结果 (子类实现)
    */
    protected abstract void checkPaymentResult(PayResult payResult);

    /**
    * 发送支付结果通知消息
    */
    protected final void sendPaymentResultNotification(PayResult payResult) {
        System.out.println("支付结果通知消息已发送！");
    }
}
```

在这个抽象类中，模板方法包含了一系列的步骤，有几个抽象方法是需要支付子类去实现的。

##### 支付子类

如微信支付子类，继承抽象类：

```java
public class WechatPay extends AbstractPayment {

    @Override
    protected void preparePaymentChannelData(Order order) {
        System.out.println("准备微信支付数据");
    }

    @Override
    protected PayResult callPaymentChannel(Order order) {
        System.out.println("调用微信支付接口");
        return null;
    }

    @Override
    protected void checkPaymentResult(PayResult payResult) {
        System.out.println("检查微信支付结果");
    }
}
```

然后实现微信支付具体的支付子步骤即可，其他支付类型也是同样的逻辑，略。

##### 测试一下

写一个测试类测试一下：

```java
/**
* 支付服务
*/
@SpringBootTest
public class PaymentTest {

    @Test
    public void tesWechatPay() {
        Order order = new Order();
        order.setAmount(89);
        order.setPaymentType("wx");

        // 微信支付
        IPayment wechatPay = new WechatPay();
        wechatPay.pay(order);
    }


    @Test
    public void tesAlipay() {
        Order order = new Order();
        order.setAmount(89);
        order.setPaymentType("alipay");

        // 支付宝支付
        IPayment alipay = new Alipay();
        alipay.pay(order);
    }
}
```

微信支付输出结果：

> 支付参数校验已通过！
>
> 风控检查已通过！
>
> 准备微信支付数据
>
> 调用微信支付接口
>
> 检查微信支付结果
>
> 支付结果通知消息已发送！

支付宝支付结果：

> 支付参数校验已通过！
>
> 风控检查已通过！
>
> 准备支付宝支付数据
>
> 调用支付宝支付接口
>
> 检查支付宝支付结果
>
> 支付结果通知消息已发送！

可以看到，模板方法模式最大的好处就是定义固定步骤，复用公共逻辑代码，其他子类只需要实现自己的特定步骤即可，模板方法模式也可以很好的与一些常用的设计模式结合使用。

## 56、什么是责任链模式？

责任链模式是一种**行为设计模式**，用于在多个处理器对象链中传递请求，多个处理器对象都有机会处理请求，直到某个处理器对象能处理该请求为止，从而规避了请求发送者和接收者之间的耦合。

责任链模式通常用于实现不同的处理逻辑，其中每个处理器对象都决定自己能否处理当前请求，如果能，则处理请求并返回，如果不能，则将请求继续传递给处理链中的下一个处理器对象，如果还不能，就继续传递，直到能处理为止，所以它就叫责任链模式。

> 在 Java 开发中，责任链模式也会有不同的变体，有的责任链中的所有处理器都会执行一遍，比如过滤器责任链，只要有一个过滤器通过，剩下的过滤器都会执行一遍，如果有一个过滤器不通过，后面的也不会再执行。

责任链模式结构图如下：

![](/images/设计模式/56.jpg)

##### 客户端（Client）：

使用责任链模式的客户端，客户端通常会创建处理器链，并启动请求的处理过程。

客户端不需要知道责任链中具体的处理逻辑和处理顺序，它不关心处理链传递过程，它只需要将请求发送到链中的第一个处理器即可，传递过程设置在每个具体的处理器实现类中。

##### 处理器（Handler）：

处理器包括**一个处理器抽象类和多个处理器实现类**。

处理器抽象类负责维护处理器链上的公共逻辑，比如，判断是否能处理请求、设置下一个处理器实现类，以及处理器实现类需要具体实现的「请求处理」抽象方法。

不同的处理器实现类继承处理器抽象类，会继承公共逻辑，只需要再实现「请求处理」抽象方法即可。

## 57、责任链模式有什么优缺点？

#### 责任链模式的优点：

##### 1、降低耦合度

责任链模式可以让发送者和接收者解耦，只需要发给第一个接收者，请求会沿着链传递，直到有对象处理它为止，最终是谁处理请求，发送者并不关心。

##### 2、灵活性、可扩展性、可维护性

责任链模式可以动态改变责任链内的处理器，比如调整它们的处理顺序，增加或删除处理器，这样就能给系统设计带来很大的灵活性、可扩展性，以及可维护性。

---

#### 责任链模式的缺点：

##### 1、性能影响

一个请求可能需要遍历整个责任链，才能被某个处理器对象处理，特别是在责任链比较长的情况下，这必然会带来影响性能，甚至会导致系统出现不确定的状态或错误。

##### 2、调试困难

由于责任链的动态特性，特别是在责任链的结构在运行时可能发生变化的情况下星调试可能会比较复杂。

## 58、责任链模式怎么避免超长链问题？

避免责任链模式出现超长链问题，可以采取以下策略。

##### 1、限制链的长度

这也是最简单的做法，在设计时就明确限制责任链的最大长度，当链的长度接近或达到这个限制时，重新考虑链的设计，看是否有必要重新组织或优化。

##### 2、处理器职责划分明确

合理地分解和定义每个处理器的职责，减少链中的环节数量，避免让不必要的处理器堆积在链上。

##### 3、动态管理链中元素

可以根据当前的业务需求，动态地添加或删除责任链中的处理器，以保证链始终保持在最优的长度，只包含那些确实需要的处理器。

## 59、责任链模式如何确保请求最终被处理？

在责任链模式中，除了最后一个处理器，每个处理器都会持有下一个处理器的引用，但如果所有的处理器都不满足条件，这样就会导致请求没有被处理。

##### 这个情况，可以有以下两种处理方式：

- 通过在链的末端添加一个默认处理器来实现；
- 根据返回的特定结果（比如：null），再去用默认的处理器执行。

也就是说，这个默认的处理器负责兜底，它能够处理所有类型的请求。

但是否能设置默认处理器，这个要根据实际业务来处理。

## 60、责任链模式在 JDK 中的应用有哪些？

##### 1、Java Servlet 过滤器

---

最经典的应用就是在 JavaEE 应用程序中，**过滤器（Filter）就使用到了责任链模式**。

过滤器用于在 Servlet 处理请求之前或响应客户端之后，再执行一些预处理/后处理操作，比如处理字符编码、检查是否登录，检查是否有处理权限等等。

它有一个 FilterChain 过滤器链接口，允许多个过滤器按顺序应用于一个请求或响应，每个过滤器都有机会处理请求/响应，然后决定是否将控制权传递给链中的下一个过滤器。

在 Tomcat 中，相关的实现细节位于如 ApplicationFilterChain 等内部类中，这个类实现了 FilterChain 接口,并贯穿了整个过滤器逻辑的执行。

##### 2、Java 日志 API

---

Java 中的日志 APl 就是使用责任链模式来传递日志消息的，其日志记录器（Logger）有多个处理器（Handler），比如：ConsoleHandler、FileHandler 等，每个处理器负责将日志消息传递到一个特定的目的地。

Logger 类中的 addHandler 和 removeHandler 方法用于添加和移除 Handler 对象，而 log 方法则用于创建日志记录并将其传递给所有注册的 Handler 对象进行处理。

## 61、责任链模式在 Spring 中的应用有哪些？

##### 1、Spring MVC 拦截器

---

Spring MVC 中的 Handlerlnterceptor 拦截器接口，它里面有 **preHandle、postHandle,afterCompletion**几个拦截方法，分别在不同的请求处理阶段处理一些逻辑。Handlerlnterceptor 在责任链模式中充当处理器的角色，**HandlerExecutionChain** 则充当客户端的角色，它可以添加拦截器，并发起责任链调用。

##### 2、Spring Security 安全过滤器链

---

Spring Security 的过滤器链中，每个具体的过滤器都可以视作一个处理器，比如：

- **UsernamePasswordAuthenticationFilter**：用于处理基于表单的登录请求；
- **BasicAuthenticationFilter**：处理基本的 HTTP 认证。

这些过滤器承担着责任链中处理器的角色，负责处理特定类型的安全相关任务。

关键类是 FilterChainProxy，它负责管理和协调多个安全过滤器，让这些过滤器按照特定的顺序执行，如果一个过滤器不能处理请求，它会将请求传递给链中的下一个过滤器。

## 62、编程实现责任链模式（真实应用案例）

举个实际的例子，XX 公司是做支付的，根据不同的客户类型会有不同的支付方式和支付产品，比如：信用卡、本地支付，而本地支付在中国又有微信支付、支付宝、云闪付、等更多其他第三方支付公司。

之前我们用「策略模式」实现过，这里我以微信、支付宝、信用卡举例来演示，看看用责任链模式怎么来实现。

##### 1、定义支付请求类

这个支付包含所有支付参数，包括支付类型 type，其他略。

```java
/**
* 支付请求
*/
@Data
@RequiredArgsConstructor
public class PaymentRequest {
    /**
    * 支付类型，1 －WechatPay、2 － ALipay、3 －CreditCard
    */
    final int type;
}
```

##### 2、定义处理器抽象类

定义一个处理器抽象类，包含处理器公共逻辑，以及一个抽象方法 process，抽象方法 每个处理器实现类负责实现，这里其实也是模板设计模式的简单应用。

```java
/**
* 支付处理器抽象类
*/
@Data
@RequiredArgsConstructor
public abstract class PaymentHandler {
    /**
    * 支付类型
    */
    private final int type;

    /**
    * 下一个支付处理器
    */
    private PaymentHandler nextHandler;

    /**
    * 处理支付请求 (模板方法)
    */
    public final void handleRequest(PaymentRequest paymentRequest){
        if (paymentRequest.getType() == this.type) {
            System.out.println("找到对应的支付处理器");
            process(paymentRequest);
        }else {
            if (this.nextHandler != null) {
                System.out.println("没找到对应的支付处理器，转发给下一个支付处理器");
                this.nextHandler.handleRequest(paymentRequest);
            } else {
                System.out.println("支付链处理完成。");
            }
        }
    }

    /**
    * 处理器实现类具体处理逻辑
    */
    protected abstract void process(PaymentRequest paymentRequest);
}
```

##### 3、定义各种处理器实现类

##### 微信支付处理器：

```java
/**
* 微信支付处理器
*/
public class WechatPayHandler extends PaymentHandler {

    public WechatPayHandler() {
        super(1);
    }

     @Override
     protected void process(PaymentRequest request) {
         System.out.println("正在处理微信支付");
         // 支付处理逻辑
     }
}
```

##### 支付宝处理器：

```java
/**
* 支付宝处理器
*/
public class AliPayHandler extends PaymentHandler {
    public AliPayHandler() {
        super(2);
    }

    @Override
    protected void process(PaymentRequest request) {
        System.out.println("正在处理支付宝支付");
        // 支付处理逻辑
    }
}
```

##### 信用卡处理器：

```java
/**
* 信用卡处理器
*/
public class CreditCardHandler extends PaymentHandler {
    public CreditCardHandler() {
        super(3);
    }

    @Override
    protected void process(PaymentRequest request) {
        System.out.println("正在处理信用卡支付");
        // 支付处理逻辑
    }
}
```

##### 4、支付客户端

以下仅为测试客户端，实际业务中会有一个类来封装责任链关系。

```java
/**
* 支付客户端
*/
public class Paymentclient {
    public static void main(String[] args) {
       // 创建责任链处理器
        PaymentHandler wechatPayPaymentHandler = new WechatPayHandler();
        AliPayHandler aliPayPaymentHandler = new AliPayHandler();
        PaymentHandler creditCardHandler = new CreditCardHandler();

        // 设置支付责任链
        wechatPayPaymentHandler.setNextHandler(aliPayPaymentHandler);
        aliPayPaymentHandler.setNextHandler(creditCardHandler);

        // 模拟支付宝支付请求
        System.out.println("开始支付宝支付请求");
        wechatPayPaymentHandler.handleRequest(new PaymentRequest(2));
        System.out.println("---------");

        // 模拟微信支付请求
        System.out.println("开始微信支付请求");
        wechatPayPaymentHandler.handleRequest(new PaymentRequest(1));
        System.out.println("---------");

        // 模拟信用卡支付请求
        System.out.println("开始信用卡支付请求");
        wechatPayPaymentHandler.handleRequest(new PaymentRequest(3));
    }
}
```

##### 5、测试一下

运行支付客户端，结果输出如下：

> 开始支付宝支付请求
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 找到对应的支付处理器
>
> 正在处理支付宝支付
>
> ---
>
> 开始微信支付请求
>
> 找到对应的支付处理器
>
> 正在处理微信支付
>
> ---
>
> 开始信用卡支付请求
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 没找到对应的支付处理器，转发给下一个支付处理器
>
> 找到对应的支付处理器
>
> 正在处理信用卡支付

责任链的顺序是：**微信->支付宝->信用卡**

可以看到，当我们发起多个不同的支付请求时，它总会从第一个支付处理器开始走，如果不匹配就转发给它的下一个支付处理器，直到找到匹配的支付处理器为止。

## 63、什么是装饰器模式？

装饰器模式，从字面上理解，顾名思义，就是一种装饰模式，它可以在不改动原有代码的情况下，对现有的对象、行为进行新的层次的包装、装饰，增强原有的基本功能以提供更丰富的能力。

举个简单的装修的小例子：

> 清理〉刮腻子〉涂油漆〉挂壁画

也可以是：

> 清理〉刮腻子〉贴大理石〉挂电视

或者可以是：

> 清理〉刮腻子〉贴墙纸

这是一步步的简单装修墙面过程（哈哈，大概如此，我不是专业的），这就是装饰器模式，装饰的每个步骤互不干涉，但后面的步骤需要依赖前一个步骤的完成，后面的步骤可以不断在前一个的装饰基础上进行增加。

##### 装饰器模式结构图如下：

![](/images/设计模式/63.jpg)

##### 装饰器模式类结构如下：

- Component：组件接口类，定义被装饰类的基本功能
- ConcreteComponent：组件接口的基本实现类
- Decorator：装饰器角色类，实现并持有一个 Component 对象实例
- ConcreteDecorator：装饰器的实现类

## 64、装饰器模式有什么优缺点？

##### 装饰器模式的优点：

1、不改动原有代码，动态增加功能；

2、对象之间不会相互依赖，松耦合，够优雅；

3、符合开闭原则，扩展性好、便于维护；

##### 装饰器模式的缺点：

1、装饰环节如果很多的话，会造成装饰器类膨胀；

2、装饰器层层嵌套比较复杂，使用者必须清楚所有的装饰器类及其用途；

## 65、装饰器模式在 JDK 中的应用有哪些？

我们再看看 JDK 哪些地方运用了装饰器模式呢。

#### 1、IO 流

最经典的装饰器模式应用莫过于 JDK 中的 IO 流了 （InputStream/ OutputStream）

##### 常用的 InputStream 类结构类如下：

![](/images/设计模式/65_1.jpg)

InputStream 和 FilelnputStream 是基本的组件接口和实现。

FilterlnputStream 就是一个实现组件接口并持有实例引 l 用的装饰器角色：

![](/images/设计模式/65_2.jpg)

BufferedlnputStream、DatalnputStream 都是不同的 FilterlnputStream 的装饰实现。

OutputStream 也是同样的原理。

##### 2、同步集合

要对非线程安全的集合（如：List、Set）简单提供线程安全的功能，使用装饰器模式也能轻松实现。

来看同步集合工具类方法：

> java.util.Collections#synchronizedList(List)
>
> java.util.Collections#synchronizedSet(Set)

![](/images/设计模式/65_3.jpg)

它们都是 SynchronizedCollection 的装饰器实现类：

![](/images/设计模式/65_4.jpg)

SynchronizedCollection 是装饰器角色：

![](/images/设计模式/65_5.jpg)

SynchronizedCollection 实现了集合组件接口并持有集合实例引引用，而 Collection(List)和 ArrayList 是基本的组件接口和实现。

## 66、编程实现装饰器模式(真实应用案例)

##### 装饰器模式实战

---

我们把上面的装修的案例用装饰器模式实现一下。

##### 组件接口类：

```java
/**
* 墙面装修接口
*/
public interface WallBeautify {
    /**
    * 装修操作
    */
    void operation();
}
```

##### 组件接口的基本实现类：

```java
/**
* 墙面装修基本实现 (清理墙面)
*/
public class WallBeautifyClean implements WallBeautify {
    @Override
    public void operation() {
        System.out.println("开始清理墙面");
    }

}
```

##### 装饰器角色类：

这是一个抽象类，实现并持有一个 Component 对象实例，这里使用的是聚合，而不是继承，这也是装饰器模式的要点所在。

```java
/**
* 墙面装修装饰器角色
*/
public abstract class WallBeautifyDecorator implements WallBeautify {

    /**
    * 持有一个Component对象实例
    */
    private WallBeautify wallBeautify;


    public WallBeautifyDecorator(WallBeautify wallBeautify) {
        this.wallBeautify = wallBeautify;
    }

    @Override
    public void operation() {
        wallBeautify.operation();
        decoration();
    }

    /**
    * 装饰器实现类自定义实现方法
    */
    public abstract void decoration();
}
```

覆写原操作方法，在原操作之后再进行装饰，所以需要提供一个抽象的 decoration 方法供不同的装饰器的实现类去实现。

##### 装饰器的实现类：

这里定义了 3 个装修过程：

> 刮腻子〉涂油漆〉挂壁画

所以各自去继承 **装饰器角色类** 并实现其装饰方法：

```java
/**
* 墙面装修装饰器角色实现(刮腻子)
*/
public class WallBeautifyPutty extends WallBeautifyDecorator {

    public WallBeautifyPutty(WallBeautify wallBeautify) {
        super(wallBeautify);
    }

    @Override
    public void decoration() {
        System.out.println("开始刮腻子");
    }
}
```

```java
/**
* 墙面装修装饰器角色实现(涂油漆)
*/
public class WallBeautifyPaint extends WallBeautifyDecorator {
    public WallBeautifyPaint(WallBeautify wallBeautify) {
        super(wallBeautify);
    }

    @Override
    public void decoration() {
        System.out.println("开始涂油漆");
    }
}
```

```java
/**
* 墙面装修装饰器角色实现 (挂壁画)
*/
public class WallBeautifyHang extends WallBeautifyDecorator {
    public WallBeautifyHang(WallBeautify wallBeautify) {
        super(wallBeautify);
    }

    @Override
    public void decoration() {
        System.out.println("开始挂壁画");
    }
}
```

##### 测试一下：

```java
/**
*
*/
public class DecoratorTest {
    public static void main(String[] args) {
        // 清理墙面
        WallBeautify wallBeautifyclean = new WallBeautifyClean();
        wallBeautifyclean.operation();
        System.out.println("--------");

        // 刮腻子
        WallBeautify wallBeautifyPutty = new WallBeautifyPutty(wallBeautifyClean);
        wallBeautifyPutty.operation();
        System.out.println("--------");

        // 涂油漆
        WallBeautify wallBeautifyPaint = new WallBeautifyPaint(wallBeautifyPutty);
        wallBeautifyPaint.operation();
        System.out.println("--------");

        // 挂壁画
        WallBeautify wallBeautifyHang = new WallBeautifyHang(wallBeautifyPaint);
        wallBeautifyHang.operation();
        System.out.println("--------");

        // 多层嵌套
        WallBeautify wbh = new WallBeautifyHang(new WallBeautifyPaint(
            new WallBeautifyPutty(new WallBeautifyClean())));
        wbh.operation();
        System.out.println("--------");
    }
}
```

本节教程所有实战源码已上传到这个仓库：

> https://github.com/javastacks/javastack

> 开始清理墙面
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> 开始挂壁画
>
> ---
>
> 开始清理墙面
>
> 开始刮腻子
>
> 开始涂油漆
>
> 开始挂壁画
>
> ---

结果输出正常！

可以看到，装饰器模式的使用还是相对比较简单的，使用装饰器模式可以达到不同的装饰效果，这样即满足了不同客户的需求，而又不用改动原有的代码，还是挺香的。
