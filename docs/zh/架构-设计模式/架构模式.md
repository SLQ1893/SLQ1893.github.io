## 1、你怎么理解系统架构师？

![](/images/架构设计/1.jpg)

这张图从架构师的综合能力、岗位认识、岗位职责等方面，清楚的画出了作为一个架构的基本准则。人人都想成为架构师，可作为架构你达到了上面的要求了吗?系统架构师是个神奇的岗位。为什么这么说，在一个人数不多的小公司，你可能什么都需要做，身体力行，做总监兼架构师或者是主管/高级开发兼架构师；在大公司，你可能只负责某个平台的架构，某些中间件的架构，你就是某一类的架构师。

无论怎么分，作为一个架构师，你必须具备以下几个特性。

- ##### 技术能力

技术能力，不用置疑肯定是最重要的。技术能力弱的架构不是一个好架构。所以，你需要知道所有主流技术的基本原理、应用场景，及快速解决问题的能力。

所以，架构师必须要有见识，所需知识面肯定是要不断拓展的。你需要清楚在什么样的场景用什么样的技术比较合适，并知道可能存在什么样的风险。来了需求，你脑袋是空的，不知道用什么技术这是最可怕的。

- ##### 架构能力

这个可以表现为抽象能力、整体规划能力、及设计能力。你需要照在业务的角度进行系统分解、技术选型、架构搭建，以及规范制定。架构出来了至少可以满足近几年的发展，或者可以很方便对现有架构进行扩容。

有人说架构不需要懂业务，我面试过的就有明确表示不做业务架构。当然有方面的架构师，如中间件架构师，运维基础设施架构师等。但一般的后端架构师都是需要了解业务，不理解业务你如果进行系统分解，服务划分，及根据不同业务作出不同的架构？

技术都是为业务服务的，不站在业务的角度设计架构，那架构就是空谈。

- ##### 沟通能力

这个看起来不是最重要的，其实也非常重要。作为一个优秀的架构师，你需要清楚的知道客户的需求，需要不断和需求人员进行沟通，以达到客户真正的目的。不论是不是架构师，任何一个职场人，提高自己的沟通表达能力无疑是不可或缺的。有一句话怎么说的，领导就喜欢拍马屁的。做领导的大多不是技术特别牛的，但沟通能力肯定是一流的。

这 3 点肯定是架构师的核心，但不一定是每个架构师的标准。

国内做程序员，30 岁左右就得转型，不然就会被嫌弃。不管是不是如此，大环境就是这样，程序员你能干到 35 已见天花板。

所以，程序员必须转型，管理职位数量有限，对性格、沟通表达能力有要求。所以转型架构师是首选，大家一起加油吧。

## 2、什么是 C-S 架构？

C/S 架构：即客户端（**C**lient）和服务器（**S**erver）架构模式，用户通过客户端和服务器进行交互。

这里的客户端可以是电脑应用软件、手机/平板 APP、浏览器等等，B/S 架构其实就是一种特殊的 C/S 架构。

## 3、什么是 B-S 架构？

B/S 架构：即浏览器（**B**rowser）和服务器（**S**erver）架构模式，用户通过浏览器和服务器进行交互。

## 4、什么是前后端分离架构？

##### 前后端分离是指：

指将一个 Web 系统的动态内容和静态内容进行分离，包括其开发、部署等。

比如传统的 MVC 架构，HTML/JS/ CSS...等前端代码和 Java/ Spring/Mybatis..等后端代码是在同一个项目中进行开发、部署的，前后端分离后，就可以分多个项目进行开发、部署，多个前端、多个后端，通过 http restful api 接口的形式进行交互。

## 5、前后端分离架构有什么好处？

前后端分离架构有几个好处：

1、前端和后端互不影响，实现高内聚低耦合，提升工作效率；

2、静态资源不占用后端的资源，可维护性、扩展性更好；

3、静态资源可以缓存到代理服务器上（Nginx），加速响应；

4、静态资源可以部署到 CDN，用户可以就近访问，提升用户的访问速度和体验；

............

## 6、什么是三层架构？

##### 三层架构是指：

- 界面层(User Interface layer)
- 业务逻辑层(Business Logic Layer)
- 数据访问层(Data Access Layer)

三层架构的区分层次的目的是为了符合“**高内聚，低耦合**”，各层之间采用接口形式访问，并通过对象模型的实体类（Model）作为数据传递的载体。

## 7、三层架构和 MVC 的区别？

##### 三层架构是指：

- Ul：界面层（User Interface layer）
- BLL：业务逻辑层（Business Logic Layer）
- DAL：数据访问层（Data Access Layer）

##### MVC 是指：

- M：业务模型（Model）
- V：用户界面（View）
- C：控制器（Controller）

---

##### 两者区别：

1、两者不是同一个东西，三层架构是一个分层式的软件体系架构设计，是针对整个软件系统的解耦，各层之间通过接口进行交互；而 MVC 是一个软件设计模式，是针对 Web 系统的解耦。

2、MVC 是应用在三层架构基础之上的，MVC 中的 V/C 相当于三层架构中的 UI 界面层，而 M 相当于三层架构中的 BLL/ DAL 层。

## 8、RESTful API 是什么？

RESTful API 是一种灵活、可扩展和易于使用的 Web 服务接口设计风格，通过 HTTP 协议实现对 Web 资源的访问和操作，可以创建出高效、可维护和易于扩展的 Web 服务。

RESTfuIl API 支持多种 HTTP 请求方法，例如 GET、POST、PUT、DELETE 等，每个 HTTP 请求方法都对应一个特定的操作，例如获取资源、创建资源、更新资源和删除资源等。

## 9、RESTful API 为什么这么流行？

因为 RESTful API 具有许多优点：

##### 1、易于使用

RESTful API 使用 HTTP 作为通信协议，使用广泛，并且易用。

##### 2、兼容性

由于 RESTful API 使用 HTTP 协议，所以可以支持跨平台、跨编程语言。

##### 3、可扩展性

RESTful API 具有很好的可扩展性，它可以添加新的资源和方法，而不会破坏现有的 APl。

##### 4、易于测试

RESTful API 易于测试，因为是基于 HTTP 应用级协议，有很多成熟的工具可以进行测试。

## 10、RESTful API 设计原则有哪些？

RESTful API 的设计原则主要包括以下几点：

##### 1、资源定位

每个 Web 资源都应该通过一个唯一的 URI 来标识，URI 应该反映资源的层次结构。

##### 2、统一接口

RESTfuI API 应该使用统一的接口，包括 HTTP 方法（不同的请求类型要使用相对应的请求方法等（比如：获取数据使用 GET，提交数据时使用 POST 等）、URI 格式和数据格式（比如：JSON/XML）等。

##### 3、无状态

RESTful API 应该是无状态的，每个请求都应该包含足够的信息来处理该请求，服务器不应该保存客户端的状态。

等等。。欢迎补充！

## 11、RESTful API 中的 URI 如何设计？

RESTful API 中的 URI 应该反映资源的层次结构，URI 应该简单明了，并且易于理解，URI 的设计应该遵循以下原则。

##### 1、使用名词而不是动词

URl 应该使用名词来标识资源，而不是使用动词来描述操作。例如，使用“**/users/123**"来表示用户资源，而不是使用“**/get-users/123**"来表示获取书籍资源的操作。

##### 2、使用复数形式

URI 应该使用复数形式来表示集合资源，例如，使用"**/users**”来表示所有用户资源。

##### 3、避免使用空格和特殊字符

URI 应该避免使用空格和特殊字符，以避免 URL 编码的复杂性。

##### 4、使用连字符而不是下划线

URl 应该使用连字符而不是下划线来分隔单词。例如，使用“**/user-reviews**"来表示用户评论资源，而不是使用"**/user_reviews**"。

##### 5、使用小写

URI 应该统一使用小写形式，避免使用大小写混合，增加复杂度。

## 12、RESTful API 多版本控制怎么做？

RESTful API 版本控制一般有以下两种方案。

##### 1、URI 中指定版本号

可以通过在 URl 路径中添加版本号来实现，例如"**/api/v1/users**"表示 API 的第一个版本的用户资源。

> **这种方案的优点**：版本号在 API 中，用户很清晰的知道要调用的 API 版本。
>
> **这种方案的缺点**：当版本变化时，URI 会发生变化，所以导致客户端的代码也要更改。

##### 2、使用 HTTP Header 来指定版本号

比如，在请求头中使用“**Accept-Version**"头来指定 APl 的版本号。

> **这种方案的优点**：URI 不会发生变化，客户端不需要任何更改。
>
> **这种方案的缺点**：实现比较复杂，需要服务器端和客户端配合。

一般使用第一种方案比较多。

## 13、RESTful API 怎么做认证和授权？

RESTful API 认证和授权一般有以下三种方案。

##### 1、HTTP 认证

使用 HTTP 自带的认证方式，比如 Basic Auth、Bearer Token 等。

![](/images/架构设计/13.jpg)

##### 2、OAuth

使用 OAuth 协议来进行认证和授权，客户端通过 OAuth 协议获取访问令牌，然后使用访问令牌来访问受保护的资源。

##### 3、JWT

使用 JSONWeb Token（JWT）来进行认证和授权。JWT 是一种开放标准，可以在网络上安全地传输信息，客户端在请求中包含 JWT 令牌，服务器验证令牌是否有效。

> HTTP 认证是最简单的方式，OAuth 和 JWT 则更强大、更安全，可扩展性也更好。

## 14、谈谈你对重构的理解？

##### 重构，即：重新构造

意思是在不改变原有系统功能的前提下，对系统原有代码进行重新构造，包括但不限于：

- 改变系统内部整体架构
- 更换所有、部分核心技术
- 使用更好的设计模式
- 代码逻辑、性能优化
- ......

## 15、为什么要重构？

重构的目的是为了改进系统的代码设计，以满足系统的需求、可维护性和可扩展性。

比如：

> 一家公司用了 10 几年的 SSM 架构，所有代码都写在一个系统里面，对于前后端开发人员的独立开发非常不方便，现在要使用前后端分离架构，前后端开发人员各自开发各自的互不影响，就不得不对系统进行重构。

又或者：

> 个开发人员把某个功能点的所有的代码都写在一个类里面，类非常庞大，不好理解，也非常难维护，就不得不对这个功能点进行重构。

## 16、谈谈你工作中是怎么重构的？

以下几点供参考：

1）代码过长的类、方法抽取子类、子方法；

2）复复的代码逻辑抽取公共方法、工具类等；

3）参数过多的方法使用对象接收，或者使用 Builder 模式；

4）更换过时的、有漏洞的组件；

5）合理使用各种设计模式；

......

## 17、怎么优化项目中大量的 if-else 语句？

项目中有很多 if-else 语句，很不优雅，你知道有哪些优化方案吗？

##### 1、三元表达式

一些简单的逻辑就没有必要写 if-else 了，用三元表达式更优雅，比如：

```java
String value = param == 0 ? 'xxi' : 'xx2';
```

##### 2、枚举

如果条件逻辑涉及到一组固定值的处理，比如：月份、星期、状态、类型等，可以使用枚举类型，每个枚举值可以包含一组数据，而不用写 if-else 来处理。

具体参考《什么是枚举类型？》面试题。

##### 3、设计模式

比如使用 策略模式，策略模式可以将不同的策略（即不同的条件逻辑）封装在不同的策略类中，在要执行条件逻辑时，通过策略名选择合适的策略来执行相应的操作。

具体实现见《编程实现策略模式（真实应用案例）》面试题。

##### 4、映射

可以将条件逻辑（类名、方法名、或是其他）映射到数据结构中，如使用 HashMap、或者数据库表，这样可以根据键值和相关手段（比如：反射）来执行相应的操作。

##### 5、链式调用

如果一系列条件是相互排斥的（即不是 if-else 的关系，是多个不同 if 的关系），可以使用链式调用，将每个条件逻辑抽取成独立的方法来调用，这样可以使代码更优雅，也更具有可读性。

##### 6、Optional#map

有的时候一个值藏在许多子对象中，比如下面的 if 语句：

```java
if(xxxorder != null){
    if(xxxorder.getxxxshippingInfo() l= null){
        if(xxxorder.getxxxshippingInfo()-getxxxshipmentDetails() != null){
            if(xxxorder.getxxxshippingInfo().getxxxshipmentDetails().getxxxTrackingInfo() != null){
                // ...
            }
        }
    }
}
```

获取一个订单物流信息要依次判断对象是否为 null，这样一大堆的 if-else 也太不优雅了，这时候可以直接把就用**Java 8 中的 Optional#map** 方法来优雅实现：

```java
private String[] getFulfillments(xxxorder xxxorder) {
    return optional.ofNullable(xxxorder)
        .map((o) -> o.getxxxshippingInfo())
        .map((si) -> si.getxxxShipmentDetails())
        .map((sd) -> sd.getxxxTrackingInfo())
        .map((t) -> new String[]ft.getTrackingNumber(), t.getTrackingLink())
        .orElse(null);
}
```

这样是不是优雅多了？

来看下 **Optional#map**方法的实现源码：

```java
public<U> Optional<U> map(Function<? super I, ? extends U> mapper) {
    // 函数式接口不能为nuLL
    objects.requireNonNull(mapper);

    //如果当前没有值。返回一个空的optionaL
    if (!isPresent())
        return empty();
    else {
        // 如果当前有值，返回一个函数式处理该值的结果optionaL
        return Optional.ofNullable(mapper.apply(value));
    }

    // 判断 optionaL VaLue 有没有值
    public boolean ispresent() {
        return value I= null;
    }

    //创建一个 optional，可以为空
    public static <T> Optional<T> ofNullable(T value) {
        return value == null ? empty() : of(value);
    }
}
```

所以回到这段程序：

```java
// 根对象为空就创建一个空optionaL，否则就创建一个根对象的optionaL
0ptional.ofNullable(xxxorder)
    // 根对象为空就直接返回空optional，否则返回这个值的OptionaL
    .map((o) -> o.getxxxshippingInfo())
    // 下面依次类推...
    .map((si) -> si.getxxxshipmentDetails())
    .map((sd) -> sd.getxxxTrackingInfo())
    .map((t) -> new String[]ft.getTrackingNumber(), t.getTrackingLink())
    // 取不到值就返回nuLL
    .orElse(null);
```

这个的关键核心在于，调用 map 时，如果 Optional 没有值就直接返回空的 Optional，而不会调用函数式接口，所以就不会出现空指针。所以只要有一个为空，后面就取不到物流信息。

程序使用了 .xx.xx.xx 这样的链式调用，调用 map 方法就必须是 Optional， 而 map 的返回结果就是 Optional。

##### 7、规则引擎

规则引引擎（Rule Engine）是一个用于执行基于规则逻辑的引引擎，它提供了一种声明性的方式来定义和管理业务规则，以便自动化决策和执行复杂的业务逻辑。规则引擎通过规则管理器来管理和存储规则，规则执行引擎负责根据规则的定义和条件执行规则，并产生相应的结果。

规则编辑器通常提供了一种可视化的界面，使业务人员可以直观地定义和编辑规则，而不需要编写复杂的代码。

> 参考分类 **架构设计－规则引擎**相关的面试题。

## 18、设计一个秒杀系统要考虑哪些技术点？

##### 参考的技术要点：

1、尽量将请求拦截在前端，避免后端的压力，比如：

- 前端随机拒绝请求
- 按钮没开始置灰
- 按钮点完置灰
- 避免重复请求

2、静态页面加速，比如：

- 页面静态化
- 静态资源缓存
- 部署到 CDN

3、防止刷单 (秒杀开始前才生成秒杀接口地址，接口地址动态化)

4、后端启用缓存 (尽量减少数据库的请求)

5、服务降级（暂停非核心的服务）

6、后端启用 IP 限流 (超过拒绝连接)

7、服务独立部署 (不影响核心的业务)

8、服务扩容 (临时扩展一定的机器保证秒杀)

9、考虑秒杀时的带宽

10、达到上限后端拒绝 (秒杀结束)

## 19、长链接转短链接，说说你的实现方案？

##### 通过长链接转短链接，通过短链接可以跳到长链接。

比如：

> https://wwwjavastack.cn/article/2021/intellj-idea-2021.2-released/

转为短链接：

> https://t.xx.com/xDM6x1

##### 技术参考要点：

1、主要是一个映射关系，可以在数据库中存储；

2、唯一短码的生成，一般 6－8 位够用了（自增 ID、随机数、Hash 算法等）

3、根据短网址域名查询短码对应的长链接，再用 301 进行永久重定向；

##### 数据量和访问量大考虑使用大数据、缓存等方案。

## 20、一个安全的登录流程要考虑哪些？

##### 总结一下：

- 使用 https 协议进行传输，虽然麻烦，但是很强的保护措施。
- 强制用户使用有一定强度且复杂的密码，必须要有大小写加数字，长度在 8 位以上，杜绝像 123456 之类的弱密码。
- 密码不要明文保存到数据库，CSDN 当年使用明文存储密码导致用户密码被完全暴露，这个事件影响十分严重。所以造成不要使用明文存储密码，要使用像 MD5 之类的散列算法加密存储，加密之前密码同时还要加上一个不固定的 salt 值一起拼接加密，一般 md5(md5(password)+ salt)就可以了，这个 salt 是盐，一起加密增加密码的长度也增加了破解的难度，盐一般设计为 64 位随机生成的字符串，最好分开存放，假如用户信息库被攻击了黑客也拿不到盐的库。不能使用可逆的算法，如果可逆，那如何保存密钥是个非常棘手的问题，一般使用明文加密与数据库中的密文对比就能确定密码正确与否，我们不需要知道用户的明文是什么，如果用户忘了可以通过重置或者密码保护问题修改密码，这也比总明文存储要好一万倍。
- MD5 现在已经不是十分安全了，最好使 sha256，sha512 之类安全强度更高的散列加密算法。
- 用户名密码错误不要单方面提示，如果密码错误提示用户说密码错误这样攻击者就知道用户名是对的，下次攻击密码，所以不管是用户名还是密码错误都给出同样的提示：用户名或密码错误，或者别的不具体的提示的错误都可以。
- 前端禁止用户输入导致 sql 注入的字符，后台也要做 sql 注入的防护。
- 保存历史密码，一段时间没登录的用户再次登录时提示要修改密码才能登录，这时新密码不能和历史密码一样，苹果就是这么做的。
- 保存每次的登录信息日志，如果登录的 IP 与以往有很大差别，要引导用户重置密码方可登录。
- 不要在 cookie 中保留用户密码，如果一定要使用 cookie 实现自动登录，切记不要使用简单的用户名+密码 MD5 保存到 cookie，要把用户 ID、用户名、过期时间、IP、不固定的 salt 等一起考虑进去，这个当然要可逆，服务端要进行解密才能难是否用户自动登录有效。另外，cookie 要设置为 http only,这样就不能通过脚本访问 cookie，保证 cookie 的安全性。
- 不要让浏览器记住密码，虽然记住密码很方便，但也不安全，所以前端最好做控制。
- 一段时间类的尝试登录失败次数达到某个值，要锁定用户登录，如失败 5 次锁定 24 小时。或者间隔性锁定，如失败 3 次后锁定半小时，再失败 1 次锁定 1 小时，再失败 1 次锁定 24 小时。
- 设置会话有效期，比如登录后 10 分钟不操作就失效，要重新登录。
- 验证码使用，加上干扰线，防止计算机能够轻易识别，这样也可以防止黑客以程序的方式来尝试登录。
- 手机登录的一般使用短信验证码的，控制验证码的时效性，即验证码一次有效，一分钟内只能发送一次。

- 有必要的要采用单点登陆，如果允许用户多处登录的要给用户安全提醒。
- 重置密码最好通过邮箱发送一定时间内生效的重置链接，或者手机短信验证码，或者两者相结合的方法。像一般的大公司都有设计一个动态密码的东西，手机即一切，所以也要妥善保管自己的动态加密的 APP，最好加上指纹或手势。
- 设置用户可以登录的 IP，即 IP 白名单。像比如财务系统，限制财务人员只能在办公室登录系统。

先总结到这，没有真正安全的登录机制，正所谓道高一尺魔高一丈，我们要做到与时俱进。

## 21、常用的接口限流框架有哪些？

##### 常用的接口限流框架有：

- Guava
- Hystrix
- Sentinel
- netflix-concurrency-limits

## 22、给你两个文件 a 和 b，各存放 50 亿个 URL，怎么找出共同的 URL？

每个 URL 占 64 个字节，内存只有 4G。

我们来预算下 50 亿 URL 所需要的内存：

> 5000000000 _ 64 = 5G _ 64 = 320G

320G〉4G，所以是不可能全部加载到内存中进行查找的，可以使用分治算法，即把大文件拆分成小文件，搜索所有小文件相同的 URL，最后再合并结果。

参考方案如下：

1）分别遍历 a,b 两上大文件，一行行读取到内存。

2）把读取的 URL 进行 hash 取模拆分到小文件中：

> hash(URL) % 1000

这样你就能得到 1000 对小文件(a0, al, a2, , a999） 和(b0, b1, b2, ., b999)

这样每个文件的大小约为：

> 320G / 1000 = 300M 左右

3）遍历每对小文件

URL 相同的，hash 取模后肯定在相同的索引坐标文件中（比如：a0 vs b0, al vs b1.），不成对的说明不可能有相同的 URL（比如：a22 没有对应的 b22 文件，那 a22 里面的 URL 就全是唯一的）。

比如把 a0 文件所有 URL 放到 HashSet 中，再遍历 b0 文件，判断是否在 Set 中，如果在说明是相同的，然后再存储结果文件 r0 中。

遍历每对文件可以使用线程池多线程异步处理，但要考虑线程池数量，避免内存溢出。

4）所有相同 URL 的文件就存储到了 r0,r1,.….文件中了，然后再依次遍历合并写入到总结果文件中。

## 23、给你 10 个 1G 的日志文件，每行存放的是页面 URL，怎么按 URL 访问频次排序？

##### 参考方案一：

从题目我们得知，页面的 URL 是肯定有限的，只是大部分都是重复的访问日志，假设内存是大于 1G 的，所以我们可以按顺序把文件内容先全部加载到内存，然后建个 TreeMap(URL,count)进行存储排序就好了。

##### 参考方案二：

1）分别遍历每个日志文件，一行行读取到内存。

2）把读取的 URL 进行 hash 取模拆分：

> hash(URL) % 10

这样你就能得到 10 个文件（f0,f1, f2,., f9），访问日志相同的 URL 会落在同一个日志文件中。

3）遍历每个日志文件，一行行读取并存储到 TreeMap(URL,count) 进行排序，然后再将排序结果存储到对应的 r0, r1,..文件中。

4）读取所有排序好的文件内容，再使用归并排序即可。

## 24、给你一个 10G 的文件，内存只有 4G，怎么读取而不内存溢出？

传统的 JavaIO 读取文件，一次读取超过内存限制的大文件肯定会内存溢出。

##### 以下有几个参考方案：

1）使用`java.util.Scanner`读取文件，可以一行一行连续地读取到内存中。

2）使用 BufferedReaderreadLine 方法，它不会一次性将整个文件加载到内存中，它每次只读取文件的一小部分到预设的缓冲区中。

3）使用 NIO 的 ByteBuffer+ CharBuffer 来读取大文件，它也不会一次将整个文件加载到内存中，而是可以将文件的一部分加载到一个预设的缓冲区中。

4）使用 Apache commons-io 工具包中的方法：

```java
LineIterator it = Fileutils.lineIterator(file, "UTF-8");
try {
    while (it.hasNext()) {
        String line = it.nextline();
      // ...
    }finally {
        LineIterator.closeQuietly(it);
    }
}
```

## 25、为什么要分库分表？

##### 1）为了提升查询效率。

当一张 MySQL 的表数据达到几干万或以上时，查询的时间会变得越来越久，分库分表能大大减小单个数据库表的压力。

##### 2）为了能方便表扩展。

可以按照一定的规则把数据分摊到不同的 MySQL 数据库上。

## 26、分库分表会产生哪些问题？

1）分库分表维度的问题；

2）联合查询的问题；

3）引发分布式事务问题；

4）跨表查询统计问题；

等等。

## 27、分库分表常用的工具有哪些？

1. Mycat

2. sharding-sphere

3. TDDL

等等。。。。

## 28、MySQL 达到什么量需要分库分表？

根据阿里开发规范：

单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

## 29、分库分表有哪两种分法？

##### 1、水平分库分表

以**字段**为依据，按照一定策略，将一个**数据库表**中的数据拆分到多个**数据库表**中，每个表的表结构一样。

##### 2、垂直分库分表

以**字段**为依据，按照字段的重要性，将**一个数据库表**中的字段拆到不同的**数据库表**中，如：主表和扩展表，每个表的表结构不一样。

## 30、水平分库分表和垂直分库分表的区别？

##### 区别如下：

| 对比项   | 水平分库分表 | 垂直分库分表 |
| -------- | ------------ | ------------ |
| 表结构   | 一样         | 不一样       |
| 数据交集 | 没有         | 主键         |
| 数据条数 | 一条         | 多条         |

## 31、水平分库分表有哪些常用的方案？

##### 1、范围法

范围法则是使用数据区间的方式进行划分。

> 比如:1~500W, 500~1000W, 1000W~,

##### 2、哈希法

哈希法则是使用主键取模的方式进行划分。

> 比如：用户表使用 UID 分库分表，要分 100 个表，则可以使用 UID 对 100 对模（UID % 100），会得到 0 ～ 99。

## 32、按 UID 分库分表，按用户名如何查询？

##### 1、遍历所有表（不可取）

按用户 ID 分库分表后，如果按用户名查询就要查询所有的表，这大大影响效率，这种方法不可取。

##### 2、索引表法

建立一个索引表，映射用户 ID 和用户名之间的一对一关系。

> 如: t_user_uid_name (uid, user_name)

先根据用户名查询对应的 UID，就能定位到具体的用户表。

##### 3、索引缓存法

查索引表会影响数据库影响，可以把映射关系放到缓存（如：Redis）中，并且永不淘汰（除非销户）。

如果缓存未命中，则需要遍历一次所有表，再把映射关系放到缓存中。

##### 4、基因法

基因法，则是不需要查数据、查缓存，根据用户名设计一个 UID 生成方法策略。

> 如：32 位用户名 = 29 位唯— ID + 3 位基因

如果根据 UID 后 3 位分库分表，先根据用户名算出 3 位基因，就能定位到具体的用户表。

## 33、如何同时按用户 ID 和订单号分库分表？

##### 面试官：

> 分库分表只能对一个字段进行，现在有一个订单表，如何同时按订单号、用户 ID 进行分库分表呢？

##### 参考方案：

在我们的水平分库分表面试题中，有一个基因法，可以解答这个问题。

1）先按用户 ID 分库分表，比如：我们分 64 个表，即 UID % 64，表落在 0 ～ 63 之间；

2）订单号中加入用户 ID 的基因：

- 用户 ID 转化为二进制，比如：186(十进制) =10111010(二进制)
- 只取二进制中的后 6 位（**10111010**），因为只有 64 个表，**111111 的十进制为 63**
- 把 6 位二进制数融入到订单号中，比如：XXXXXXXXXX..**111010**

##### 演示：

假设现在是用户 ID（186）下单：

> 186 % 64 = 58
>
> 把订单号后 6 位 111010 转化为二进制为：58，58%64=58

成功，根据订单号、用户 ID 都能定位到具体的表。

> 注意：这种基因法融入了二进制，分表数也是必要是二制制的倍数，如：16、32、64、128、256..
>
> 如：要分 100 个左右的表，根据二进制基因法可以选 128

问题来了，我只要分 100 个表，怎么分库分表？

> 100 个表会落在 00 ～ 99 之间，根据基因法，同样可以把它融入到订单号中
>
> 如：XXXXXXXXXX..58

## 34、分库分表后如何做查询统计？

##### 参考方案：

每次统计要遍历所有表是不可取的。

新建一个统计库，及新建对应的统计表，如：小时报表、日报表、周报表、月报表等，在数据入库成功之后，起一个线程，把数据传入并重新计算一下本小时报表,再用定时任务每天凌晨生成日报表、月报表等。

查询统计时就可以直接查统计库对应的表，而不需要遍历所有库表。

## 35、垂查分库分表有什么好处？

##### 垂直分库分表有以下几点好处：

1、主表可以存储更多的数据，减轻主表的容量压力；

2、数据库缓冲池可以缓冲更多的数据，提升查询效率；

3、按某种规则进行表拓展，方便信息的维护；

## 36、垂直分库分表怎么分比较好？

##### 常见的拆分依据：

**1、主表：存储一些关键、核心的、内容较短、访问频率较高的数据**，比如：用户名、性别、年龄、电话等...

**2、扩展表：存储一些不重要的、内容较长、访问频率较低的数据**，比如：用户的爱好、教育、备用地址信息等..

## 37、什么是读写分离技术？

在 MySQL 主从同步架构中，传统的只有“主"数据库才提供读写操作服务，“从"数据库只作为备用。

##### 读写分离则是把“读”操作分离出去，由“从”数据库承担读操作服务，主数据库提供写操作服务。

## 38、为什么需要读写分离？

在主数据库中，如果读操作比较多，势必会影响写操作的吞吐量，给数据库带来性能瓶颈，**读写分离就是为了提升读写的性能，充分利用主、从数据库的资源。**

## 39、读写分离有哪些解决方案？

##### 主要有以下两种方案：

1、应用程序自己做负载均衡，程序自己选择该读哪个数据库，可以通过 Spring 动态数据源或者 MyBatis Plus 拦截的方式配置 insert/update/delete 操作走主库，而 select 操作走从库；

2、放在代理层做，比如：MySQL-Proxy，应用程序的连接是透明的;

## 40、读写分离常用的中间件有哪些？

##### 常用的有以下几个：

1、MySQL Proxy (官方推荐)

2、MyCat

3、Sharding JDBC

4、TDDL

5、Atlas

.....

## 41、读写分离可能导致什么问题？

读写分离最大的问题就是，主从同步如果发生延迟，从库读取的数据就是脏数据，就会造成**数据一致性问题**。

## 42、读写分离如何保证数据一致性？

一般的主从同步都是秒级的，但也可能出现延迟导致的数据一致性问题。

所以，强一致性的业务，或者出现从库如果查不到的情况，可以选择性强制读主库，这是最简单的方案，当然主库也可以等待从库同步完成之后主库才写成功，但是这样就是牺牲了性能而保证了数据一致性。

## 43、什么是微服务？

微服务是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的自己的环境中，可以单独构建和部署，服务之间互相协调，互相配合，各项服务在工作（和出现故障）时不会相互影响。

服务之间采用轻量级的通信机制互相沟通，通常是基于 HTTP 的 RESTfuI API。

![](/images/架构设计/43.jpg)

## 44、微服务架构有什么优势？

##### 可扩展性

在增加业务功能时，单一应用架构需要在原先架构的代码基础上做比较大的调整，而微服务架构只需要增加新的微服务节点，并调整与之有关联的微服务节点即可。在增加业务响应能力时，单一架构需要进行整体扩容，而微服务架构仅需要扩容响应能力不足的微服务节点。

##### 容错性

在系统发生故障时，单一应用架构需要进行整个系统的修复，涉及到代码的变更和应用的启停，而微服务架构仅仅需要针对有问题的服务进行代码的变更和服务的启停。其他服务可通过重试、熔断等机制实现应用层面的容错。

##### 技术选型灵活

微服务架构下，每个微服务节点可以根据完成需求功能的不同，自由选择最适合的技术栈，即使对单一的微服务节点进行重构，成本也非常低。

##### 开发运维效率更高

每个微服务节点都是一个单一进程，都专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模团队或者个人完全掌控，易于保持高可维护性和开发效率。

## 45、微服务架构有什么缺点？

- 开发人员要处理分布式系统的复杂性
- 多服务运维难度,随着服务的增加,运维的压力也在增大
- 系统部署依赖
- 服务间通信成本
- 数据一致性
- 系统集成测试
- 性能监控
- .....

## 46、SOA 和微服务架构有什么区别？

| 功能     | SOA                  | 微服务                       |
| -------- | -------------------- | ---------------------------- |
| 组件大小 | 大块业务逻辑         | 单独任务或小块业务逻辑       |
| 耦合     | 通常松耦合           | 总是松耦合                   |
| 公司架构 | 任何类型             | 小型、专注于功能交叉的团队   |
| 管理     | 着重中央管理         | 着重分散管理                 |
| 目标     | 确保应用能够交互操作 | 执行新功能，快速拓展开发团队 |

## 47、什么是服务治理？

服务治理主要用于对分布式系统中大量微服务进行有效控制管理。

## 48、什么是服务注册？

服务注册就是把微服务注册到注册中心，由注册中心统一维护管理，微服务会不定时发送心跳，注册中心会不定时检测并维护健康的服务实例，清除失效的实例。有了注册中心，这样就不需要写死服务地址了，也不需要我们自己维护服务的有效性了，保证我们获取的服务实例都是有效、正在运行中的健康实例。

## 49、注册中心有哪些实现方案？

##### 主流的注册中心有：

- Eureka (官方)
- Nacos (推荐)
- Consul
- CoreDNS
- Zookeeper
- ...

## 50、什么是配置中心？

一个系统中包含有各种各样的配置信息，如一个日志文件需要配置以下几个信息。

- 日志文件生成主目录
- 日志文件名称，不同的日志级别对应不同的文件
- 当前日志级别

还有其他各种业务参数、系统参数等，大多单一系统是直接把这些配置写死在配置文件中，当部署到测试、生产环境就再修改下配置文件，这样很容易出错，也不能灵活修改。还有就是系统变成分布式系统后，子系统越来越多，你要维护这些配置就变得越来越困难。

##### 配置中心能解决以下问题：

1）能在线灵活修改配置

2）能动态刷新配置

3）能根据不同环境配置

4）能统一管理维护配置

## 51、配置中心有哪些实现方案？

##### 主流的配置中心有：

- ##### Spring Cloud Config（官方）

- Apollo（携程开源的）

- Nacos （阿里开源的）

| 功能点       | Spring Cloud Config                                   | Apollo                                    | Nacos                                |
| ------------ | ----------------------------------------------------- | ----------------------------------------- | ------------------------------------ |
| 开源时间     | 2014.9                                                | 2016.5                                    | 2018.6                               |
| 配置实时推送 | 支持(Spring Cloud Bus)                                | 支持 (HTTP 长轮询 1S 内)                  | 支持 (HTTP 长轮询 1S 内)             |
| 版本管理     | 支持 (Git)                                            | 支持                                      | 支持                                 |
| 配置回滚     | 支持 (Git)                                            | 支持                                      | 支持                                 |
| 灰度发布     | 支持                                                  | 支持                                      | 待支持                               |
| 权限管理     | 支持                                                  | 支持                                      | 待支持                               |
| 多集群       | 支持                                                  | 支持                                      | 支持                                 |
| 多环境       | 支持                                                  | 支持                                      | 支持                                 |
| 监听查询     | 支持                                                  | 支持                                      | 支持                                 |
| 多语言       | 只支持 java                                           | Go、C++、java、Python、PHP、.net、OpenAPI | Python、Java、Node.js、OpenAPI       |
| 单机部署     | Config-server+Git+Spring Cloud Bus (支持配置实时推送) | Apollo-quikstart+MySQL                    | Nacos 单节点                         |
| 分布式部署   | Config-server+Git+MQ(部署复杂)                        | Config+Admin+Portal+MySQL(部署复杂)       | NacoS+MySQL(部署简单)                |
| 配置格式校验 | 不支持                                                | 支持                                      | 支持                                 |
| 通信协议     | HTTP 和 AMQP                                          | HTTP                                      | HTTP                                 |
| 数据一致性   | Git 保证数据一致性，Config-server 从 Git 读数据       | 数据库模拟消息队列，Apollo 定时读消息     | HTTP 异步通知                        |
| 单机读       | 7 (限流所致)                                          | 9000                                      | 15000                                |
| 单机写       | 5 (限流所致)                                          | 1100                                      | 1800                                 |
| 3 节点读     | 21 (限流所致)                                         | 27000                                     | 45000                                |
| 3 节点写     | 5(限流所致)                                           | 3300                                      | 5600                                 |
| 文档         | 详细                                                  | 详细                                      | 有待完善(目前只有 java 开发相关文档) |

## 52、什么是服务容错？

因为系统在拆分成微服务后，各个服务就需要通过 HTTP／RCP 形式交互，这样势必就会存在各种问题，比如网络故障、服务宕机、服务大量异常等，服务出现问题的情况下如果还继续涌入大量请求，以致大量请求堆积，这样就可能会造成微服务整体的不可用，这就是服务雪崩效应。

![](/images/架构设计/52.jpg)

所以服务需要有一定容错的能力，就是服务能有尽最大可能容纳错误情况发生的能力，在一定程度上保护好自己，也是保护好整体服务。

## 53、服务容错的方式有哪些？

##### 常用的服务容错有以下几种方式：

- 限流
- 熔断
- 降级
- 超时
- 重试
- 隔离

一般可以一起配合使用达到合适的效果。

## 54、服务容错有哪些技术组件？

常见的开源容错组件：

##### 1、Hystrix

Hystrix 是由 Netflix 开源的容错组件，目前已经停止维护。

##### 2、 Sentinel

Sentinel 是阿里巴巴开源的，也是 Spring Cloud Alibaba 微服务技术栈中的官方容错组件，本身在阿里内部已经被大规模采用，非常稳定。

##### 3、Resilience4J

Resilicence4J 是一个轻量级的容错库，也是 Spring Cloud 官方推荐的 Hystrix 替代产品，包含在 Spring Cloud CircuitBreaker 项目实现中。

## 55、什么是服务限流？

限流就是对服务进行流量控制，避免同时进入大量请求压垮服务，这也是最基本的防控手段，因为资源（最大连接线程数）是有限的，一旦占满系统就无法处理新的请求，服务不可用时就会连累其他服务。

限流后就能保证服务的正常运行，也能对后续超限流量进行有针对性的处理。

## 56、什么是服务超时？

服务超时即不要让服务一直等待，需要对每个服务设置超时时间，当达到超时时间还没响应时就自动断开连接，这样可以释放被调用服务的连接线程数，以防止大量线程阻塞而导致服务不可用。

## 57、什么是服务重试？

服务重试即对服务中的某些操作设置重试，当调用服务失败后可以自动重试下一个正常实例，以避免瞬间的网络故障而返回错误，提升整体用户体验。

## 58、什么是服务熔断？

服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。

熔断机制是应对服务雪崩效应的一种微服务链路保护机制，扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用快速返回"错误"的响应信息，当检测到该节点微服务响应正常后恢复调用链路。

## 59、什么是服务降级？

**服务降级**：就是对不怎么重要的服务进行低优先级的处理。

说白了，就是尽可能的把系统资源让给优先级高的服务。资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证网站核心功能服务的可用性，都要对某些服务降级处理。

## 60、服务降级有哪些实现方案？

##### 1、拒绝服务

判断应用来源，高峰时段拒绝低优先级应用的服务请求，保证核心应用正常工作。也可以随机拒绝请求，直接返回服务器繁忙，避免同时涌入过多的请求，这在电商秒杀时用的特别多。

##### 2、关闭服务

既然是高峰期，那么可以关闭一些冷门的或者边缘不重要的服务，给核心服务让出资源。如淘宝每年双 11 时候都会关闭如评价、确定收货等一些与下单核心业务无关的服务，以保证用户下单支付正常，当然肯定也会使用拒绝服务，0 点高峰期很多用户看到的基本是服务器繁忙。

## 61、什么是服务隔离？

隔离是指将系统/服务垂直拆分成不同的功能模块，模块之间不产生相互强依赖，即使某个模块出现故障也不会影响其他服务，把风险限制在某个服务之内，从而保障整体服务的稳定性。

## 62、服务隔离的方式有哪些？

常见的隔离方式有线程池隔离和信号量隔离。

##### 1）线程池隔离：

使用不同的线程池隔离服务中的接口（或者功能），不同的接口使用不同的线程池，从而不用担心一个接口故障影响整体服务；

##### 2）信号量隔离（较少使用）：

每次请求需要获取信号量，不超过最大线程数则信号量+1，信号量用完需要排队阻塞，获取失败则拒绝服务；

## 63、什么是服务雪崩？

多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 有调用其他的微服务，这就是所谓的"扇出"，如扇出的链路上某个微服务的调用响应式过长或者不可用，对微服务 A 的调用就会占用越来越多的系统资源，进而引起系统雪崩，所谓的"雪崩效应"。

## 64、什么是服务网关？

在微服务中，服务网关可以做到跨所有服务的路由转发、过滤和公共处理、统一接入、流量管控、安全防护、业务隔离等功能。

##### 下面是服务网关的大概作用图：

![](/images/架构设计/64_1.jpg)

看完这张图，或许你已经明白了服务网关的作用，及使用服务网关带来的诸多好处。

所以，既然服务网关有这么多作用，也是现在微服务套件中的必用组件，你还有什么理由不用服务网关呢？

##### 下图是 Spring Cloud 服务网关的套件图：

![](/images/架构设计/64_2.jpg)

Spring Cloud 使用了 Zuul/ Gateway 作为服务网关组件，图中 Open Service 即是服务网关，Service A,B 是内部实际的业务服务，通过 Open Service 对外进行内部服务的请求的路由、过滤等操作。

## 65、什么是灰度发布？

什么是灰度发布？

灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行 A/B testing，即让一部分用户继续用产品特性 A，部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。

灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。

灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。

灰度发布的意义

灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。

灰度发布步骤

1、定义目标

2、选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等

3、筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等

4、部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调

5、发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表

6、产品完善

7、新一轮灰度发布或完整发布

## 66、你怎么理解 laaS？

##### laaS

---

Infrastructure as a Service，基础设施即服务。

假如你现在要做一个网站，你肯定要有一台服务器或者虚拟机，要么自己搭建，要么买服务器运营商的。

说白了，laaS 就是解决企业硬件问题的，包括服务器、存储设备、网络设备等基础设施。基础设施有了，你就可以搭建环境了。

## 67、你怎么理解 SaaS？

##### SaaS

---

Software as a Service，软件即服务。

你现在想做一个网站，你不会做，你只要购买别人的成熟软件，配置几下就能使用了。

说白了就是租售软件的，你不用租用服务，开发软件等费时间的工作，你直接购买别人的软件通过互联网就能使用，也不需要本地安装，也就是软件即服务的意思，你出钱，别人出软件服务。

## 68、你怎么理解 PaaS？

##### PaaS

---

Platform as a Service， 平台即服务。

假如你现在要做一个网站，你不想自己买服务器搭环境，你就直接购买别人的 PaaS 服务。

PaaS 一般会为企业解决硬件的租赁问题，以及操作系统的选装，开发测试环境的搭建，及各种编程语言的选装等，提供一个运行的直接用的软件平台。有了 PaaS 你就可以在上面做开发工作了，当然，一些别的程序及软件还得你自己安装配置。

## 69、Iaas, PaaS, SaaS 的区别?

如图所示：

![](/images/架构设计/69.jpg)

## 70、你怎么理解 FaaS？

##### FaaS

---

Function as a Service，功能/函数即服务。

FaaS 是无状态的，每个函数就是一个服务，这样就可以让各个模块/函数间进行充分解耦，这也就是架构设计原则中的单一职责原则，它部署在云端，也是 Serverless 架构中的一种。

以电商为例，可以将用户、商品、下单等拆分成微服务，FaaS 就可以看作是比微服务更细小的单元，比如：减库存操作，就可以包装成一个函数部署到云端。

具体可以看这个面试题中的示例： Spring Cloud Function 是什么?

## 71、你怎么理解 BaaS？

##### BaaS

---

一般有以下两种说法：

##### Backend as a Service，后端即服务

即为移动/Web 应用提供后端云服务，可以理解为 PaaS 和 SaaS 之间的一种服务，它也是 Serverless 架构中的一种。

##### Blockchain as a Service，区块链即服务

即区块链+云计算打造的区块链云服务。

## 72、你怎么理解 Serverless？

Serverless：即无服务器，是目前正在发力的一种云原生架构模式。

它并不是指不需要服务器，而是指用户无需关心底层资源，只需要关注业务即可，它具有资源编排、自动伸缩、事件驱动等能力，覆盖编码-调试-测试-部署等全生命周期，减少维护基础设施的成本和风险，利用云的能力可以更迅速的扩展。

目前最常见的 Serverless 实现方案为:

> FaaS（函数即服务）+BaaS（后端即服务）

## 73、Serverless 和 FaaS、BaaS 的区别？

Serverless 是一种架构模式，FaaS 和 BaaS 都属于 Serverless 架构不同的表现形式，也可以说 FaaS 和 BaaS 是 Serverless 架构，它们是相辅相成的。

## 74、POJO, DO, DTO, DAO, BO, VO 都是什么？

POJO、PO、DTO、DAO、BO、VO 这些概念作为 Java 开发来说应该全部或者部分遇到过，作为架构师的你想必更是清楚这些概念在不同场景的应用。

下面我逐一介绍一下，想必你会更深刻。

##### POJO

全称为：Plain Ordinary Java Object，即简单普通的 Java 对象，包括只有 setter/getter/toString 的简单类，包括 DO/ DTO/ BO/VO 等等。

##### DO

全称为：Data Object，即数据对象，与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

##### DTO

全称为：Data Transfer Object，即数据传输对象。

一般用于向数据层外围提供仅需的数据，如查询一个表有 50 个字段，界面或服务只需要用到其中的某些字段，DTO 就包装出去的对象。可用于隐藏数据层字段定义，也可以提高系统性能，减少不必要字段的传输损耗。

##### DAO

全称为：Data Access Object，即数据访问对象。

就是一般所说的 DAO 层，用于连接数据库与外层之间的桥梁，并且持久化数据层对象。

##### BO

全称为：Business Object，即业务对象。

一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用 BO 类组合封装所有的对象一并传递。

##### VO

全称为：Value Object，有的也称为 View Object，即值对象或页面对象。

一般用于 web 层向 view 层封装并提供需要展现的数据。

## 75、DO 与 DTO 之间怎么互相转换？

常用的做法有以下几种：

- get/set
- 构造器
- BeanUtils 工具类
- Builder 模式
- MapStruct 框架 (带 IDEA 插件)

## 76、什么是 SLA？

**SLA**：服务等级协议（简称：SLA，全称：service level agreement），是在一定开销下为保障服务的性能和可用性，SLA 的概念，对互联网公司来说就是对提供的服务可用性的一个标准、保证。

我们平常经常看到互联网公司喊口号，我们今年一定要做到 3 个 9、4 个 9，即：99.9%、99.99%，甚至还有 5 个 9，即 99.999%，这就是指 SLA。

## 77、怎么理解 SLA 中的 99.9%、99.99%？

##### 这么多 9 是怎么计算的呢？

全年拿 365 天做计算吧，看看几个 9 要停机多久时间做能才能达到！

> 1 年 =365 天= 8760 小时
>
> 99.9 = 8760 _ 0.1% = 8760 _ 0.001 = 8.76 小时
>
> 99.99 = 8760 _ 0.0001 = 0.876 小时 = 0.876 _ 60 = 52.6 分钟
>
> 99.999 = 8760 _ 0.00001 = 0.0876 小时 = 0.0876 _ 60 = 5.26 分钟

从以上看来，全年停机 5.26 分钟才能做到 99.999%，即 5 个 9。依此类推，要达到 6 个 9 及更多 9，可说是非常难了吧。

##### 怎么做到更多的 9

每个公司对几个 9 的定义都不一样，互联网公司至少都是 99.99 吧。像一些政府网站，如社保公积金等，经常故障服务不可用，能做到 99.9 就不错了。

如果我们提供的服务可用性越低，意味着造成的损失也越大，别的不说，如果是特别重要的时刻，或许就在某一分钟，你可能就会因服务不可用而丢掉一笔大的订单，这都是始料未及的。所以，只要尽可能的提升 SLA 可用性才能最大化的提高企业生产力。

要做到更多的 9，就要不断的监控自己的服务，服务挂掉能及时恢复服务。就像开车出远门，首先得检查轮胎，同时还得准备一个备胎一样的道理。

## 78、什么是重复请求？怎么产生的？

重复请求是指在某个时间段内，**服务端同时接收到了两个以上的相同请求**，如果不妥善处理，就会导致数据的不一致性，甚至会造成一些安全风险。

常见的重复请求产生原因包括以下几种：

##### 1）网络问题

调用方有重试机制，当网络不稳定、超时或延迟较高时，如果请求没有收到正确的响应，调用方可能会重试发送。

##### 2）用户重复点击

如果前端页面提交按钮未做重复点击处理，可能造成用户多次点击。

##### 3）系统设计问题

比如一个分布式定时任务系统，部署了多台服务器，如果多台服务器未做正确的分片处理，造成多台服务器同时处理同一个任务，就会造成任务重复执行，导致重复请求。

## 79、怎么处理重复请求？有哪些方案？

处理重复请求的常见方案：

##### 1、分布式锁

使用某个 ID 作为分布式锁，哪个请求能获取到锁就正确处理业务逻辑，否则拦截请求。

##### 2、前端防止重复提交

用户在第一次发送请求时，及时禁用提交按钮，可防止用户连续多次点击提交按钮。

##### 3、后端去重

后端在处理请求时，可以使用数据库、BitMap 等方案来存储已处理请求的标识，从而实现去重。

##### 4、幂等性处理

实现被调用方的幂等性，多次重复请求，返回同样的结果。

## 80、什么是幂等性？

**一个幂等性操作的特点是**：一般是指服务、接口的调用，相同的参数任意多次执行，所产生的影响均与一次执行的影响相同。

> ##### 举个接口回调的例子：
>
> 微信支付成功后，把支付结果通知给商户，如果通知多次，商户应该只处理一次，并且每次返回的结果一样，不然就会造成数据不一致问题。

## 81、怎么保证接口幂等性？有哪些方案？

实现接口 幂等性 的常用方案：

##### 1、唯一约束

如果是数据新增操作，数据库侧一般都会设置唯一约束，多次请求只会插入一条数据，多余的请求会报错，如果报错则返回之前请求的结果。

> 不建议使用，多次请求会频繁引发数据库端的错误。

##### 2、数据比对

接口在处理数据时，检查数据是否存在，或者要更新的数据是否和当前数据完全一致，如果匹配，则返回已有的数据结果，否则插入/更新数据。

> 需要结合分布式锁或者其他方案来实现，防止并发重复请求。

##### 3、数据库乐观锁

在请求接口时，传递一个版本号，在更新数据的 SQL 中，直接用版本号作为 where 条件，如果版本号匹配就能更新成功并返回 1，如果返回 O 说明更新不成功，则返回已有的数据结果。

## 82、怎么优化接口的性能？有哪些方案？

##### 1、异步处理

比如无需返回结果的请求，可以使用异步处理，直接返回。

比如业务逻辑中涉及与同步结果无关的逻辑，如：消息通知、记录日志等，这些逻辑可以放到异步执行，比如新起一个线程异步执行，或者发送消息到消息队列 MQ 中。

##### 2、批量处理

即合并多次请求，一次处理多次请求的数据。

##### 3、优化程序及组件

比如优化程序的锁、JVM 的性能，避免大事务锁及频繁垃圾回收。比如把热点数据放到缓存中，避免多次查询数据库。

##### 4、优化数据库

比如大表查询需要创建索引、使用分页查询。

比如只读的请求可以使用只读事务等。

更多.....

> 真正的优化措施，需要找到接口真正慢的原因再进行针对性优化。

## 83、什么是 Session Stick？

**Session Stick** 也叫会话粘滞、粘性会话，或者会话保持，即负载均衡（比如：Nginx）始终将同一个客户端的请求都转发到同一台服务器（比如：Tomcat）。

如图所示：

![](/images/架构设计/83.jpg)

## 84、Session Stick 有什么缺点？

Session Stick 的一个缺点就是，如果客户端在请求过程中对应的服务器挂了，服务器 Session 又没有做持久化机制，那么会话数据可能就挂失了，就像单机 Session 一样，如果服务器挂了，那登录都登录不了了。

如果有分布式系统，最好就是采用分布式 Session。

## 85、什么是页面静态化技术？

页面静态化技术是指 **将原本是动态内容的网页提前生成静态页面**，比如之前是：

> http://ww.javastack.cn/topic/java?id=10

页面静态化之后：

> http://wwwjavastack.cn/topic/java10.html

生成静态页面可以加速页面的访问，提升用户体验，但只适用于不怎么变化的页面（如：秒杀页面），生成的数据量、页面数量不宜过大，不然会影响性能。

## 86、如何实现页面静态化？

常用的页面静态化技术是：**FreeMarker**，根据其模板引擎生成静态页面。

## 87、什么是规则引擎？

规则引引擎（Rule Engine）是一个用于执行基于规则逻辑的引擎，它提供了一种声明性的方式来定义和管理业务规则，以便自动化决策和执行复杂的业务逻辑。

规则引引擎通过规则管理器来管理和存储规则，规则执行引擎负责根据规则的定义和条件执行规则，并产生相应的结果。

规则编辑器通常提供了一种可视化的界面，使业务人员可以直观地定义和编辑规则，而不需要编写复杂的代码。

## 88、为什么要用规则引擎？

我们在开发复杂的业务代码时，应用程序的条件规则和业务逻辑代码互相嵌套在一起，十分错综复杂，比如以下示例：

![](/images/架构设计/88.jpg)

if 条件过多，代码很不优雅，当然可以用策略模式解决，但是如果条件非常多又非常复杂，策略模式也会非常臃肿。

另外，如果要改变一个规则的话，需要修改代码，同时需要重新发布，对于应用程序来说就是个灾难，维护成本级高，可拓展性极差，所以需要规则引擎。

规则引引擎的主要目的是将应用程序的**规则代码**与**业务逻辑代码**相分离，业务人员可以以可视化的方式定义和修改规则，而无需修改应用程序代码，这样就可以实现更灵活、可维护和可配置的业务规则管理。

##### 说下规则的引擎的优点：

1、业务规则和业务逻辑代码相分离，十分优雅，更方便扩展。

2、业务人员和开发人员可以各司其职，业务人员修改规则，开发人员不用改代码，不用重新发布系统，迭代速度更快。

## 89、规则引擎的应用场景有哪些？

下面举几个规则引引擎的应用场景例子：

##### 1、促销活动规则

> 比如有一个电子商务平台，需要根据促销活动的不同规则来计算商品的折扣价格。

使用规则引引擎可以将促销规则与业务逻辑分离，并实现灵活的促销策略

##### 2、大数据杀熟

> 比如我们常见的一个大数据杀熟问题，不同的地域、不同年龄段的人群、不同的手机设备、不同的消费习惯等，同一个商品不同用户看到不同的价格

使用规则引擎可以将定价规则与应用程序解耦，实现更灵活的定价管理。

##### 3、客户评级规则

> 比如有一个客户评级系统，根据客户的交易金额、交易次数和信用评估等指标，为客户进行评级。

使用规则引擎可以将评级规则与应用程序解耦，使评级规则的管理和调整更加灵活。

## 90、常用的规则引擎系统有哪些？

Java 常用的规则引|擎系统有：

- ##### Drools (开源，使用最广泛)

- Easy Rules (开源)

- QLExpress （阿里巴巴开源)

- URule (部分开源+商业)

## 91、什么是多租户架构？

多租户架构（Multi-Tenant Architecture）是一种软件架构模式，它允许单个软件实例同时为多个租户（Tenant）提供服务。

![](/images/架构设计/91.jpg)

> 租户可以是组织、企业、用户群或任何需要独立环境和数据隔离的实体。

在多租户架构中，所有租户共享同一个软件实例，但每个租户都拥有自己独立的数据、配置和用户界面，租户之间的数据和操作被严格隔离，一个租户无法访问或干扰其他租户的数据。通过这种方式，多租户架构实现了资源的共享和效率提升。

## 92、多租户架构的应用场景？

多租户架构适用于在同一个应用程序下需要将不同实体或组织的数据和操作隔离的场景，它提供了资源共享、简化维护和灵活性等优势，适合许多应用领域，尤其是在云计算和共享服务的环境中。

多租户架构适用的应用场景举例：

##### 1、软件即服务 (SaaS)

多租户架构是 SaaS 应用程序的核心，允许供应商通过单个软件实例为多个客户提供服务。

> 每个客户被视为一个租户，并且他们的数据和配置在逻辑上是相互隔离的。

##### 2、企业应用程序

多租户架构可用于构建企业级应用程序，以支持不同部门、分公司或业务单位之间的数据隔离和定制需求。

> 每个部门或业务单位可以被视为一个租户，共享相同的软件实例。

##### 3、教育管理系统

多租户架构适用于教育管理系统，允许学校、大学或培训机构在同一个平台上管理学生信息、课程和成绩，但保持彼此之间的数据隔离。

......

## 93、多租户架构怎么实现？说说方案

多租户架构根据不同的需求涉及多个方面，主要包括数据隔离、租户识别、权限控制等，另外，多租户架构可能还需要解决配置管理、拓展性、性能、多租户的管理维护等方面的问题。

#### 1、数据隔离

---

##### 1.1 数据库级别隔离

解决方案：

- 为每个租户创建独立的数据库实例；
- 在应用程序中使用不同的数据库连接配置来连接到相应的租户数据库；
- 确保每个租户只能访问自己的数据库，防止跨租户的数据访问；

这个可以使用 Spring 中的动态数据源实现，或者采用第三方数据源项目。

##### 1.2 模式（Schema）级别隔离

解决方案：

- 在单个数据库中为每个租户创建独立的模式；
- 使用数据库连接时，在连接字符串中指定不同的模式，以区分租户；
- 确保应用程序只能访问当前租户对应的模式，实现数据隔离；

这个可以使用 Spring 中的动态数据源实现，或者采用第三方数据源项目。

##### 1.3 行级别隔离

解决方案：

- 在数据库中的每个表中添加租户 ID 列，标识每条数据所属的租户；
- 在查询中始终包含租户 ID 的条件，以限制查询结果仅包含当前租户的数据；
- 确保应用程序对每个查询都应用正确的租户过滤器，防止跨租户的数据泄漏；

可以使用 MyBatis-Plus 的多租户插件，它提供了 Tenantld 行级处理租户的功能：

![](/images/架构设计/93.jpg)

TenantLineHandler 接口定义了一些获取租户 ID、获取租户字段名、忽略表的一些方法，然后需要自己去实现这个接口。

##### 2、租户识别

---

解决方案：

对于每个请求，确定当前租户的标识符，可以是在请求头或参数中传递租户标识，并在后续操作中使用该标识进行数据隔离和权限控制。

##### 3、权限控制

---

解决方案：

- 实施细粒度的权限控制，确保每个租户只能访问其拥有权限的资源和功能；
- 根据租户标识和权限配置，在应用程序中进行权限检查和访问控制；

可以使用 ThreadLocal 存储不同租户的标识符，然后使用 Spring Security 对租户进行权限控制

## 94、什么是中台？

中台最早是由阿里在 2015 年提出的“**大中台、小前台**"概念，灵感来源于芬兰的一家游戏公司 Supercell，该公司开创了中台的玩法。

![](/images/架构设计/94.jpg)

中台就是介于**前台和后台**之间的平台，主要是为**前台**而生的，能服务前台规模化的创新。

## 95、中台可以分为哪些层面的中台？

##### 1、业务中台

业务中台就是将系统中的核心业务（如电商中的商品、客户、支付、物流..）组成一个服务，供其他业务使用。

##### 2、数据中台

数据中台则是与业务中台相辅相成，提供对数据的收集、处理、分析、报表、治理等。

##### 3、技术中台

技术中台是面向底层的技术基础服务，如：安全、权限、认证、消息通知等。

## 96、为什么要建立中台？

以往的架构，前台是与后台直接交互，如果要拓展新的前台，就可能要大量改动后台，不利于后台的稳定性。

中台就是解决这个问题的，中台充当前台和后台的对接层，**将核心的业务全部归集到中台**，在中台实现高效敏捷的管理，解决了因为前端渠道的增加而带来的各种后端适配问题，也打通了企业的数据、业务、服务，将不同的业务、不同渠道的数据者统一管理，避免了重复工作量，提高系统效率。

**中台的作用总结**：敏捷、解耦、利用。

## 97、什么样的公司适合建中台？

这要看公司有否有多条不同的业务线或产品，其产品只是面向的用户群体或场景不同而已，而底层的业务逻辑是一样的，这样的公司就适合建立中台。

##### 总结：中台一般适用于有多条业务线的中大型公司，小公司不太建议，因为建中台也得烧不少钱，别折腾！

> 大公司上中台，钱没了.
>
> 小公司上中台，公司没了。。

## 98、什么是 DDD？

DDD 全称：Domain Driven Design，即领域驱动设计。

DDD 不是指具体架构，而是一种架构设计方法论，或者一种软件开发方法，是一种处理高度复杂领域的设计思想，它通过业务边界划分将复杂业务领域问题简单化,划分出清晰的业务领域和应用边界，从而可以很容易地实现微服务的架构演进。

## 99、什么是云计算？

云计算就是指提供计算服务，包括**服务器、存储、数据库、网络、软件**等服务，通过云的方式可快速提供及弹性伸缩等。

云计算服务通常只需要按量付费，从而帮助企业降低运营成本，使基础设施更有效地运行，并可以根据自身业务需求的变化，灵活调整对云计算服务的使用。

## 100、云计算有哪几种部署方式？

##### 部署云计算资源有三种不同的方式：

1、公共云

2、私有云

3、混合云

## 101、云计算有哪几种服务类型？

##### 云计算服务类型：

1、基础设施即服务 (laaS)

2、平台即服务(PaaS)

3、软件即服务(SaaS)

具体可以参考这个面试题：《你怎么理解 SaaS,PaaS,laaS?》

## 102、什么是云原生？

##### 云原生：Cloud Native

> Cloud：表示应用运行在云环境中；
>
> Native：表示应用为云环境设计而生；

云原生是以 **容器、微服务、服务网络** 等技术为基础建立的一套云技术架构体系，使用云原生技术后，我们就不需考虑底层的技术实现，可以充分发挥云平台的弹性和分布式优势，实现快速部署、按需伸缩、不停机交付等。

以云环境设计的应用就是云原生应用。

## 103、云原生都包含哪些技术要点？

云原生基金会：

> https://www.cncf.io/

##### 云原生最新技术要点：

- 容器
- 服务网络
- 微服务
- 固定基础设施
- 申明式 API

## 104、云原生都涉及到哪些具体的技术？

##### 云原生包含的核心技术：

- 容器(Docker)
- 服务网络 (Ilstio、Consoul 等)
- 微服务 (Spring Cloud、Dubbo、Kong 等)
- 固定基础设施(laaS、PaaS、SaaS、Kubernates)
- 申明式 API

## 105、云原生和云计算有什么关系？

云原生本质上也是一种与云计算相同的计算方式，云原生技术可以充分利用云计算的优势在公有云、私有云和混合云等新型动态环境中构建和运行可弹性扩展的应用。

所以说，**云原生是云计算的更上一层的理念**，云原生技术和应用的发展同时也推动了云计算相关服务的发展。
