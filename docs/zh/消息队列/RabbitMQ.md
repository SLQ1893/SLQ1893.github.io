## 1、RabbitMQ 是什么？

RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（面向消息的中间件）。

RabbitMQ 服务器是用 ErLang 语言编写的，而集群和故障转移是构建在开放电信平台框架上的，所有主要的编程语言均有与代理接口通讯的客户端库。

## 2、RabbitMQ 有哪些优点？

##### 1、可靠性好

RabbitMQ 支持消息持久化，保证了消息的稳定可靠性；

##### 2、支持高并发

RabbitMQ 使用了 Erlang 开发语言，天生支持高并发、高可用特性；

##### 3、集群部署简单

RabbitMQ 使用了 Erlang 开发语言，Erlang 使 RabbitMQ 集群部署变得非常简单；

##### 4、社区活跃度高

因为 RabbitMQ 应用比较广泛，所以社区的活跃度也很高；

因为社区活跃，所以学习资料比较多，解决问题的成本也很低；

##### 5、支持多种语言

主流的编程语言都支持，如 Java、.NET、PHP、Python、JavaScript、Ruby、Go 等；

## 3、RabbitMQ 有哪些重要的组件？

RabbitMQ 包含的重要组件有：

- ConnectionFactory（连接管理器）：用于应用程序与 RabbitMQ 之间建立连接的管理器；
- Channel（信道）：消息推送时使用的通道；
- Exchange（交换器）：用于分发消息；
- Queue（队列）：用于存储生产者写入的消息；
- RoutingKey（路由键）：用于交换器把生成者的消息写入到不同的队列；
- BindingKey（绑定键）：用于将交换器绑定到不同的队列；

## 4、RabbitMQ 有哪些重要的角色？

##### RabbitMQ 有 3 个重要的角色：

###### 1、生产者

消息的创建者，负责创建和推送数据到消息服务器；

###### 2、消费者

消息的接收方，用于处理数据和确认消息；

###### 3、代理

就是 RabbitMQ 本身，本身不生产消息，只是扮演投递的角色。

## 5、RabbitMQ 交换器类型有哪些？

RabbitMQ 交换器（Exchange）模式：

- **direct（默认）**：路由模式，发送消息时指定不同的 Routing Key，交换机会根据不同的 Routing Key 将消息写入到不同的队列中；
- **fanout**：广播模式，交换器会将消息发送到它绑定的所有队列中，也是性能最好、使用最多的模式；
- **headers**：交换器使用消息内容中的 headers 属性进行匹配，性能较差，几乎不用；
- **topic**：匹配模式，和路由模式差不多，但可以允许使用通配符匹配来分发消息；

## 6、RabbitMQ 消息基于什么传输？

RabbitMQ 是基于信道 Channel 的方式来传输数据，排除了使用 TCP 链接来进行数据的传输，因为 TCP 链接创建和销毁对于系统性能的开销比较大，且并发能力受系统资源的限制，这样很容易造成 RabbitMQ 的性能瓶颈。

消费者链接 RabbitMQ 其实就是一个 TCP 链接，一但链接创建成功之后，就会基于链接创建 Channel，每个线程把持一个 Channel，Channel 复用 TCP 链接，减少了系统创建和销毁链接的消耗，提高了性能。

## 7、RabbitMQ 怎么避免消息丢失？

##### 可以采取以下几个措施：

1、消息持久化

2、消息手动确认机制

3、消息事务机制

4、设置集群镜像模式

5、消息补偿机制

## 8、RabbitMQ 怎么保证消息的稳定性？

可以使用以下设置：

（1）消息事务机制

（2）消息确认机制

## 9、RabbitMQ 支持消息顺序性吗？

RabbitMQ**不支持**消息顺序性。

## 10、RabbitMQ 如何保证消息的顺序性？

RabbitMQ 本身不支持消息的顺序性，但可以通过单线程发送、单线程消费，并且采用延迟队列、优先级队列等一些高级功能整体配合才能实现消息的顺序性。

## 11、RabbitMQ 支持消息幂等性吗？

RabbitMQ**不支持**消息幂等性。

## 12、RabbitMQ 支持事务消息吗？

支持，主要是对信道（Channel）的设置。

主要方法有以下三个：

1、声明启动事务模式：channel.txSelect

2、提交事务：channel.txCommit

3、回滚事务：channel.txRollback

## 13、RabbitMQ 事务消息在什么情况下无效？

RabbitMQ 如果是消息自动确认模式（autoAck=true），RabbitMQ 会直接把消息从队列中移除，即使后面事务回滚也不能起到任何作用，**所以事务在自动消费确认的时候是无效的**。

## 14、RabbitMQ 接收到消息之后必须消费吗？

RabbitMQ 接收到消息后可以不消费，在消息确认消费之前可以做两件事：

##### 1、拒绝消息消费

使用 channel.basicReject 方法，消息可以被分配给其他消费者。

##### 2、设置为死信队列

死信队列可用于存放被拒绝的消息队列。

## 15、RabbitMQ 如何确认消息已被消费？

RabbitMQ 可以使用 ack 消息确认的方式确认消息被消费了，可根据自己的实际业务，选择 channel.basicAck()方法手动确认消息被消费。

## 16、RabbitMQ 消息持久化的条件？

RabbitMQ 消息持久化，必须满足 4 个条件：

##### 1、队列必须开启消息持久化

> channel.queueDeclare(x, **true**, false, false, null)

第二个参数设置 durable 为 true，表示开启队列持久化。

##### 2、消息推送投递模式必须开启持久化

> channel.basicPublish(x, x, MessageProperties.PERSISTENTTEXTPLAIN, x)

在三个参数设置投递模式 deliveryMode 为 2，表示以纯文本存储到磁盘。

##### 3、消息已经送达持久化交换器

##### 4、消息已经送达持久化的队列

## 17、RabbitMQ 的持久化包括几部分？

##### RabbitMQ 持久化包括三部分：

1、交换器（Exchange）持久化

2、队列（Queue）持久化

3、消息（Message）持久化

## 18、RabbitMQ 什么情况消息会变成死信？

##### 发生死信的情况有：

- 消息被拒绝
- 消息的存活时间（TTL）已过期
- 队列已满，无法添加新消息

## 19、RabbitMQ 死信消息还能被处理吗？

**如果 RabbitMQ 配置了死信队列**，当消息变成死信后，就会将消息重新投递到另一个死信交换器，由该死信交换器再重定向到一个死信队列，后续再重新处理该消息。

如果 RabbitMQ 没有配置死信队列，则该消息将会被丢弃。

## 20、RabbitMQ 中的死信队列是什么？

**死信：Dead Letter**，就是指无法被消费的消息，死信队列则是暂存死信消息的队列。

## 21、RabbitMQ 死信队列有什么用？

避免消息没有被正确消费而被丢弃，在比较重要的业务中建议使用。

通过配置 RabbitMQ 死信队列，可以让未正确消费的消息暂存到另一个死信队列中，待排查清楚问题后再来处理这些死信消息。

## 22、RabbitMQ 如何处理死信队列中的消息？

##### 处理死信队列的方式：

1、通过编写代码等其他方式人工处理

2、系统恢复正常后，把死信队列中的消息移到正常队列中去处理。

## 23、RabbitMQ 队列中的消息是否有数量限制？

可以认为是无限制，因为取决于服务器的内存，但是消息过多会导致消息处理效率下降或者消息积压。

## 24、RabbitMQ 支持优先队列吗？

**RabbitMQ 支持优先队列。**

## 25、RabbitMQ 支持延迟队列吗？

**RabbitMQ 支持延迟队列。**

## 26、RabbitMQ 怎么实现消息延迟推送？

RabbitMQ 3.6.x 之前，一般采用死信队列 + TTL 过期时间来实现延迟队列。

RabbitMQ 3.6.x 开始，RabbitMQ 官方提供了延迟队列的插件，可以下载到 RabbitMQ 根目录下的 plugins 目录下使用。

## 27、RabbitMQ 消息是推模式，还是拉模式？

RabbitMQ 支持推、拉两个模式，即支持客户端主动拉取消息、以及服务端推送消息两种模式。
