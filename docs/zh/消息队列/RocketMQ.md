## 1、RocketMQ 是什么？

Apache RocketMQ 是阿里巴巴开源的一款消息中间件，现在已成为 Apache 顶级项目。它同时也是一个分布式消息和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可扩展性。

官方网站：

> https://rocketmq.apache.org/

其作为 Spring Cloud Alibaba 中的一员，经过历年淘宝双 11 历练，稳定性、性能方面都是很出色的，使用也简单。

##### 它具有以下特点：

- 消息发送和消费的严格顺序
- 丰富的消息拉取模式
- 消费者的横向可扩展性
- 实时消息订阅
- 亿级消息积累能力

## 2、为什么选择 RocketMQ？

在阿里系统中，ActiceMQ 随着队列和虚拟主题使用的增加，IO 模块会达到一个瓶颈，Kafka 也不符合阿里要求，所以阿里发明了一个全新的消息系统 RocketMQ，覆盖从传统的 pub/sub 场景到高容量的实时零误差的交易系统。

RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被广泛采用，历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。

## 3、RocketMQ 的架构介绍一下？

以下是 RocketMQ 4.0 vs 5.0 的架构模式对比：

![](/images/RocketMQ/3.jpg)

RocketMQ 自诞生以来就一直坚持简洁架构，比如元数据采用最终一致性设计，只引入了几百行代码的无状态 NameSrv 组件。

RocketMQ 5.0 引入了全新的弹性无状态代理模式，将当前的 Broker 职责进行拆分，新增了 Proxy 独立无状态的代理角色，对于客户端协议适配、权限管理、消费管理等计算逻辑进行抽离，Broker 则继续专注于存储能力的持续优化。

RocketMQ 5.0 全新模式可以更好地实现在云环境的资源弹性调度，和 4.0 的极简架构模式是相容相通的，5.0 的代理架构完全可以以 Local 模式运行，实现与 4.0 架构完全一致的效果。

## 4、RocketMQ 的领域模型介绍下？

![](/images/RocketMQ/4.jpg)

Apache RocketMQ 中消息的生命周期主要分为以下三部分：

- 消息生产
- 消息存储
- 消息消费

生产者负责生产消息并发送至 RocketMQ 服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。

不建议在生产环境中通过频繁修改订阅关系来实现业务逻辑的变更，这样可能会导致客户端一直处于负载均衡调整和变更的过程，从而影响消息接收。

## 5、RocketMQ 支持的消息传输模型？

RocketMQ 使用的传输模型为**发布/订阅**模型。

![](/images/RocketMQ/5.jpg)

（1）生产者发送消息到 Apache RocketMQ 服务端；

（2）消息按照到达 Apache RocketMQ 服务端的顺序存储到主题的队列中；

（3）消费者按照指定的订阅关系从 Apache RocketMQ 服务端中获取消息并消费。

同一个主题内的消息可以被多个消费者处理，每个订阅的消费者都可以拿到全量消息。

## 6、RocketMQ 5.0 有哪些改变或新特性？

RocketMQ 5.0 新特性一览：

- 全新的架构，Broker 角色拆分成 Broker + Proxy；
- 重新设计了轻量 API 和多语言 SDK；
- 支持消息的流式处理和轻计算；

## 7、RocketMQ 的主题拆分设计，应遵循那些原则？

RocketMQ 的主题拆分设计应遵循**大类统一原则**，即将相同业务域内同一功能属性的消息划分为同一个主题，可以从以下角度考虑拆分粒度：

##### 1、消息类型是否一致

不同类型的消息使用不同的主题，如顺序消息和普通消息需要使用不同的主题。

##### 2、消息业务有是否关联

业务没有直接关联需要使用不同的消息主题，如淘宝交易消息和盒马物流消息没有业务交集，他们需要使用不同的主题。

##### 3、消息量级是否一样

数量级不同或时效性不同的业务消息建议使用不同的主题，例如某些业务消息量很小但是时效性要求很强，如果跟某些万亿级消息量的业务使用同一个主题，会增加消息的等待时长。

## 8、一个线上商品购买场景，RocketMQ 主题该怎么设计比较好？

**如果是线上商品购买场景，RocketMQ 主题可以这么设计：**

- 订单交易（创建、支付、取消等流程）的消息使用一个主题；
- 物流相关消息使用一个主题；
- 积分管理相关的消息再使用一个主题；

### 9、RocketMQ 主题拆分不合理会有什么后果？

##### RocketMQ 主题拆分不合理的后果：

##### 1、拆分粒度过粗

会导致业务隔离性差，不利于独立运维和故障处理。

> 错误示例：
>
> 将所有交易消息和物流消息都共用一个主题，将会混乱不堪。

##### 2、拆分粒度过细

会消耗大量主题资源，造成系统负载过重。

> 错误示例：
>
> 按照用户 ID 区分，每个用户 ID 使用一个主题，如果用户量一多...

## 10、RocketMQ 怎么避免产生大量垃圾主题？

RocketMQ 支持自动创建主题，但是建议仅在测试环境使用，请勿在生产环境使用，否则会产生大量垃圾主题，无法管理和回收并浪费系统资源。因为创建和管理主题会占用一定的系统资源，因此生产环境需要严格管理主题资源，请勿随意进行增、删、改、查操作。

## 11、RocketMQ 中的主题和队列的关系是？消息存储在哪个位置？

主题是 RocketMQ 消息传输和存储的分组容器，队列是 RocketMQ 消息传输和存储的实际单元容器。

RocketMQ 中的主题是一个逻辑概念，并不是实际的消息容器，主题内部由多个队列组成，消息的存储和水平扩展实际上是通过主题内的队列实现的。

![](/images/RocketMQ/11.jpg)

RocketMQ 队列模型和 Kafka 的分区（Partition）模型类似，队列属于主题的一部分，虽然所有的消息资源以主题粒度管理，但实际的操作实现是面向队列。例如，生产者指定某个主题，向主题内发送消息，但实际消息发送到该主题下的某个队列中。

## 12、RocketMQ 主题的队列数可以更改吗？

Apache RocketMQ 的队列数可在创建主题或变更主题时设置修改，队列数量的设置应遵循少用够用原则，避免随意增加队列数量。

## 13、RocketMQ 中的主题，什么场景下需要增加队列数？

##### 常见队列增加场景：

##### 1、需要增加队列实现物理节点负载均衡

Apache RocketMQ 每个主题的多个队列可以分布在不同的服务节点上，在集群水平扩容增加节点后，为了保证集群流量的负载均衡，建议在新的服务节点上新增队列，或将旧的队列迁移到新的服务节点上。

##### 2、需要增加队列实现顺序消息性能扩展

在 Apache RocketMQ 服务端 4.x 版本中，顺序消息的顺序性在队列内生效的，因此顺序消息的并发度会在一定程度上受队列数量的影响，因此建议仅在系统性能瓶颈时再增加队列。

## 14、RocketMQ 主题内的队列数过多，可能会导致什么问题？

主题内队列数过多可能导致如下问题：

##### 1、集群元数据膨胀

Apache RocketMQ 会以队列粒度采集指标和监控数据，队列过多容易造成管控元数据膨胀。

##### 2、客户端压力过大

Apache RocketMQ 的消息读写都是针对队列进行操作，队列过多容易产生空轮询请求，增加系统负荷。

## 15、RocketMQ 中的消息最小存储单元是？

RocketMQ 中消息存储和传输的实际容器是**队列**，它也是 RocketMQ 消息的最小存储单元。RocketMQ 中的所有主题都是可以有多个队列组成的，以此实现队列数量的水平拆分和队列内部的流式存储。

## 16、RocketMQ 中的最小传输单元是？

Apache RocketMQ 中的最小传输单元是：**消息**，生产者将业务数据的负载和拓展属性包装成消息发送到 Apache RocketMQ 服务器，服务端按照相关语义将消息投递到消费端进行消费。

## 17、RocketMQ 支持哪些消息类型？

RocketMQ 支持的消息类型：

- 普通消息
- 顺序消息（FIFO）
- 定时/延时消息（Delay）
- 事务消息（Transaction）

## 18、RocketMQ 队列中的消息是顺序存储的吗？

RocketMQ 中的队列天然具备顺序性，即消息按照进入队列的顺序写入存储，同一队列间的消息天然存在顺序关系，队列头部为最早写入的消息，队列尾部为最新写入的消息。消息在队列中的位置和消息之间的顺序通过位点（Offset）进行标记管理。

## 19、RocketMQ 中的顺序消息是什么？

顺序消息是 RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。相比其他类型消息，顺序消息在发送、存储和投递的处理过程中，更多强调多条消息间的先后顺序关系。

RocketMQ 顺序消息的顺序关系通过消息组（MessageGroup）判定和识别，发送顺序消息时需要为每条消息设置归属的消息组，相同消息组的多条消息之间遵循先进先出的顺序关系，不同消息组、无消息组的消息之间不涉及顺序性。

基于消息组的顺序判定逻辑，支持按照业务逻辑做细粒度拆分，可以在满足业务局部顺序的前提下提高系统的并行度和吞吐能力。

> 示例场景：
>
> 一个订单下单后需要发送三条优惠券消息，需要按顺序发送和消费，但是不同订单之间是可以并行消费的。

## 20、RocketMQ 中的顺序消息分为哪几种？

顺序消息分为全局顺序和分区顺序两种。

##### 全局顺序

对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。

> 适用场景：
>
> 性能要求不高，所有的消息严格按照 FIFO 原则进行消费发布和消费的场景

##### 分区顺序

对于指定的一个 Topic，所有消息根据`Sharding key`进行区块分区，同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费，`Sharding key`是顺序消费中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。

> 适用场景：
>
> 性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。

## 21、RocketMQ 中的消息的顺序性分为两部分？

RocketMQ 的消息的顺序性分为两部分：

- **生产顺序性**：通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化；
- **消费顺序性**：通过消费者和服务端的协议保障消息消费严格按照存储的先后顺序来处理；

如果消息需要严格按照先进先出（FIFO）的原则处理，即先发送的先消费、后发送的后消费，则必须要同时满足生产顺序性和消费顺序性。

## 22、RocketMQ 使用顺序消息有什么要注意的吗？

##### 1、使用串行消费，避免使用批量消费导致乱序

消息消费建议串行处理，避免一次消费多条消息，否则可能出现乱序情况。

> 错误示例：
>
> 比如发送顺序为：1 -> 2 -> 3 -> 4，消费时批量消费，消费顺序为 1 -> 23（批量处理，失败）-> 23（重试处理）-> 4，此时可能由于消息 3 的失败导致消息 2 被重复处理，最后导致消费乱序。

##### 2、消息组尽可能打散，避免集中导致热点

RocketMQ 保证相同消息组的消息存储在同一个队列中，如果不同业务场景的消息都集中在少量或一个消息组中，则这些消息存储压力都会集中到服务端的少量队列或一个队列中，容易导致性能热点，且不利于扩展。一般建议消息组采用订单 ID、用户 ID 作为顺序参考，即同一个终端用户的消息保证顺序，不同用户的消息无需保证顺序。

因此建议将业务以消息组粒度进行拆分，例如，将订单 ID、用户 ID 作为消息组关键字，可实现同意终端用户的消息按照顺序处理，不同用户的消息无需保证顺序。

## 23、RocketMQ 中的延时消息是什么？

RocketMQ 中的定时/延时消息指的是，通过指定延时时间控制消息生产后不要立即投递，而是在延时间隔后才对消费者可见，即消息被发送至服务端后，在指定时间后才能被消费者消费。

> 在电商系统里很常见的一个取消订单的应用场景：
>
> 用户提交一个订单后，可以发送一个延时消息，30 分钟（可配置）后再去检查这个订单的状态，如果还是未付款状态就取消该订单释放库存。

## 24、RocketMQ 延时消息的实现原理是怎样的？

除了主动设置延时消息，消息消费失败也会进入延时消息队列，所以消息发送时间与设置的延时等级和重试次数有关。

延时消息不会马上写入到实际的 Topic，而是先暂存到`SCHEDULE_TOPIC_XXXX`Topic 中，相同等级的延时消息会存储到相同的队列以保证其顺序性，然后再由 Broker 检查`SCHEDULE_TOPIC_XXXX`中的消息是否到期，到期则写入到真实的 Topic 让消费者消费。

## 25、RocketMQ 延时消息可以设置任意时间吗？

RocketMQ 暂不支持任意时间的消息延时，需要设置几个固定的延时等级，从 1s 到 2 小时，分别对应着等级 1 到 18，如下所示：

> [1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h]

## 26、RocketMQ 使用延时消息有什么要注意的吗？

需要注意的一点是，**避免创建大量相同定时时刻的消息**。

如果将大量延时消息设置为同一时间段，则系统需要在同一时间处理大量消息，这就会造成系统巨大的压力，导致消息分发延迟，影响定时精度等问题。

## 27、RocketMQ 中的事务消息是什么？

事务消息是 RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。

RocketMQ 支持分布式事务消息，支持应用数据库更新和消息调用的事务一致性保障，它在普通消息基础上，支持二阶段的提交能力，将二阶段提交和本地事务绑定，实现全局提交结果的一致性。

![](/images/RocketMQ/27.jpg)

## 28、RocketMQ 使用事务消息有什么要注意的吗？

##### 1、避免大量未决事务导致超时

RocketMQ 支持在事务提交阶段异常的情况下发起事务回查，保证事务一致性，但生产者应该尽量避免本地事务返回未知结果，大量的事务检查会导致系统性能受损，容易导致事务处理延迟。

##### 2、正确处理进行中的事务

消息回查时，对于正在进行中的事务不要返回 Rollback 或 Commit 结果，应继续保持 Unknown 的状态。一般出现消息回查时事务正在处理的原因为事务执行较慢，消息回查太快。解决方案如下：

- 将第一次事务回查时间设置较大一些，但可能导致依赖回查的事务提交延迟较大；
- 程序能正确识别正在进行中的事务；

## 29、RocketMQ 中的消息是可变的吗？

RocketMQ 中的消息具备不可变性，在消息初始化发送和完成存储后即不可变。

消息本质上是已经产生并确定的事件，一旦产生后，消息的内容不会发生改变，即使经过传输链路的控制也不会发生变化，消费端获取的消息都是只读消息视图。

## 30、RocketMQ 中的消息有没有大小限制？

##### 系统默认的消息最大限制如下：

- 普通和顺序消息：4MB；
- 事务和定时或延时消息：64KB；

Apache RocketMQ 中的消息大小不得超过其类型所对应的限制，否则消息会发送失败。建议单个原子消息事件的数据大小做好严格控制，如果单条消息过大容易造成网络传输层压力，不利于异常重试和流量控制。

生产环境中如果需要传输超大负载，建议按照固定大小做报文拆分，或者结合文件存储等方法进行传输。

## 31、RocketMQ 支持消息持久化吗？

支持的， Apache RocketMQ 默认提供消息可靠存储机制，对消息进行持久化，即所有发送成功的消息都被持久化存储到队列中，然后存储到 Apache RocketMQ 服务端的存储文件中，保证消息的可回溯性和系统故障场景下的可恢复性。

## 32、RocketMQ 中的消息队列是无限存储的吗？

Apache RocketMQ 中的消息队列逻辑上都是无限存储的，即消息位点会从 0 到 Long.MAX 无限增加，但服务端物理节点的存储空间是有限的，Apache RocketMQ 会滚动删除队列中存储最早的消息。

## 33、RocketMQ 中的消息是永久存储的吗？

不是，在实际部署场景中，服务端节点的物理存储空间是有限的，消息无法做到永久存储。

Apache RocketMQ 提供一种消息存储和清理机制，使用存储时长作为消息存储的依据，即每个节点对外承诺消息的存储时长。在存储时长范围内的消息都会被保留，无论消息是否被消费，超过时长限制的消息则会被清理掉。

## 34、RocketMQ 中的消息存储多长时间比较适合？

这要看存储成本，只要存储成本可控，就尽可能地延长消息存储时间，时间越长越好。延长消息存储时长，可以为紧急故障恢复、应急问题排查和消息回溯带来更多的可操作空间。

## 35、RocketMQ 中的消息被消费后，会被立即清理吗？

不会立即清理，Apache RocketMQ 按存储时长统一控制消息是否保留，只要在存储时长范围内的消息都会被保留，无论消息是否被消费，超过时长限制的消息才会被清理掉。

## 36、RocketMQ 怎么定位一条消息？使用了什么索引？

RocketMQ 会为每个消息创建哈希索引，应用可以通过 topic、key 来定位（查询）这条消息内容，以及消息被谁消费，由于是哈希索引，为了避免哈希冲突，所以要保证 key 必须唯一。

## 37、RocketMQ 可以避免消息重复吗？如何处理？

RocketMQ 无法避免消息重复，如果业务对消费重复非常敏感，务必要在业务层面进行去重处理。

##### 去重处理方式：

可以借助关系数据库进行去重，首先确定消息的唯一标识，在消费之前判断消息唯一标识是否在关系数据库中存在，如果不存在则插入、并消费，否则跳过。另外还要考虑原子性问题，如果插入报主键冲突，则插入失败，直接跳过。

## 38、RocketMQ 消费者每次消费成功后，如何确保不会再重复处理该消息？

Apache RocketMQ 会基于每个消费者分组维护一份消费记录，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点，以此可以避免重复处理消息。

## 39、RocketMQ 怎么保证消息不丢失？

可以使用重试策略，可以在一定程度上保证了消息可以发送成功。

如果业务要求消息发送不能丢，需要对可能出现的异常做兜底，比如调用 send 同步方法发送失败时，则尝试将消息存储到 DB，然后有后台线程定时重试，确保消息一定到达 Broker。

## 40、RocketMQ 消息处理慢怎么处理？

##### RocketMQ 消息处理慢的处理方式：

1、提高消费并行度；

2、批量方式消费；

3、重置位点跳过非重要消息；

4、优化每条消息消费过程；

## 41、RocketMQ 怎么合理设置消费并行度？

绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。

##### 所以，应用必须要设置合理的并行度。

如下有几种修改消费并行度的方法：

- 同一个 ConsumerGroup 下通过增加 Consumer 实例数量来提高并行度，可以通过加机器，或者在已有机器启动多个进程的方式；
- 提高单个 Consumer 的消费并行线程；

## 42、RocketMQ 中的 keys 的使用场景是？

RocketMQ 建议每条消息映射到业务层面的一个**唯一标识**，设置 keys 字段，方便后续定位消息丢失问题，常见的设置策略比如有使用订单 ID、用户 ID、请求 ID 等比较离散的唯一标识来处理。

## 43、RocketMQ 中的 tags 的使用场景是？

RocketMQ 推荐的做法是**一个应用尽可能用一个 Topic**，而消息子类型则可以用**tags**来标识，如生产者在发送消息时指定 tags，然后消费者在订阅消息时可以通过 tags 做消息过滤。

## 44、RocketMQ 消息过滤有哪些实现方式？

Apache RocketMQ 支持 Tag 标签过滤和 SQL 属性过滤，这两种过滤方式对比如下：

| 对比项   | Tag 标签过滤                     | SLQ 属性过滤                                                       |
| -------- | -------------------------------- | ------------------------------------------------------------------ |
| 过滤目标 | 消息的 Tag 标签。                | 消息的属性，包括用户自定义属性以及系统属性（Tag 是一种系统属性）。 |
| 过滤能力 | 精准匹配。                       | SQL 语法匹配。                                                     |
| 适用场景 | 简单过滤场景，计算逻辑简单轻量。 | 复杂过滤场景，计算逻辑较复杂。                                     |

## 45、RocketMQ 消息过滤的实现原理是什么？

消息过滤实现原理图如下：

![](/images/RocketMQ/45.jpg)

消息过滤主要通过以下几个关键流程实现：

- **生产者**：生产者在初始化消息时预先为消息设置一些属性和标签，用于后续消费时指定过滤目标。
- **消费者**：消费者在初始化及后续消费流程中通过调用订阅关系注册接口，向服务端上报需要订阅指定主题的哪些消息，即过滤条件。
- **服务端**：消费者获取消息时会触发服务端的动态过滤计算，Apache RocketMQ 服务端根据消费者上报的过滤条件的表达式进行匹配，并将符合条件的消息投递给消费者。

## 46、RocketMQ 消息过滤的作用是什么？

消费者订阅了某个主题后，Apache RocketMQ 会将该主题中的所有消息投递给消费者。若消费者只需要关注部分消息，可通过设置过滤条件在 Apache RocketMQ 服务端进行过滤，只获取到需要关注的消息子集。避免接收到大量无效的消息。

使用 Apache RocketMQ 的消息过滤功能，可以帮助消费者更高效地过滤自己需要的消息集合，避免大量无效投递给消费者，降低下游系统处理压力。

## 47、RocketMQ 中的消息可以从任意位置读取任意数量的消息吗？

可以的，RocketMQ 基于队列的存储模型，可以确保消息从任意位点、读取任意数量的消息，以此实现类似聚合读取、回溯读取等特性，这些特性是 RabbitMQ、ActiveMQ 等非队列存储模型不具备的。

### RocketMQ 中的生产者和主题的关系是？

Apache RocketMQ 的生产者和主题是**多对多**的关系，支持同一个生产者向多个主题发送消息。

##### 1、不建议单一进程创建大量生产者

对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。

##### 2、不建议频繁创建和销毁生产者

Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。

### RocketMQ 中的生产者必须要配置生产者组吗？

从 Apache RocketMQ 5.x 版本开始，生产者是匿名的，无需配置和管理生产者分组（ProducerGroup），而对于历史版本服务端 3.x 和 4.x 版本，已经使用的生产者组可以废弃无需再设置，且不会对当前业务产生影响。

## 50、RocketMQ 消息是推模式，还是拉模式？

RocketMQ 采用的是**拉模式（Pull）**，由客户端主动拉取消息消费。

## 51、RocketMQ 支持哪几种消费者类型？

Apache RocketMQ 支持以下三种类型的消费者：

- PushConsumer
- SimpleConsumer
- PullConsumer

具体区别如下：

| 对比项       | PushConsumer                                                             | SimpleConsumer                                       | PullConsumer                             |
| ------------ | ------------------------------------------------------------------------ | ---------------------------------------------------- | ---------------------------------------- |
| 接口方式     | 使用监听器回调接口返回消费结果，消费者仅允许在监听器范围内处理消费逻辑。 | 业务方自行实现消息处理，并主动调用接口返回消费结果。 |                                          |
| 消费并发管理 | 由 SDK 管理消费并发度。                                                  | 由业务方消费逻辑自行管理消费线程。                   | 由业务方消费逻辑自行管理消费线程。       |
| 负载均衡粒度 | 5.0 SDK 是消息粒度，更均衡，早期版本是队列维度                           | 消息粒度，更均衡                                     | 队列粒度，吞吐攒批性能更好，但容易不均衡 |
| 接口灵活度   | 高度封装，不够灵活。                                                     | 原子接口，可灵活自定义。                             | 原子接口，可灵活自定义。                 |
| 适用场景     | 适用于无自定义流程的业务消息开发场景。                                   | 适用于需要高度自定义业务流程的业务开发场景。         | 仅推荐在流处理框架场景下集成使用         |

在实际使用场景中，PullConsumer 仅推荐在流处理框架中集成使用，大多数消息收发场景使用 PushConsumer 和 SimpleConsumer 就可以满足需求。

> 危险！！！
>
> 生产环境中相同的 ConsumerGroup 下严禁混用 PullConsumer 和其他两种消费者，否则会导致消息消费异常。

## 52、RocketMQ 中的消费者和主题的关系是？

Apache RocketMQ 的消费者和主题是**多对多**的关系，一个消费者可以同时消费多个主题中的消息，一个主题也可以同时被多个消费者消费。

## 53、RocketMQ 中的消费者分组和消费者之间的关系？

Apache RocketMQ 中的消费者（Consumer）是消费消息的运行实体，消费者分组（ConsumerGroup）则是统一管理底层运行的多个消费者（Consumer）。

消息订阅是以消费者组（ConsumerGroup）为粒度进行管理的，消费者组（ConsumerGroup）它并不是运行实体，而是一个逻辑资源。消费者（Consumer）必须被指定到某一个消费组（ConsumerGroup）中，同一个消费组（ConsumerGroup）的多个消费者（Consumer）必须保持消费逻辑和配置一致，共同分担该消费组（ConsumerGroup）订阅的消息，实现消费能力的水平扩展。

Apache RocketMQ 要求同一分组下的所有消费者一下消费行为保持一致：

- 投递顺序；
- 消费重试策略；

## 54、RocketMQ 的消费者拆分设计，应遵循那些原则？

对于消费者分组的拆分设计，建议遵循以下原则：

##### 1、消费者的投递顺序一致

同一消费者分组下所有消费者的消费投递顺序是相同的，同意都是顺序投递或并发投递，不同业务场景不能混用消费者分组。

##### 2、消费者业务类型一致

一般消费者分组和主题对应，不同业务域对消息消费的要求不同，例如消息过滤属性、消费重试策略不同。因此，不同业务域主题的消费建议使用不同的消费者分组，避免一个消费者分组消费超过 10 个主题。

Apache RocketMQ 虽然提供了自动创建消费者分组的功能，但是建议仅在测试环境使用，生产环境请勿打开，避免产生大量消费者分组，无法管理和回收，且浪费系统资源。

## 55、RocketMQ 消费者启动后从哪里开始消费消息？

Apache RocketMQ 会基于每个消费者分组维护一份消费记录，即消费位点，从服务端最新消息又再次重新上线时，会严格按照服务端保存的历史位点进度继续处理消息，如果服务端保存的历史位点信息已过期被删除，此时消费位点向前移动至服务端存储的最小位点。

## 56、RocketMQ 消息位点和消费位点的区别？

##### 消息位点（Offset）

消息是按到达服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的 Long 类型坐标，这个坐标被定义为消息位点。任意一个消息队列在逻辑上都是无限存储，即消息位点会从 0 到 Long.MAX 无限增加。通过主题、队列和位点就可以定位任意一条消息的位置。

Apache RocketMQ 定义队列中最早的一条消息的位点为最小消息位点（MinOffset），最新一条消息的位点为最大消息位点（MaxOffset），如下图所示：

![](/images/RocketMQ/56_1.jpg)

虽然消息队列逻辑上是无限存储，但由于服务端物理节点的存储空间有限，Apache RocketMQ 会滚动删除队列中存储最早的消息。因此，消息的最小消息位点和最大消息位点会一直递增变化。

##### 消费位点（ConsumerOffset）

Apache RocketMQ 是通过消费位点管理消息的消费进度的，每条消息被某个消费者消费完成后不会立即在队列中删除，Apache RocketMQ 会基于每个消费者分组维护一份消费记录，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点。

队列中的消息位点 MinOffset、MaxOffset 和每个消费者分组的消费位点 ConsumerOffset 的关系图如下：

![](/images/RocketMQ/56_2.jpg)

## 57、RocketMQ 什么场景下需要重置消费位点？

若消费者分组的初始消费位点或当前消费位点不符合业务预期时，可以通过重置消费位点调整消费进度，比如以下场景：

- 初始消费位点不符合需求；
- 消费堆积时，快速丢弃清理；
- 业务回溯，纠正处理；

重置消费位点会给系统带来额外处理压力，可能会影响消息的读写性能，请在适用场景下谨慎执行，并提前做好合理性和必要性评估。

## 58、RocketMQ 消费者负载均衡策略是指什么？

消费者内共享消费场景下，消费者分组内多个消费者共同分担消息，消息按照哪种逻辑分配给哪个消费者，就是由消费者负载均衡策略所决定的。

消费者从 Apache RocketMQ 获取消息消费时，通过消费者负载均衡策略，可将主题内的消息分配给指定消费者分组中的多个消费者共同分担，提高消费并发能力和消费者的水平扩展能力。

## 59、RocketMQ 什么时候会触发重新负载均衡？会带来什么问题？

RocketMQ 在消费者上线或下线、服务端扩缩容等场景下，都会触发短暂的重新负载均衡动作。此时可能会存在短暂的负载不一致情况，出现少量消息重复的现象。

**因此，需要在下游消费逻辑中做好消息幂等去重处理。**

## 60、RocketMQ 消费者负载均衡策略有哪几种模式？

根据消费者类型的不同，消费者负载均衡策略分为以下两种模式：

- **消息粒度负载均衡**：PushConsumer 和 SimpleConsumer 的默认负载策略；
- **队列粒度负载均衡**：PullConsumer 的默认负载策略；

## 61、RocketMQ 消费者建议打印日志吗？

这个要看线上环境的消息量：

- 如果消息量较少（TPS 不高），建议在消费入口方法打印消息，消费耗时等，方便后续排查问题；
- 如果消息量较多（TPS 很高），则不建议打印日志，避免日志太多影响性能；

## 62、RocketMQ 消息发送重试机制有什么用？

Apache RocketMQ 客户端连接服务端发起消息发送请求时，可能会因为网络故障、服务异常等原因导致调用失败。

为保证消息的可靠性，Apache RocketMQ 在客户端 SDK 中内置请求重试逻辑，尝试通过重试发送达到最终调用成功的效果。同步发送和异步发送模式均支持消息发送重试。

## 63、RocketMQ 在什么情况下触发消息发送重试？

##### 触发消息发送重试机制的条件如下：

- 客户端消息发送请求调用失败或请求超时
- 网络异常造成连接失败或请求超时。
- 服务端节点处于重启或下线等状态造成连接失败。
- 服务端运行慢造成请求超时。
- 服务端返回失败错误码
  - 系统逻辑错误：因运行逻辑不正确造成的错误。
  - 系统流控错误：因容量超限造成的流控错误。

## 64、RocketMQ 消息发送重试的流程是怎样的？

生产者在初始化时设置消息发送最大重试次数，当出现上述触发条件的场景时，生产者客户端会按照设置的重试次数一直重试发送消息，直到消息发送成功或达到最大重试次数重试结束，并在最后一次重试失败后返回错误响应。

## 65、RocketMQ 消息发送重试是否会阻塞业务调用？

这要看不同的发送类型：

- **同步发送**：调用线程**会一直阻塞**，直到某次重试成功或最终重试失败，抛出错误码和异常；
- **异步发送**：调用线程**不会阻塞**，但调用结果会通过异常事件或者成功事件返回；

## 66、RocketMQ 消息发送重试有什么不足？

RocketMQ 消息重试不足的是，对于事务消息，只会进行透明重试（transparent retries），网络超时或异常等场景不会进行重试。

## 67、RocketMQ 消费重试的作用是什么？

消费重试指的是，消费者在消费某条消息失败后，Apache RocketMQ 服务端会根据重试策略重新消费该消息，超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中。

## 68、RocketMQ 消费重试的应用场景是？

Apache RocketMQ 的消费重试主要解决的是业务处理逻辑失败的消费完整性问题，是一种为业务兜底的策略，不应该被用作业务流程控制，消息重试适用业务处理失败且当前消费为小概率事件的场景，不适合连续性失败的场景下使用，例如消费限流场景。

##### 建议、推荐以下消费失败场景使用重试机制：

- 业务处理失败，且失败原因跟当前的消息内容相关，比如该消息对应的事务状态还未获取到，预期一段时间后可执行成功；
- 消费失败的原因不会导致连续性，即当前消息消费失败是一个小概率事件，不是常态化的失败，后面的消息大概率会消费成功。此时可以对当前消息进行重试，避免进程阻塞。

## 69、RocketMQ 在什么情况下会触发消费重试？

##### 消费重试的触发条件如下：

- 消费失败，包括消费者返回消息失败状态标识或抛出非预期异常；
- 消息处理超时，包括在 PushConsumer 中排队超时。

## 70、RocketMQ 怎么避免无限消费重试？

Apache RocketMQ 支持自定义消费重试次数，建议通过减少重试次数 + 延长重试间隔来降低系统压力，避免出现无限重试或大量重试的情况。

## 71、RocketMQ 如果出现异常需要需要故障恢复，已消费的消息是否被重新消费？

不会，因为消费位点的保存和恢复是基于 Apache RocketMQ 服务端的存储实现的，和任何消费者无关。因此 Apache RocketMQ 支持跨消费者的消费进度恢复。

## 72、RocketMQ 消息流控是指什么？

消息流控指的是系统容量或水位过高，Apache RocketMQ 服务端会通过快速失败返回流控错误来避免底层资源承受过高压力。

## 73、RocketMQ 触发流控时客户端行为是什么？

当系统触发消息发送流控时，客户端会收到系统限流错误和异常，错误码信息如下：

- reply-code：530
- reply-text：TOO_MANY_REQUESTS

客户端收到系统流控错误码后，会根据指数退避策略进行消息发送重试。

## 74、RocketMQ 在什么情况下会触发流控？

Apache RocketMQ 的消息流控触发条件如下：

##### 1、存储压力大

参考消费进度管理的原理机制，消费者分组的初始消费位点为当前队列的最大消费位点。若某些场景例如业务上新等需要回溯到指定时刻前开始消费，此时队列的存储压力会瞬间飙升，触发消息流控。

##### 2、服务端请求任务排队溢出

若消费者消费能力不足，导致队列中有大量堆积消息，当堆积消息超过一定数量后会触发消息流控，减少下游消费系统压力。

## 75、RocketMQ 应该如何避免触发流控？

触发限流的根本原因是系统容量或水位过高，可以利用可观测性功能监控系统水位容量等，保证底层资源充足，避免触发流控机制。

## 76、RocketMQ 应该如何应对突发流控？

如果因为突发原因触发消息流控，且客户端内置的重试流程实行失败，则建议业务方将请求调用临时替换到其他系统进行应急处理。

## 77、RocketMQ 服务端由哪几个组件组成？

RocketMQ 由以下组件组成：

- **NameServer**：主要用于 Broker 管理及路由管理；
- **Broker Server**：主要负责消息的存储、传递、查询等；
- **Proxy (RocketMQ 5.0+)**：主要负责客户端协议适配、权限管理、消费管理等计算逻辑；

## 78、RocketMQ 需要依赖 Zookeeper 吗？

不需要，RocketMQ 可以独立运行。

## 79、RocketMQ Broker 有哪几种角色？怎么选用？

##### RocketMQ Broker 角色分为以下几种：

- ASYNC_MASTER (异步主机)
- SYNC_MASTER (同步主机)
- SLAVE (从机)

##### RocketMQ Broker 选用方案：

如果对消息的可靠性要求比较严格，可以采用 SYNC_MASTER + SLAVE 的部署方式。

如果对消息可靠性要求不高，可以采用 ASYNC_MASTER + SLAVE 的部署方式。

如果只是测试方便，则可以选择仅 ASYNC_MASTER 或仅 SYNC_MASTER 的部署方式。

## 80、RocketMQ Broker 如果崩溃了会有什么影响？

##### （1）Master 节点崩溃

消息不能发送到这个代理集群，但是如果你有另一个可用的代理集群，消息仍然可以在有主题的情况下发送。仍然可以从 Slave 节点消费消息。

##### （2）部分 Slave 节点挂了

只要有另一个工作的 Slave，发送消息不受影响。消费消息也不受影响，除非消费者组设置有先从这个 Slave 消费。默认情况下，消费者组从 Master 消费。

##### （3）所有 Slave 节点崩溃

向 Master 发送消息无效。然而，如果 Master 是 SYNC_MASTER，Producer 会得到一个 SLAVE_NOT_AVAILABLE，表明消息没有被发送到任何 Slave。消费消息也不受影响，除非消费者组设置优先从 Slave 消费。默认情况下，消费者组从 Master 消费。

## 81、RocketMQ 如果部分节点发生异常，是否影响消息发送？

不会影响，因为 Apache RocketMQ 在客户端中内置请求重试逻辑，尝试通过重试发送达到最终调用成功的效果。

## 82、RocketMQ 支持哪几种部署方式？

Apache RocketMQ 5.0+版本包括 NameServer、Broker、Proxy 组件，Proxy 和 Broker 可以根据需要分为 Local 模式和 Cluster 模式，一般情况下如果没有特殊需求，可以选用 Local 模式。

- **Local 模式**：Broker 和 Proxy 同进程部署，只是在原有 Broker 的配置基础上新增 Proxy 的简易配置就可以运行。
- **Cluster 模式**：Broker 和 Proxy 分别部署，即在原有的集群基础上再额外部署 Proxy 即可。

## 83、RocketMQ 怎么替换原生的副本存储机制？

RocketMQ 部署时可以根据需要选择使用**DLeger**来替换原生的副本存储机制，DLedger 是一套基于 Raft 协议的分布式日志存储组件，基于 DLedger 可以快速构建和部署可以自动容灾切换的 RocketMQ 集群。

## 84、RocketMQ 怎么优化 JVM 性能？

（1）推荐使用最新的 JDK 版本，并设置相同的 Xms 和 Xmx 值，以防止 JVM 调整推大小影响性能。

（2）Broker 建议配置足够大内存，避免使用小内存机器部署，因为 Broker 是重度依赖内存 PageCache 做性能优化的，内存过小可能造成性能不稳定。当 JVM 是默认 8 字节对齐，简易配置最大堆内存不要超过 32G，否则会影响 JVM 的指针压缩技术，浪费内存。

（3）如果不关心 RocketMQ Broker 的启动时间，可以通过“预触摸”Java 堆以确保在 JVM 初始化期间每个页面都将被分配。

## 85、RocketMQ 在线运维使用什么工具？

可以使用官方的 RocketMQ Dashboard，它是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。

![](/images/RocketMQ/85.jpg)

## 86、RocketMQ Connect 是什么？

RocketMQ Connect 是一个独立的分布式，可伸缩，容错的系统，它主要为 RocketMQ 提供与各种外部系统的数据的流入流出能力，用户不需要要编程，只需要简单的配置即可使用 RocketMQ Connect。

> 例如：
>
> 从 MySQL 同步数据到 RocketMQ，只需要配置同步所需的 MySQL 的账号密码，链接地址，和需要同步的数据库，表名就可以了。

## 87、RocketMQ Streams 是什么？

RocketMQ Streams 是基于 RocketMQ 的轻量级流计算引擎，它能以 SDK 的方式集成到应用中，无须部署复杂的流计算服务端即可获得流计算能力。

因此，RocketMQ Streams 具有资源消耗少、扩展性好、支持流计算算子丰富的特点。

整体架构图如下：

![](/images/RocketMQ/87.jpg)
